import {
  createElementBlock,
  normalizeStyle,
  openBlock
} from "./chunk-3OA5VQTW.js";
import {
  __commonJS,
  __toESM
} from "./chunk-HUBM7RA2.js";

// node_modules/@canvasjs/charts/canvasjs.min.js
var require_canvasjs_min = __commonJS({
  "node_modules/@canvasjs/charts/canvasjs.min.js"(exports, module) {
    (function() {
      function na(h, n) {
        h.prototype = db(n.prototype);
        h.prototype.constructor = h;
        h.base = n.prototype;
      }
      function db(h) {
        function n() {
        }
        n.prototype = h;
        return new n();
      }
      function Xa(h, n, E) {
        "millisecond" === E ? h.setMilliseconds(h.getMilliseconds() + 1 * n) : "second" === E ? h.setSeconds(h.getSeconds() + 1 * n) : "minute" === E ? h.setMinutes(h.getMinutes() + 1 * n) : "hour" === E ? h.setHours(h.getHours() + 1 * n) : "day" === E ? h.setDate(h.getDate() + 1 * n) : "week" === E ? h.setDate(h.getDate() + 7 * n) : "month" === E ? h.setMonth(h.getMonth() + 1 * n) : "year" === E && h.setFullYear(h.getFullYear() + 1 * n);
        return h;
      }
      function Z(h, n) {
        var E = false;
        0 > h && (E = true, h *= -1);
        h = "" + h;
        for (n = n ? n : 1; h.length < n; )
          h = "0" + h;
        return E ? "-" + h : h;
      }
      function Ha(h) {
        if (!h)
          return h;
        h = h.replace(/^\s\s*/, "");
        for (var n = /\s/, E = h.length; n.test(h.charAt(--E)); )
          ;
        return h.slice(0, E + 1);
      }
      function Da(h) {
        h.roundRect = function(h2, E, r2, w2, U, A, v2, B2) {
          v2 && (this.fillStyle = v2);
          B2 && (this.strokeStyle = B2);
          "undefined" === typeof U && (U = 5);
          this.lineWidth = A;
          this.beginPath();
          this.moveTo(h2 + U, E);
          this.lineTo(h2 + r2 - U, E);
          this.quadraticCurveTo(h2 + r2, E, h2 + r2, E + U);
          this.lineTo(h2 + r2, E + w2 - U);
          this.quadraticCurveTo(h2 + r2, E + w2, h2 + r2 - U, E + w2);
          this.lineTo(h2 + U, E + w2);
          this.quadraticCurveTo(h2, E + w2, h2, E + w2 - U);
          this.lineTo(h2, E + U);
          this.quadraticCurveTo(h2, E, h2 + U, E);
          this.closePath();
          v2 && this.fill();
          B2 && 0 < A && this.stroke();
        };
      }
      function Ra(h, n) {
        return h - n;
      }
      function O(h) {
        var n = ((h & 16711680) >> 16).toString(16), E = ((h & 65280) >> 8).toString(16);
        h = ((h & 255) >> 0).toString(16);
        n = 2 > n.length ? "0" + n : n;
        E = 2 > E.length ? "0" + E : E;
        h = 2 > h.length ? "0" + h : h;
        return "#" + n + E + h;
      }
      function eb(h, n) {
        var E = this.length >>> 0, r2 = Number(n) || 0, r2 = 0 > r2 ? Math.ceil(r2) : Math.floor(r2);
        for (0 > r2 && (r2 += E); r2 < E; r2++)
          if (r2 in this && this[r2] === h)
            return r2;
        return -1;
      }
      function r(h) {
        return null === h || "undefined" === typeof h;
      }
      function Ea(h) {
        h.indexOf || (h.indexOf = eb);
        return h;
      }
      function fb(h) {
        if (ta.fSDec)
          h[W("`eeDwdouMhrudods")](W("e`u`@ohl`uhnoHuds`uhnoDoe"), function() {
            ta._fTWm && ta._fTWm(h);
          });
      }
      function Ya(h, n, E) {
        E = E || "normal";
        var r2 = h + "_" + n + "_" + E, w2 = Za[r2];
        if (isNaN(w2)) {
          try {
            if (!wa) {
              var U = document.body;
              wa = document.createElement("span");
              wa.innerHTML = "";
              var A = document.createTextNode("Mpgyi");
              wa.appendChild(A);
              U.appendChild(wa);
            }
            wa.style.display = "";
            S(wa, { position: "absolute", left: "0px", top: "-20000px", padding: "0px", margin: "0px", border: "none", whiteSpace: "pre", lineHeight: "normal", fontFamily: h, fontSize: n + "px", fontWeight: E });
            w2 = Math.round(wa.offsetHeight);
            wa.style.display = "none";
          } catch (v2) {
            w2 = Math.ceil(1.1 * n);
          }
          w2 = Math.max(w2, n);
          Za[r2] = w2;
        }
        return w2;
      }
      function J(h, n) {
        var E = [];
        if (E = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [
          8,
          2
        ], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[h || "solid"])
          for (var r2 = 0; r2 < E.length; r2++)
            E[r2] *= n;
        else
          E = [];
        return E;
      }
      function K(h, n, E, w2, sa) {
        w2 = w2 || [];
        sa = r(sa) ? gb ? { passive: false, capture: false } : false : sa;
        w2.push([h, n, E, sa]);
        return h.addEventListener ? (h.addEventListener(n, E, sa), E) : h.attachEvent ? (w2 = function(n2) {
          n2 = n2 || window.event;
          n2.preventDefault = n2.preventDefault || function() {
            n2.returnValue = false;
          };
          n2.stopPropagation = n2.stopPropagation || function() {
            n2.cancelBubble = true;
          };
          E.call(h, n2);
        }, h.attachEvent("on" + n, w2), w2) : false;
      }
      function hb(h) {
        if (h._menuButton)
          h.exportEnabled ? (S(h._menuButton, { backgroundColor: h.toolbar.itemBackgroundColor, color: h.toolbar.fontColor }), Ma(h._menuButton), pa(h, h._menuButton, "menu")) : ua(h._menuButton);
        else if (h.exportEnabled && w) {
          var n = false;
          h._menuButton = document.createElement("button");
          pa(h, h._menuButton, "menu");
          h._toolBar.appendChild(h._menuButton);
          K(h._menuButton, "touchstart", function(h2) {
            n = true;
          }, h.allDOMEventHandlers);
          K(h._menuButton, "click", function() {
            "none" !== h._dropdownMenu.style.display || h._dropDownCloseTime && 500 >= new Date().getTime() - h._dropDownCloseTime.getTime() || (h._dropdownMenu.style.display = "block", h._menuButton.blur(), h._dropdownMenu.focus());
          }, h.allDOMEventHandlers, true);
          K(h._menuButton, "mousemove", function() {
            n || (S(h._menuButton, { backgroundColor: h.toolbar.itemBackgroundColorOnHover, color: h.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && S(h._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
          }, h.allDOMEventHandlers, true);
          K(h._menuButton, "mouseout", function() {
            n || (S(h._menuButton, {
              backgroundColor: h.toolbar.itemBackgroundColor,
              color: h.toolbar.fontColor
            }), 0 >= navigator.userAgent.search("MSIE") && S(h._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
          }, h.allDOMEventHandlers, true);
        }
        if (h.exportEnabled && h._dropdownMenu) {
          S(h._dropdownMenu, { backgroundColor: h.toolbar.itemBackgroundColor, color: h.toolbar.fontColor });
          for (var E = h._dropdownMenu.childNodes, r2 = [h._cultureInfo.printText, h._cultureInfo.saveJPGText, h._cultureInfo.savePNGText], sa = 0; sa < E.length; sa++)
            S(E[sa], {
              backgroundColor: h.toolbar.itemBackgroundColor,
              color: h.toolbar.fontColor
            }), E[sa].innerHTML = r2[sa];
        } else
          !h._dropdownMenu && (h.exportEnabled && w) && (n = false, h._dropdownMenu = document.createElement("div"), h._dropdownMenu.setAttribute("tabindex", -1), E = -1 !== h.theme.indexOf("dark") ? "black" : "#888888", S(h._dropdownMenu, {
            position: "absolute",
            zIndex: 1,
            userSelect: "none",
            MozUserSeelct: "none",
            WebkitUserSelect: "none",
            msUserSelect: "none",
            cursor: "pointer",
            right: "0px",
            top: "25px",
            minWidth: "120px",
            outline: 0,
            fontSize: "14px",
            fontFamily: "Arial, Helvetica, sans-serif",
            padding: "5px 0px 5px 0px",
            textAlign: "left",
            lineHeight: "10px",
            backgroundColor: h.toolbar.itemBackgroundColor,
            boxShadow: "2px 2px 10px" + E
          }), h._dropdownMenu.style.display = "none", h._toolBar.appendChild(h._dropdownMenu), K(h._dropdownMenu, "blur", function() {
            ua(h._dropdownMenu);
            h._dropDownCloseTime = new Date();
          }, h.allDOMEventHandlers, true), E = document.createElement("div"), S(E, { padding: "12px 8px 12px 8px" }), E.innerHTML = h._cultureInfo.printText, E.style.backgroundColor = h.toolbar.itemBackgroundColor, E.style.color = h.toolbar.fontColor, h._dropdownMenu.appendChild(E), K(E, "touchstart", function(h2) {
            n = true;
          }, h.allDOMEventHandlers), K(E, "mousemove", function() {
            n || (this.style.backgroundColor = h.toolbar.itemBackgroundColorOnHover, this.style.color = h.toolbar.fontColorOnHover);
          }, h.allDOMEventHandlers, true), K(E, "mouseout", function() {
            n || (this.style.backgroundColor = h.toolbar.itemBackgroundColor, this.style.color = h.toolbar.fontColor);
          }, h.allDOMEventHandlers, true), K(E, "click", function() {
            h.print();
            ua(h._dropdownMenu);
          }, h.allDOMEventHandlers, true), E = document.createElement("div"), S(E, { padding: "12px 8px 12px 8px" }), E.innerHTML = h._cultureInfo.saveJPGText, E.style.backgroundColor = h.toolbar.itemBackgroundColor, E.style.color = h.toolbar.fontColor, h._dropdownMenu.appendChild(E), K(E, "touchstart", function(h2) {
            n = true;
          }, h.allDOMEventHandlers), K(E, "mousemove", function() {
            n || (this.style.backgroundColor = h.toolbar.itemBackgroundColorOnHover, this.style.color = h.toolbar.fontColorOnHover);
          }, h.allDOMEventHandlers, true), K(
            E,
            "mouseout",
            function() {
              n || (this.style.backgroundColor = h.toolbar.itemBackgroundColor, this.style.color = h.toolbar.fontColor);
            },
            h.allDOMEventHandlers,
            true
          ), K(E, "click", function() {
            h.exportChart({ format: "jpeg", fileName: h.exportFileName });
            ua(h._dropdownMenu);
          }, h.allDOMEventHandlers, true), E = document.createElement("div"), S(E, { padding: "12px 8px 12px 8px" }), E.innerHTML = h._cultureInfo.savePNGText, E.style.backgroundColor = h.toolbar.itemBackgroundColor, E.style.color = h.toolbar.fontColor, h._dropdownMenu.appendChild(E), K(E, "touchstart", function(h2) {
            n = true;
          }, h.allDOMEventHandlers), K(E, "mousemove", function() {
            n || (this.style.backgroundColor = h.toolbar.itemBackgroundColorOnHover, this.style.color = h.toolbar.fontColorOnHover);
          }, h.allDOMEventHandlers, true), K(E, "mouseout", function() {
            n || (this.style.backgroundColor = h.toolbar.itemBackgroundColor, this.style.color = h.toolbar.fontColor);
          }, h.allDOMEventHandlers, true), K(E, "click", function() {
            h.exportChart({ format: "png", fileName: h.exportFileName });
            ua(h._dropdownMenu);
          }, h.allDOMEventHandlers, true));
      }
      function $a(h, n, E) {
        h *= ia;
        n *= ia;
        h = E.getImageData(h, n, 2, 2).data;
        n = true;
        for (E = 0; 4 > E; E++)
          if (h[E] !== h[E + 4] | h[E] !== h[E + 8] | h[E] !== h[E + 12]) {
            n = false;
            break;
          }
        return n ? h[0] << 16 | h[1] << 8 | h[2] : 0;
      }
      function la(h, n, E) {
        return h in n ? n[h] : E[h];
      }
      function Na(h, n, E, va) {
        w && ab ? (va = !r(va) && va ? h.getContext("2d", { willReadFrequently: true }) : h.getContext("2d"), Oa = va.webkitBackingStorePixelRatio || va.mozBackingStorePixelRatio || va.msBackingStorePixelRatio || va.oBackingStorePixelRatio || va.backingStorePixelRatio || 1, ia = Sa / Oa, h.width = n * ia, h.height = E * ia, Sa !== Oa && (h.style.width = n + "px", h.style.height = E + "px", va.scale(ia, ia))) : (h.width = n, h.height = E);
      }
      function ib(h) {
        if (!jb) {
          var n = false, E = false;
          "undefined" === typeof oa.Chart.creditHref ? (h.creditHref = W("iuuqr;..b`ow`rkr/bnl."), h.creditText = W("B`ow`rKR/bnl")) : (n = h.updateOption("creditText"), E = h.updateOption("creditHref"));
          if (h.creditHref && h.creditText) {
            h._creditLink || (h._creditLink = document.createElement("a"), h._creditLink.setAttribute("class", "canvasjs-chart-credit"), h._creditLink.setAttribute("title", "JavaScript Charts"), S(h._creditLink, {
              outline: "none",
              margin: "0px",
              position: "absolute",
              right: "2px",
              top: h.height - 14 + "px",
              color: "dimgrey",
              textDecoration: "none",
              fontSize: "11px",
              fontFamily: "Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"
            }), h._creditLink.setAttribute("tabIndex", -1), h._creditLink.setAttribute("target", "_blank"));
            if (0 === h.renderCount || n || E)
              h._creditLink.setAttribute("href", h.creditHref), h._creditLink.innerHTML = h.creditText;
            h._creditLink && h.creditHref && h.creditText ? (h._creditLink.parentElement || h._canvasJSContainer.appendChild(h._creditLink), h._creditLink.style.top = h.height - 14 + "px") : h._creditLink.parentElement && h._canvasJSContainer.removeChild(h._creditLink);
          }
        }
      }
      function ra(h, n, E) {
        Ia && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
        var r2 = document.createElement("canvas");
        r2.setAttribute("class", "canvasjs-chart-canvas");
        Na(r2, h, n, E);
        w || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(r2);
        return r2;
      }
      function S(h, n) {
        for (var E in n)
          h.style[E] = n[E];
      }
      function pa(h, n, E) {
        n.getAttribute("state") || (n.style.backgroundColor = h.toolbar.itemBackgroundColor, n.style.color = h.toolbar.fontColor, n.style.border = "none", S(n, {
          WebkitUserSelect: "none",
          MozUserSelect: "none",
          msUserSelect: "none",
          userSelect: "none"
        }));
        n.getAttribute("state") !== E && (n.setAttribute("state", E), n.setAttribute("type", "button"), S(n, { padding: "5px 12px", cursor: "pointer", "float": "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), n.innerHTML = "<img src='" + kb[E].image + "' alt='" + h._cultureInfo[E + "Text"] + "' />", S(n.childNodes[0], { height: "95%", pointerEvents: "none" }));
        n.setAttribute("title", h._cultureInfo[E + "Text"]);
      }
      function Ma() {
        for (var h = null, n = 0; n < arguments.length; n++)
          h = arguments[n], h.style && (h.style.display = "inline");
      }
      function ua() {
        for (var h = null, n = 0; n < arguments.length; n++)
          (h = arguments[n]) && h.style && (h.style.display = "none");
      }
      function Ta(h, n, E, r2, w2) {
        if (null === h || "undefined" === typeof h)
          return "undefined" === typeof E ? n : E;
        h = parseFloat(h.toString()) * (0 <= h.toString().indexOf("%") ? n / 100 : 1);
        "undefined" !== typeof r2 && (h = Math.min(r2, h), "undefined" !== typeof w2 && (h = Math.max(w2, h)));
        return !isNaN(h) && h <= n && 0 <= h ? h : "undefined" === typeof E ? n : E;
      }
      function X(h, n, E, w2, v2) {
        this._defaultsKey = h;
        this._themeOptionsKey = n;
        this._index = w2;
        this.parent = v2;
        this._eventListeners = [];
        h = {};
        this.theme && r(this.parent) && r(n) && r(w2) ? h = r(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[n]) && (null === w2 ? h = this.parent.themeOptions[n] : 0 < this.parent.themeOptions[n].length && (w2 = Math.min(this.parent.themeOptions[n].length - 1, w2), h = this.parent.themeOptions[n][w2]));
        this.themeOptions = h;
        this.options = E ? E : { _isPlaceholder: true };
        this.setOptions(this.options, h);
      }
      function Fa(h, n, r2, w2, v2) {
        "undefined" === typeof v2 && (v2 = 0);
        this._padding = v2;
        this._x1 = h;
        this._y1 = n;
        this._x2 = r2;
        this._y2 = w2;
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      }
      function ka(h, n) {
        ka.base.constructor.call(this, "TextBlock", null, n, null, null);
        this.ctx = h;
        this._isDirty = true;
        this._wrappedText = null;
        this._initialize();
      }
      function Ua(h, n) {
        Ua.base.constructor.call(this, "Toolbar", "toolbar", n, null, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "toolbar";
      }
      function ya(h, n) {
        ya.base.constructor.call(this, "Title", "title", n, null, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "title";
        if (r(this.options.margin) && h.options.subtitles) {
          for (var E = h.options.subtitles, w2 = 0; w2 < E.length; w2++)
            if ((r(E[w2].horizontalAlign) && "center" === this.horizontalAlign || E[w2].horizontalAlign === this.horizontalAlign) && (r(E[w2].verticalAlign) && "top" === this.verticalAlign || E[w2].verticalAlign === this.verticalAlign) && !E[w2].dockInsidePlotArea === !this.dockInsidePlotArea) {
              this.margin = 0;
              break;
            }
        }
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Ja(h, n, r2) {
        Ja.base.constructor.call(this, "Subtitle", "subtitles", n, r2, h);
        this.chart = h;
        this.canvas = h.canvas;
        this.ctx = this.chart.ctx;
        this.optionsName = "subtitles";
        this.isOptionsInArray = true;
        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
        this.height = this.width = null;
        this.bounds = { x1: null, y1: null, x2: null, y2: null };
      }
      function Va() {
        this.pool = [];
      }
      function Ka(h) {
        var n;
        h && La[h] && (n = La[h]);
        Ka.base.constructor.call(this, "CultureInfo", null, n, null, null);
      }
      var Ia = false, ta = {}, w = !!document.createElement("canvas").getContext, oa = { Chart: {
        width: 500,
        height: 400,
        zoomEnabled: false,
        zoomType: "x",
        backgroundColor: "white",
        theme: "light1",
        animationEnabled: false,
        animationDuration: 1200,
        dataPointWidth: null,
        dataPointMinWidth: null,
        dataPointMaxWidth: null,
        colorSet: "colorSet1",
        culture: "en",
        creditHref: "",
        creditText: "CanvasJS",
        interactivityEnabled: true,
        exportEnabled: false,
        exportFileName: "Chart",
        rangeChanging: null,
        rangeChanged: null,
        publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly", selectedColorSet: "readOnly" }
      }, Title: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 20,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: w ? "transparent" : null,
        margin: 5,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Subtitle: {
        padding: 0,
        text: null,
        verticalAlign: "top",
        horizontalAlign: "center",
        fontSize: 14,
        fontFamily: "Calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        margin: 2,
        wrap: true,
        maxWidth: null,
        dockInsidePlotArea: false,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, Toolbar: { itemBackgroundColor: "white", itemBackgroundColorOnHover: "#2196f3", buttonBorderColor: "#2196f3", buttonBorderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: {
        name: null,
        verticalAlign: "center",
        horizontalAlign: "right",
        fontSize: 14,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        cursor: null,
        itemmouseover: null,
        itemmouseout: null,
        itemmousemove: null,
        itemclick: null,
        dockInsidePlotArea: false,
        reversed: false,
        backgroundColor: w ? "transparent" : null,
        borderColor: w ? "transparent" : null,
        borderThickness: 0,
        cornerRadius: 0,
        maxWidth: null,
        maxHeight: null,
        markerMargin: null,
        itemMaxWidth: null,
        itemWidth: null,
        itemWrap: true,
        itemTextFormatter: null,
        publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
      }, ToolTip: {
        enabled: true,
        shared: false,
        animationEnabled: true,
        content: null,
        contentFormatter: null,
        reversed: false,
        backgroundColor: w ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
        borderColor: null,
        borderThickness: 2,
        cornerRadius: 5,
        fontSize: 14,
        fontColor: "black",
        fontFamily: "Calibri, Arial, Georgia, serif;",
        fontWeight: "normal",
        fontStyle: "italic",
        updated: null,
        hidden: null,
        publicProperties: { options: "readWrite", chart: "readOnly" }
      }, Axis: {
        minimum: null,
        maximum: null,
        viewportMinimum: null,
        viewportMaximum: null,
        interval: null,
        intervalType: null,
        reversed: false,
        logarithmic: false,
        logarithmBase: 10,
        title: null,
        titleFontColor: "black",
        titleFontSize: 20,
        titleFontFamily: "arial",
        titleFontWeight: "normal",
        titleFontStyle: "normal",
        titleWrap: true,
        titleMaxWidth: null,
        titleBackgroundColor: w ? "transparent" : null,
        titleBorderColor: w ? "transparent" : null,
        titleBorderThickness: 0,
        titleCornerRadius: 0,
        labelAngle: 0,
        labelFontFamily: "arial",
        labelFontColor: "black",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelAutoFit: true,
        labelWrap: true,
        labelMaxWidth: null,
        labelFormatter: null,
        labelBackgroundColor: w ? "transparent" : null,
        labelBorderColor: w ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelPlacement: "outside",
        labelTextAlign: "left",
        prefix: "",
        suffix: "",
        includeZero: false,
        tickLength: 5,
        tickColor: "black",
        tickThickness: 1,
        tickPlacement: "outside",
        lineColor: "black",
        lineThickness: 1,
        lineDashType: "solid",
        gridColor: "#A0A0A0",
        gridThickness: 0,
        gridDashType: "solid",
        interlacedColor: w ? "transparent" : null,
        valueFormatString: null,
        margin: 2,
        publicProperties: {
          options: "readWrite",
          stripLines: "readWrite",
          scaleBreaks: "readWrite",
          crosshair: "readWrite",
          bounds: "readOnly",
          chart: "readOnly"
        }
      }, StripLine: {
        value: null,
        startValue: null,
        endValue: null,
        color: "orange",
        opacity: null,
        thickness: 2,
        lineDashType: "solid",
        label: "",
        labelPlacement: "inside",
        labelAlign: "far",
        labelWrap: true,
        labelMaxWidth: null,
        labelBackgroundColor: null,
        labelBorderColor: w ? "transparent" : null,
        labelBorderThickness: 0,
        labelCornerRadius: 0,
        labelFontFamily: "arial",
        labelFontColor: "orange",
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelFontStyle: "normal",
        labelFormatter: null,
        showOnTop: false,
        publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, ScaleBreaks: { autoCalculate: false, collapsibleThreshold: "25%", maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" } }, Break: {
        startValue: null,
        endValue: null,
        spacing: 8,
        type: "straight",
        color: "#FFFFFF",
        fillOpacity: 0.9,
        lineThickness: 2,
        lineColor: "#E16E6E",
        lineDashType: "solid",
        publicProperties: { options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" }
      }, Crosshair: { enabled: false, snapToDataPoint: false, color: "grey", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelWrap: true, labelMaxWidth: null, labelBackgroundColor: w ? "grey" : null, labelBorderColor: w ? "grey" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: w ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 12, labelFontColor: "#fff", labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, valueFormatString: null, updated: null, hidden: null, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" } }, DataSeries: {
        name: null,
        dataPoints: null,
        label: "",
        bevelEnabled: false,
        highlightEnabled: true,
        cursor: "default",
        indexLabel: "",
        indexLabelPlacement: "auto",
        indexLabelOrientation: "horizontal",
        indexLabelTextAlign: "left",
        indexLabelFontColor: "black",
        indexLabelFontSize: 12,
        indexLabelFontStyle: "normal",
        indexLabelFontFamily: "Arial",
        indexLabelFontWeight: "normal",
        indexLabelBackgroundColor: null,
        indexLabelLineColor: "gray",
        indexLabelLineThickness: 1,
        indexLabelLineDashType: "solid",
        indexLabelMaxWidth: null,
        indexLabelWrap: true,
        indexLabelFormatter: null,
        lineThickness: 2,
        lineDashType: "solid",
        connectNullData: false,
        nullDataLineDashType: "dash",
        color: null,
        lineColor: null,
        risingColor: "white",
        fallingColor: "red",
        fillOpacity: null,
        startAngle: 0,
        radius: null,
        innerRadius: null,
        neckHeight: null,
        neckWidth: null,
        reversed: false,
        valueRepresents: null,
        linkedDataSeriesIndex: null,
        whiskerThickness: 2,
        whiskerDashType: "solid",
        whiskerColor: null,
        whiskerLength: null,
        stemThickness: 2,
        stemColor: null,
        stemDashType: "solid",
        upperBoxColor: "white",
        lowerBoxColor: "white",
        type: "column",
        xValueType: "number",
        axisXType: "primary",
        axisYType: "primary",
        axisXIndex: 0,
        axisYIndex: 0,
        xValueFormatString: null,
        yValueFormatString: null,
        zValueFormatString: null,
        percentFormatString: null,
        showInLegend: null,
        legendMarkerType: null,
        legendMarkerColor: null,
        legendText: null,
        legendMarkerBorderColor: w ? "transparent" : null,
        legendMarkerBorderThickness: 0,
        markerType: "circle",
        markerColor: null,
        markerSize: null,
        markerBorderColor: w ? "transparent" : null,
        markerBorderThickness: 0,
        mouseover: null,
        mouseout: null,
        mousemove: null,
        click: null,
        toolTipContent: null,
        visible: true,
        publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" }
      }, TextBlock: {
        x: 0,
        y: 0,
        width: null,
        height: null,
        maxWidth: null,
        maxHeight: null,
        padding: 0,
        angle: 0,
        text: "",
        horizontalAlign: "center",
        textAlign: "left",
        fontSize: 12,
        fontFamily: "calibri",
        fontWeight: "normal",
        fontColor: "black",
        fontStyle: "normal",
        borderThickness: 0,
        borderColor: "black",
        cornerRadius: 0,
        backgroundColor: null,
        textBaseline: "top"
      }, CultureInfo: {
        decimalSeparator: ".",
        digitGroupSeparator: ",",
        zoomText: "Zoom",
        panText: "Pan",
        resetText: "Reset",
        menuText: "More Options",
        saveJPGText: "Save as JPEG",
        savePNGText: "Save as PNG",
        printText: "Print",
        days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
      } }, La = { en: {} }, v = w ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", Ga = w ? "Impact, Charcoal, sans-serif" : "Arial", za = {
        colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
        colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
        colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
      }, R, Y, V, ea, ja;
      Y = "#333333";
      V = "#000000";
      R = "#666666";
      ja = ea = "#000000";
      var da = 20, B = 14, Wa = { colorSet: "colorSet1", backgroundColor: "#FFFFFF", title: { fontFamily: Ga, fontSize: 32, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: Ga, fontSize: B, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{
        indexLabelFontFamily: v,
        indexLabelFontSize: B,
        indexLabelFontColor: Y,
        indexLabelFontWeight: "normal",
        indexLabelLineThickness: 1
      }], axisX: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: Y, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 0, gridColor: R, stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: ja,
        color: ea,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisX2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: Y, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 0, gridColor: R, stripLines: [{
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#FF7300",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FF7300",
        thickness: 1
      }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{
        titleFontFamily: v,
        titleFontSize: da,
        titleFontColor: Y,
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: V,
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: R,
        tickThickness: 1,
        tickColor: R,
        gridThickness: 1,
        gridColor: R,
        stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#BBBBBB",
          lineThickness: 1,
          lineDashType: "solid"
        }
      }], axisY2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: Y, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 1, gridColor: R, stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: ja,
        color: ea,
        thickness: 1,
        lineDashType: "dash"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: v, fontSize: 14, fontColor: Y, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }, toolbar: {
        itemBackgroundColor: "white",
        itemBackgroundColorOnHover: "#2196f3",
        buttonBorderColor: "#2196f3",
        buttonBorderThickness: 1,
        fontColor: "black",
        fontColorOnHover: "white"
      } };
      V = Y = "#F5F5F5";
      R = "#FFFFFF";
      ea = "#40BAF1";
      ja = "#F5F5F5";
      var da = 20, B = 14, bb = { colorSet: "colorSet2", title: { fontFamily: v, fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: v, fontSize: B, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: v, indexLabelFontSize: B, indexLabelFontColor: "#666666", indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
        titleFontFamily: v,
        titleFontSize: da,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 1,
        lineColor: "#BBBBBB",
        tickThickness: 1,
        tickColor: "#BBBBBB",
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: {
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#EEEEEE",
          labelFontWeight: "normal",
          labelBackgroundColor: "black",
          color: "black",
          thickness: 1,
          lineDashType: "dot"
        },
        scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
      }], axisX2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#FFA500",
        labelFontWeight: "normal",
        labelBackgroundColor: null,
        color: "#FFA500",
        thickness: 1
      }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], axisY: [{
        titleFontFamily: v,
        titleFontSize: da,
        titleFontColor: "#666666",
        titleFontWeight: "normal",
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#666666",
        labelFontWeight: "normal",
        lineThickness: 0,
        lineColor: "#BBBBBB",
        tickColor: "#BBBBBB",
        tickThickness: 1,
        gridThickness: 1,
        gridColor: "#BBBBBB",
        stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }],
        crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" },
        scaleBreaks: {
          type: "zigzag",
          spacing: "2%",
          lineColor: "#BBBBBB",
          lineThickness: 1,
          lineDashType: "solid"
        }
      }], axisY2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: {
        labelFontFamily: v,
        labelFontSize: B,
        labelFontColor: "#EEEEEE",
        labelFontWeight: "normal",
        labelBackgroundColor: "black",
        color: "black",
        thickness: 1,
        lineDashType: "dot"
      }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" } }], legend: { fontFamily: v, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: v, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }, toolbar: {
        itemBackgroundColor: "white",
        itemBackgroundColorOnHover: "#2196f3",
        buttonBorderColor: "#2196f3",
        buttonBorderThickness: 1,
        fontColor: "black",
        fontColorOnHover: "white"
      } };
      V = Y = "#F5F5F5";
      R = "#FFFFFF";
      ea = "#40BAF1";
      ja = "#F5F5F5";
      da = 20;
      B = 14;
      Ga = {
        colorSet: "colorSet12",
        backgroundColor: "#2A2A2A",
        title: { fontFamily: Ga, fontSize: 32, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 },
        subtitles: [{ fontFamily: Ga, fontSize: B, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 }],
        toolbar: {
          itemBackgroundColor: "#666666",
          itemBackgroundColorOnHover: "#FF7372",
          buttonBorderColor: "#FF7372",
          buttonBorderThickness: 1,
          fontColor: "#F5F5F5",
          fontColorOnHover: "#F5F5F5"
        },
        data: [{ indexLabelFontFamily: v, indexLabelFontSize: B, indexLabelFontColor: V, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }],
        axisX: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 0, gridColor: R, stripLines: [{
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        axisX2: [{
          titleFontFamily: v,
          titleFontSize: da,
          titleFontColor: V,
          titleFontWeight: "normal",
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: V,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: R,
          tickThickness: 1,
          tickColor: R,
          gridThickness: 0,
          gridColor: R,
          stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" },
          scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }],
        axisY: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 1, gridColor: R, stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#000000",
          labelFontWeight: "normal",
          labelBackgroundColor: ja,
          color: ea,
          thickness: 1,
          lineDashType: "dash"
        }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        axisY2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 1, gridColor: R, stripLines: [{
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        legend: { fontFamily: v, fontSize: 14, fontColor: Y, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" },
        toolTip: {
          fontFamily: v,
          fontSize: 14,
          fontStyle: "normal",
          cornerRadius: 0,
          borderThickness: 1,
          fontColor: V,
          backgroundColor: "rgba(0, 0, 0, .7)"
        }
      };
      R = "#FFFFFF";
      V = Y = "#FAFAFA";
      ea = "#40BAF1";
      ja = "#F5F5F5";
      var da = 20, B = 14, cb = { light1: Wa, light2: bb, dark1: Ga, dark2: {
        colorSet: "colorSet2",
        backgroundColor: "#32373A",
        title: { fontFamily: v, fontSize: 32, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 },
        subtitles: [{ fontFamily: v, fontSize: B, fontColor: Y, fontWeight: "normal", verticalAlign: "top", margin: 5 }],
        toolbar: {
          itemBackgroundColor: "#666666",
          itemBackgroundColorOnHover: "#FF7372",
          buttonBorderColor: "#FF7372",
          buttonBorderThickness: 1,
          fontColor: "#F5F5F5",
          fontColorOnHover: "#F5F5F5"
        },
        data: [{ indexLabelFontFamily: v, indexLabelFontSize: B, indexLabelFontColor: V, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }],
        axisX: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 1, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 0, gridColor: R, stripLines: [{
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        axisX2: [{
          titleFontFamily: v,
          titleFontSize: da,
          titleFontColor: V,
          titleFontWeight: "normal",
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: V,
          labelFontWeight: "normal",
          lineThickness: 1,
          lineColor: R,
          tickThickness: 1,
          tickColor: R,
          gridThickness: 0,
          gridColor: R,
          stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
          crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" },
          scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }],
        axisY: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 0, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 1, gridColor: R, stripLines: [{ labelFontFamily: v, labelFontSize: B, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#000000",
          labelFontWeight: "normal",
          labelBackgroundColor: ja,
          color: ea,
          thickness: 1,
          lineDashType: "dash"
        }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        axisY2: [{ titleFontFamily: v, titleFontSize: da, titleFontColor: V, titleFontWeight: "normal", labelFontFamily: v, labelFontSize: B, labelFontColor: V, labelFontWeight: "normal", lineThickness: 0, lineColor: R, tickThickness: 1, tickColor: R, gridThickness: 1, gridColor: R, stripLines: [{
          labelFontFamily: v,
          labelFontSize: B,
          labelFontColor: "#FF7300",
          labelFontWeight: "normal",
          labelBackgroundColor: null,
          color: "#FF7300",
          thickness: 1
        }], crosshair: { labelFontFamily: v, labelFontSize: B, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ja, color: ea, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" } }],
        legend: { fontFamily: v, fontSize: 14, fontColor: Y, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" },
        toolTip: {
          fontFamily: v,
          fontSize: 14,
          fontStyle: "normal",
          cornerRadius: 0,
          borderThickness: 1,
          fontColor: V,
          backgroundColor: "rgba(0, 0, 0, .7)"
        }
      }, theme1: Wa, theme2: bb, theme3: Wa }, I = { numberDuration: 1, yearDuration: 314496e5, monthDuration: 2592e6, weekDuration: 6048e5, dayDuration: 864e5, hourDuration: 36e5, minuteDuration: 6e4, secondDuration: 1e3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") };
      (function() {
        ta.fSDec = function(h) {
          for (var n = "", r2 = 0; r2 < h.length; r2++)
            n += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r2));
          return n;
        };
        delete oa[ta.fSDec("Bi`su")][ta.fSDec("bsdehuIsdg")];
        ta.pro = { sCH: oa[ta.fSDec("Bi`su")][ta.fSDec("bsdehuIsdg")] };
      })();
      var gb = function() {
        var h = false;
        try {
          var n = Object.defineProperty && Object.defineProperty({}, "passive", { get: function() {
            h = true;
            return false;
          } });
          window.addEventListener && (window.addEventListener("test", null, n), window.removeEventListener("test", null, n));
        } catch (r2) {
          h = false;
        }
        return h;
      }(), Za = {}, wa = null, lb = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));
      }, xa = function(h) {
        h.width = 1;
        h.height = 1;
        h.getContext("2d") && h.getContext("2d").clearRect(0, 0, 1, 1);
      }, mb = function(h, n, r2) {
        n = Math.min(this.width, this.height);
        return Math.max("theme4" === this.theme ? 0 : 300 <= n ? 12 : 11, Math.round(n * (h / 400)));
      }, Aa = function() {
        var h = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, n = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), r2 = "Sun Mon Tue Wed Thu Fri Sat".split(" "), w2 = "January February March April May June July August September October November December".split(" "), v2 = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), U = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, A = /[^-+\dA-Z]/g;
        return function(B2, J2, P) {
          var R2 = P ? P.days : n, O2 = P ? P.months : w2, K2 = P ? P.shortDays : r2, I2 = P ? P.shortMonths : v2;
          P = "";
          var S2 = false;
          B2 = B2 && B2.getTime ? B2 : B2 ? new Date(B2) : new Date();
          if (isNaN(B2))
            throw SyntaxError("invalid date");
          "UTC:" === J2.slice(0, 4) && (J2 = J2.slice(4), S2 = true);
          P = S2 ? "getUTC" : "get";
          var X2 = B2[P + "Date"](), N = B2[P + "Day"](), $ = B2[P + "Month"](), a2 = B2[P + "FullYear"](), d2 = B2[P + "Hours"](), c2 = B2[P + "Minutes"](), b = B2[P + "Seconds"](), e = B2[P + "Milliseconds"](), f = S2 ? 0 : B2.getTimezoneOffset();
          return P = J2.replace(h, function(l2) {
            switch (l2) {
              case "D":
                return X2;
              case "DD":
                return Z(X2, 2);
              case "DDD":
                return K2[N];
              case "DDDD":
                return R2[N];
              case "M":
                return $ + 1;
              case "MM":
                return Z($ + 1, 2);
              case "MMM":
                return I2[$];
              case "MMMM":
                return O2[$];
              case "Y":
                return parseInt(String(a2).slice(-2));
              case "YY":
                return Z(String(a2).slice(-2), 2);
              case "YYY":
                return Z(String(a2).slice(-3), 3);
              case "YYYY":
                return Z(a2, 4);
              case "h":
                return d2 % 12 || 12;
              case "hh":
                return Z(d2 % 12 || 12, 2);
              case "H":
                return d2;
              case "HH":
                return Z(d2, 2);
              case "m":
                return c2;
              case "mm":
                return Z(c2, 2);
              case "s":
                return b;
              case "ss":
                return Z(b, 2);
              case "f":
                return Z(String(e), 3).slice(0, 1);
              case "ff":
                return Z(String(e), 3).slice(0, 2);
              case "fff":
                return Z(String(e), 3).slice(0, 3);
              case "t":
                return 12 > d2 ? "a" : "p";
              case "tt":
                return 12 > d2 ? "am" : "pm";
              case "T":
                return 12 > d2 ? "A" : "P";
              case "TT":
                return 12 > d2 ? "AM" : "PM";
              case "K":
                return S2 ? "UTC" : (String(B2).match(U) || [""]).pop().replace(A, "");
              case "z":
                return (0 < f ? "-" : "+") + Math.floor(Math.abs(f) / 60);
              case "zz":
                return (0 < f ? "-" : "+") + Z(Math.floor(Math.abs(f) / 60), 2);
              case "zzz":
                return (0 < f ? "-" : "+") + Z(Math.floor(Math.abs(f) / 60), 2) + Z(Math.abs(f) % 60, 2);
              default:
                return l2.slice(1, l2.length - 1);
            }
          });
        };
      }(), nb = function(h) {
        var n = 0 > h;
        if (1 > Math.abs(h)) {
          var r2 = parseInt(h.toString().split("e-")[1]);
          r2 && (h = (n ? -1 * h : h) * Math.pow(10, r2 - 1), h = "0." + Array(r2).join("0") + h.toString().substring(2), h = n ? "-" + h : h);
        } else
          r2 = parseInt(h.toString().split("+")[1]), 20 < r2 && (r2 -= 20, h /= Math.pow(10, r2), h = h.toString() + Array(r2 + 1).join("0"));
        return String(h);
      }, fa = function(h, n, r2) {
        if (null === h)
          return "";
        if (!isFinite(h))
          return h;
        h = Number(h);
        var w2 = 0 > h ? true : false;
        w2 && (h *= -1);
        var v2 = r2 ? r2.decimalSeparator : ".", U = r2 ? r2.digitGroupSeparator : ",", A = "";
        n = String(n);
        var A = 1, B2 = r2 = "", J2 = -1, P = [], R2 = [], O2 = 0, K2 = 0, I2 = 0, S2 = false, X2 = 0, B2 = n.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
        n = null;
        for (var N = 0; B2 && N < B2.length; N++)
          if (n = B2[N], "." === n && 0 > J2)
            J2 = N;
          else {
            if ("%" === n)
              A *= 100;
            else if ("\u2030" === n) {
              A *= 1e3;
              continue;
            } else if ("," === n[0] && "." === n[n.length - 1]) {
              A /= Math.pow(1e3, n.length - 1);
              J2 = N + n.length - 1;
              continue;
            } else
              "E" !== n[0] && "e" !== n[0] || "0" !== n[n.length - 1] || (S2 = true);
            0 > J2 ? (P.push(n), "#" === n || "0" === n ? O2++ : "," === n && I2++) : (R2.push(n), "#" !== n && "0" !== n || K2++);
          }
        S2 && (n = Math.floor(h), B2 = -Math.floor(Math.log(h) / Math.LN10 + 1), X2 = 0 === h ? 0 : 0 === n ? -(O2 + B2) : nb(n).length - O2, A /= Math.pow(10, X2));
        0 > J2 && (J2 = N);
        A = (h * A).toFixed(K2);
        n = A.split(".");
        A = (n[0] + "").split("");
        h = (n[1] + "").split("");
        A && "0" === A[0] && A.shift();
        for (S2 = B2 = N = K2 = J2 = 0; 0 < P.length; )
          if (n = P.pop(), "#" === n || "0" === n)
            if (J2++, J2 === O2) {
              var $ = A, A = [];
              if ("0" === n)
                for (n = O2 - K2 - ($ ? $.length : 0); 0 < n; )
                  $.unshift("0"), n--;
              for (; 0 < $.length; )
                r2 = $.pop() + r2, S2++, 0 === S2 % B2 && (N === I2 && 0 < $.length) && (r2 = U + r2);
            } else
              0 < A.length ? (r2 = A.pop() + r2, K2++, S2++) : "0" === n && (r2 = "0" + r2, K2++, S2++), 0 === S2 % B2 && (N === I2 && 0 < A.length) && (r2 = U + r2);
          else
            "E" !== n[0] && "e" !== n[0] || "0" !== n[n.length - 1] || !/[eE][+-]*[0]+/.test(n) ? "," === n ? (N++, B2 = S2, S2 = 0, 0 < A.length && (r2 = U + r2)) : r2 = 1 < n.length && ('"' === n[0] && '"' === n[n.length - 1] || "'" === n[0] && "'" === n[n.length - 1]) ? n.slice(1, n.length - 1) + r2 : n + r2 : (n = 0 > X2 ? n.replace("+", "").replace("-", "") : n.replace("-", ""), r2 += n.replace(/[0]+/, function(a2) {
              return Z(X2, a2.length);
            }));
        U = "";
        for (P = false; 0 < R2.length; )
          n = R2.shift(), "#" === n || "0" === n ? 0 < h.length && 0 !== Number(h.join("")) ? (U += h.shift(), P = true) : "0" === n && (U += "0", P = true) : 1 < n.length && ('"' === n[0] && '"' === n[n.length - 1] || "'" === n[0] && "'" === n[n.length - 1]) ? U += n.slice(1, n.length - 1) : "E" !== n[0] && "e" !== n[0] || "0" !== n[n.length - 1] || !/[eE][+-]*[0]+/.test(n) ? U += n : (n = 0 > X2 ? n.replace("+", "").replace("-", "") : n.replace("-", ""), U += n.replace(/[0]+/, function(a2) {
            return Z(X2, a2.length);
          }));
        r2 += (P ? v2 : "") + U;
        return w2 ? "-" + r2 : r2;
      }, Pa = function(h) {
        var n = 0, r2 = 0;
        h = h || window.event;
        h.offsetX || 0 === h.offsetX ? (n = h.offsetX, r2 = h.offsetY) : h.layerX || 0 == h.layerX ? (n = h.layerX, r2 = h.layerY) : (n = h.pageX - h.target.offsetLeft, r2 = h.pageY - h.target.offsetTop);
        return { x: n, y: r2 };
      }, ab = true, Sa = window.devicePixelRatio || 1, Oa = 1, ia = ab ? Sa / Oa : 1, ba = function(h, n, r2, w2, v2, B2, A, J2, O2, P, R2, S2, K2) {
        "undefined" === typeof K2 && (K2 = 1);
        A = A || 0;
        J2 = J2 || "black";
        var I2 = 15 < w2 - n && 15 < v2 - r2 ? 8 : 0.35 * Math.min(w2 - n, v2 - r2);
        h.beginPath();
        h.moveTo(n, r2);
        h.save();
        h.fillStyle = B2;
        h.globalAlpha = K2;
        h.fillRect(n, r2, w2 - n, v2 - r2);
        h.globalAlpha = 1;
        0 < A && (K2 = 0 === A % 2 ? 0 : 0.5, h.beginPath(), h.lineWidth = A, h.strokeStyle = J2, h.moveTo(n, r2), h.rect(n - K2, r2 - K2, w2 - n + 2 * K2, v2 - r2 + 2 * K2), h.stroke());
        h.restore();
        true === O2 && (h.save(), h.beginPath(), h.moveTo(n, r2), h.lineTo(n + I2, r2 + I2), h.lineTo(w2 - I2, r2 + I2), h.lineTo(w2, r2), h.closePath(), A = h.createLinearGradient((w2 + n) / 2, r2 + I2, (w2 + n) / 2, r2), A.addColorStop(0, B2), A.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle = A, h.fill(), h.restore());
        true === P && (h.save(), h.beginPath(), h.moveTo(n, v2), h.lineTo(n + I2, v2 - I2), h.lineTo(w2 - I2, v2 - I2), h.lineTo(w2, v2), h.closePath(), A = h.createLinearGradient((w2 + n) / 2, v2 - I2, (w2 + n) / 2, v2), A.addColorStop(0, B2), A.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle = A, h.fill(), h.restore());
        true === R2 && (h.save(), h.beginPath(), h.moveTo(n, r2), h.lineTo(n + I2, r2 + I2), h.lineTo(n + I2, v2 - I2), h.lineTo(n, v2), h.closePath(), A = h.createLinearGradient(n + I2, (v2 + r2) / 2, n, (v2 + r2) / 2), A.addColorStop(0, B2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = A, h.fill(), h.restore());
        true === S2 && (h.save(), h.beginPath(), h.moveTo(w2, r2), h.lineTo(w2 - I2, r2 + I2), h.lineTo(w2 - I2, v2 - I2), h.lineTo(w2, v2), A = h.createLinearGradient(w2 - I2, (v2 + r2) / 2, w2, (v2 + r2) / 2), A.addColorStop(0, B2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = A, A.addColorStop(0, B2), A.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = A, h.fill(), h.closePath(), h.restore());
      }, W = function(h) {
        for (var n = "", r2 = 0; r2 < h.length; r2++)
          n += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(r2));
        return n;
      }, jb = window && (window[W("mnb`uhno")] && window[W("mnb`uhno")].href && window[W("mnb`uhno")].href.indexOf && (-1 !== window[W("mnb`uhno")].href.indexOf(W("b`ow`rkr/bnl")) || -1 !== window[W("mnb`uhno")].href.indexOf(W("gdonqhy/bnl")) || -1 !== window[W("mnb`uhno")].href.indexOf(W("gheemd")))) && -1 === window[W("mnb`uhno")].href.indexOf(W("gheemd")), kb = {
        reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
        pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
        zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
        menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }
      };
      X.prototype.setOptions = function(h, n) {
        if (oa[this._defaultsKey]) {
          var r2 = oa[this._defaultsKey], w2;
          for (w2 in r2)
            "publicProperties" !== w2 && r2.hasOwnProperty(w2) && (this[w2] = h && w2 in h ? h[w2] : n && w2 in n ? n[w2] : r2[w2]);
        } else
          Ia && window.console && console.log("defaults not set");
      };
      X.prototype.get = function(h) {
        var n = oa[this._defaultsKey];
        if ("options" === h)
          return this.options && this.options._isPlaceholder ? null : this.options;
        if (n.hasOwnProperty(h) || n.publicProperties && n.publicProperties.hasOwnProperty(h))
          return this[h];
        window.console && window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`);
      };
      X.prototype.set = function(h, n, r2) {
        r2 = "undefined" === typeof r2 ? true : r2;
        var w2 = oa[this._defaultsKey];
        if ("options" === h)
          this.createUserOptions(n);
        else if (w2.hasOwnProperty(h) || w2.publicProperties && w2.publicProperties.hasOwnProperty(h) && "readWrite" === w2.publicProperties[h])
          this.options._isPlaceholder && this.createUserOptions(), this.options[h] = n;
        else {
          window.console && (w2.publicProperties && w2.publicProperties.hasOwnProperty(h) && "readOnly" === w2.publicProperties[h] ? window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`));
          return;
        }
        r2 && (this.stockChart || this.chart || this).render();
      };
      X.prototype.addTo = function(h, n, r2, w2) {
        w2 = "undefined" === typeof w2 ? true : w2;
        var v2 = oa[this._defaultsKey];
        v2.hasOwnProperty(h) || v2.publicProperties && v2.publicProperties.hasOwnProperty(h) && "readWrite" === v2.publicProperties[h] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[h] && (this.options[h] = []), h = this.options[h], r2 = "undefined" === typeof r2 || null === r2 ? h.length : r2, h.splice(r2, 0, n), w2 && (this.stockChart || this.chart || this).render()) : window.console && (v2.publicProperties && v2.publicProperties.hasOwnProperty(h) && "readOnly" === v2.publicProperties[h] ? window.console.log('Property "' + h + '" is read-only.') : window.console.log('Property "' + h + `" doesn't exist. Please check for typo.`));
      };
      X.prototype.createUserOptions = function(h) {
        if ("undefined" !== typeof h || this.options._isPlaceholder)
          if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
            this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
            var n = this.parent.options[this.optionsName], r2 = n.length;
            this.options._isPlaceholder || (Ea(n), r2 = n.indexOf(this.options));
            this.options = "undefined" === typeof h ? {} : h;
            n[r2] = this.options;
          } else
            this.options = "undefined" === typeof h ? {} : h, h = this.parent.options, this.optionsName ? n = this.optionsName : (n = this._defaultsKey) && 0 !== n.length ? (r2 = n.charAt(0).toLowerCase(), 1 < n.length && (r2 = r2.concat(n.slice(1))), n = r2) : n = void 0, h[n] = this.options;
      };
      X.prototype.remove = function(h) {
        h = "undefined" === typeof h ? true : h;
        if (this.isOptionsInArray) {
          var n = this.parent.options[this.optionsName];
          Ea(n);
          var r2 = n.indexOf(this.options);
          0 <= r2 && n.splice(r2, 1);
        } else
          delete this.parent.options[this.optionsName];
        h && (this.stockChart || this.chart || this).render();
      };
      X.prototype.updateOption = function(h) {
        !oa[this._defaultsKey] && (Ia && window.console) && console.log("defaults not set");
        var n = oa[this._defaultsKey], w2 = {}, v2 = this[h], B2 = this._themeOptionsKey, U = this._index;
        this.theme && r(this.parent) && r(B2) && r(U) ? w2 = r(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[B2]) && (null === U ? w2 = this.parent.themeOptions[B2] : 0 < this.parent.themeOptions[B2].length && (w2 = Math.min(this.parent.themeOptions[B2].length - 1, U), w2 = this.parent.themeOptions[B2][w2]));
        this.themeOptions = w2;
        h in n && (v2 = h in this.options ? this.options[h] : w2 && h in w2 ? w2[h] : n[h]);
        if (v2 === this[h])
          return false;
        this[h] = v2;
        return true;
      };
      X.prototype.trackChanges = function(h) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        this.sessionVariables[h] = this.options[h];
      };
      X.prototype.isBeingTracked = function(h) {
        this.options._oldOptions || (this.options._oldOptions = {});
        return this.options._oldOptions[h] ? true : false;
      };
      X.prototype.hasOptionChanged = function(h) {
        if (!this.sessionVariables)
          throw "Session Variable Store not set";
        return this.sessionVariables[h] !== this.options[h];
      };
      X.prototype.addEventListener = function(h, n, r2) {
        h && n && (this._eventListeners[h] = this._eventListeners[h] || [], this._eventListeners[h].push({ context: r2 || this, eventHandler: n }));
      };
      X.prototype.removeEventListener = function(h, n) {
        if (h && n && this._eventListeners[h]) {
          for (var r2 = this._eventListeners[h], w2 = 0; w2 < r2.length; w2++)
            if (r2[w2].eventHandler === n) {
              r2[w2].splice(w2, 1);
              break;
            }
        }
      };
      X.prototype.removeAllEventListeners = function() {
        this._eventListeners = [];
      };
      X.prototype.dispatchEvent = function(h, n, r2) {
        if (h && this._eventListeners[h]) {
          n = n || {};
          for (var w2 = this._eventListeners[h], v2 = 0; v2 < w2.length; v2++)
            w2[v2].eventHandler.call(
              w2[v2].context,
              n
            );
        }
        "function" === typeof this[h] && this[h].call(r2 || this.chart, n);
      };
      Fa.prototype.registerSpace = function(h, n) {
        "top" === h ? this._topOccupied += n.height : "bottom" === h ? this._bottomOccupied += n.height : "left" === h ? this._leftOccupied += n.width : "right" === h && (this._rightOccupied += n.width);
      };
      Fa.prototype.unRegisterSpace = function(h, n) {
        "top" === h ? this._topOccupied -= n.height : "bottom" === h ? this._bottomOccupied -= n.height : "left" === h ? this._leftOccupied -= n.width : "right" === h && (this._rightOccupied -= n.width);
      };
      Fa.prototype.getFreeSpace = function() {
        return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied };
      };
      Fa.prototype.reset = function() {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
      };
      na(ka, X);
      ka.prototype._initialize = function() {
        r(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = r(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = r(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = r(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = r(this.padding.left) ? 0 : Number(this.padding.left) | 0);
      };
      ka.prototype.render = function(h) {
        if (0 !== this.fontSize) {
          h && this.ctx.save();
          var n = this.ctx.font;
          this.ctx.textBaseline = this.textBaseline;
          var r2 = 0;
          this._isDirty && this.measureText(this.ctx);
          this.ctx.translate(this.x, this.y + r2);
          "middle" === this.textBaseline && (r2 = -this._lineHeight / 2);
          this.ctx.font = this._getFontString();
          this.ctx.rotate(Math.PI / 180 * this.angle);
          var w2 = 0, v2 = this.topPadding, B2 = null;
          this.ctx.roundRect || Da(this.ctx);
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, r2, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          this.ctx.fillStyle = this.fontColor;
          for (r2 = 0; r2 < this._wrappedText.lines.length; r2++) {
            B2 = this._wrappedText.lines[r2];
            if ("right" === this.horizontalAlign || "right" === this.textAlign)
              w2 = this.width - B2.width - this.rightPadding;
            else if ("left" === this.horizontalAlign || "left" === this.textAlign)
              w2 = this.leftPadding;
            else if ("center" === this.horizontalAlign || "center" === this.textAlign)
              w2 = (this.width - (this.leftPadding + this.rightPadding)) / 2 - B2.width / 2 + this.leftPadding;
            this.ctx.fillText(B2.text, w2, v2);
            v2 += B2.height;
          }
          this.ctx.font = n;
          h && this.ctx.restore();
        }
      };
      ka.prototype.setText = function(h) {
        this.text = h;
        this._isDirty = true;
        this._wrappedText = null;
      };
      ka.prototype.measureText = function() {
        this._lineHeight = Ya(this.fontFamily, this.fontSize, this.fontWeight);
        if (null === this.maxWidth)
          throw "Please set maxWidth and height for TextBlock";
        this._wrapText(this.ctx);
        this._isDirty = false;
        return { width: this.width, height: this.height };
      };
      ka.prototype._getLineWithWidth = function(h, n, r2) {
        h = String(h);
        if (!h)
          return { text: "", width: 0 };
        var w2 = r2 = 0, v2 = h.length - 1, B2 = Infinity;
        for (this.ctx.font = this._getFontString(); w2 <= v2; ) {
          var B2 = Math.floor((w2 + v2) / 2), A = h.substr(0, B2 + 1);
          r2 = this.ctx.measureText(A).width;
          if (r2 < n)
            w2 = B2 + 1;
          else if (r2 > n)
            v2 = B2 - 1;
          else
            break;
        }
        r2 > n && 1 < A.length && (A = A.substr(0, A.length - 1), r2 = this.ctx.measureText(A).width);
        n = true;
        if (A.length === h.length || " " === h[A.length])
          n = false;
        n && (h = A.split(" "), 1 < h.length && h.pop(), A = h.join(" "), r2 = this.ctx.measureText(A).width);
        return { text: A, width: r2 };
      };
      ka.prototype._wrapText = function() {
        var h = new String(Ha(String(this.text))), n = [], r2 = this.ctx.font, w2 = 0, v2 = 0;
        this.ctx.font = this._getFontString();
        if (0 === this.frontSize)
          v2 = w2 = 0;
        else
          for (; 0 < h.length; ) {
            var B2 = this.maxHeight - (this.topPadding + this.bottomPadding), A = this._getLineWithWidth(h, this.maxWidth - (this.leftPadding + this.rightPadding), false);
            A.height = this._lineHeight;
            n.push(A);
            var J2 = v2, v2 = Math.max(v2, A.width), w2 = w2 + A.height, h = Ha(h.slice(A.text.length, h.length));
            B2 && w2 > B2 && (A = n.pop(), w2 -= A.height, v2 = J2);
          }
        this._wrappedText = { lines: n, width: v2, height: w2 };
        this.width = v2 + (this.leftPadding + this.rightPadding);
        this.height = w2 + (this.topPadding + this.bottomPadding);
        this.ctx.font = r2;
      };
      ka.prototype._getFontString = function() {
        var h;
        h = this.fontStyle ? this.fontStyle + " " : "";
        h += this.fontWeight ? this.fontWeight + " " : "";
        h += this.fontSize ? this.fontSize + "px " : "";
        var n = this.fontFamily ? this.fontFamily + "" : "";
        !w && n && (n = n.split(",")[0], "'" !== n[0] && '"' !== n[0] && (n = "'" + n + "'"));
        return h += n;
      };
      na(Ua, X);
      na(ya, X);
      ya.prototype.setLayout = function() {
        if (this.text) {
          var h = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, n = h.layoutManager.getFreeSpace(), w2 = n.x1, v2 = n.y1, B2 = 0, J2 = 0, A = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0, I2, K2;
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = n.width - 4 - A * ("center" === this.horizontalAlign ? 2 : 1)), J2 = 0.5 * n.height - this.margin - 2, B2 = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = n.height - 4), J2 = 0.5 * n.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = n.width - 4), J2 = 0.5 * n.height - 4));
          var P;
          r(this.padding) || "number" !== typeof this.padding ? r(this.padding) || "object" !== typeof this.padding || (P = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, P += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : P = 2 * this.padding;
          this.wrap || (J2 = Math.min(J2, 1.5 * this.fontSize + P));
          J2 = new ka(this.ctx, {
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            fontColor: this.fontColor,
            fontStyle: this.fontStyle,
            fontWeight: this.fontWeight,
            horizontalAlign: this.horizontalAlign,
            textAlign: this.horizontalAlign,
            verticalAlign: this.verticalAlign,
            borderColor: this.borderColor,
            borderThickness: this.borderThickness,
            backgroundColor: this.backgroundColor,
            maxWidth: this.maxWidth,
            maxHeight: J2,
            cornerRadius: this.cornerRadius,
            text: this.text,
            padding: this.padding,
            textBaseline: "top"
          });
          P = J2.measureText();
          "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (v2 = n.y1 + 2, K2 = "top") : "bottom" === this.verticalAlign && (v2 = n.y2 - 2 - P.height, K2 = "bottom"), "left" === this.horizontalAlign ? w2 = n.x1 + 2 : "center" === this.horizontalAlign ? w2 = n.x1 + n.width / 2 - P.width / 2 : "right" === this.horizontalAlign && (w2 = n.x2 - 2 - P.width - A), I2 = this.horizontalAlign, this.width = P.width, this.height = P.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (w2 = n.x1 + 2, v2 = n.y2 - 2 - (this.maxWidth / 2 - P.width / 2), B2 = -90, K2 = "left", this.width = P.height, this.height = P.width) : "right" === this.horizontalAlign ? (w2 = n.x2 - 2, v2 = n.y1 + 2 + (this.maxWidth / 2 - P.width / 2), B2 = 90, K2 = "right", this.width = P.height, this.height = P.width) : "center" === this.horizontalAlign && (v2 = h.y1 + (h.height / 2 - P.height / 2), w2 = h.x1 + (h.width / 2 - P.width / 2), K2 = "center", this.width = P.width, this.height = P.height), I2 = "center");
          J2.x = w2;
          J2.y = v2;
          J2.angle = B2;
          J2.horizontalAlign = I2;
          this._textBlock = J2;
          h.layoutManager.registerSpace(K2, { width: this.width + ("left" === K2 || "right" === K2 ? this.margin + 2 : 0), height: this.height + ("top" === K2 || "bottom" === K2 ? this.margin + 2 : 0) });
          this.bounds = { x1: w2, y1: v2, x2: w2 + this.width, y2: v2 + this.height };
          this.ctx.textBaseline = "top";
        }
      };
      ya.prototype.render = function() {
        this._textBlock && this._textBlock.render(true);
      };
      na(Ja, X);
      Ja.prototype.setLayout = ya.prototype.setLayout;
      Ja.prototype.render = ya.prototype.render;
      Va.prototype.get = function(h, n) {
        var r2 = null;
        0 < this.pool.length ? (r2 = this.pool.pop(), Na(r2, h, n)) : r2 = ra(h, n);
        return r2;
      };
      Va.prototype.release = function(h) {
        this.pool.push(h);
      };
      na(Ka, X);
      var Qa = { addTheme: function(h, n) {
        cb[h] = n;
      }, addColorSet: function(h, n) {
        za[h] = n;
      }, addCultureInfo: function(h, n) {
        La[h] = n;
      }, formatNumber: function(h, n, r2) {
        r2 = r2 || "en";
        if (La[r2])
          return fa(h, n || "#,##0.##", new Ka(r2));
        throw "Unknown Culture Name";
      }, formatDate: function(h, r2, w2) {
        w2 = w2 || "en";
        if (La[w2])
          return Aa(h, r2 || "DD MMM YYYY", new Ka(w2));
        throw "Unknown Culture Name";
      } };
      "undefined" !== typeof module && "undefined" !== typeof module.exports ? module.exports = Qa : "function" === typeof define && define.amd ? define([], function() {
        return Qa;
      }) : (window.CanvasJS && window.console && window.console.log("CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features."), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Qa);
      v = Qa.Chart = function() {
        function h(a2, d2) {
          return a2.x - d2.x;
        }
        function n(a2, d2, c2) {
          d2 = d2 || {};
          r(c2) ? (this.predefinedThemes = cb, this.optionsName = this.parent = this.index = null) : (this.parent = c2.parent, this.index = c2.index, this.predefinedThemes = c2.predefinedThemes, this.optionsName = c2.optionsName, this.stockChart = c2.stockChart, this.panel = a2, this.isOptionsInArray = c2.isOptionsInArray);
          this.theme = r(d2.theme) || r(this.predefinedThemes[d2.theme]) ? "light1" : d2.theme;
          n.base.constructor.call(this, "Chart", this.optionsName, d2, this.index, this.parent);
          var b = this;
          this._containerId = a2;
          this._objectsInitialized = false;
          this.overlaidCanvasCtx = this.ctx = null;
          this._indexLabels = [];
          this._panTimerId = 0;
          this._lastTouchEventType = "";
          this._lastTouchData = null;
          this.isAnimating = false;
          this.renderCount = 0;
          this.disableToolTip = this.animatedRender = false;
          this.canvasPool = new Va();
          this.allDOMEventHandlers = [];
          this.panEnabled = false;
          this._defaultCursor = "default";
          this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 };
          this._dataInRenderedOrder = [];
          (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", d2 = a2 = 0, a2 = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, d2 = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.width = a2, this.height = d2, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this.selectedColorSet = "undefined" !== typeof za[this.colorSet] ? za[this.colorSet] : za.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute(
            "class",
            "canvasjs-chart-container"
          ), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", w || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = ra(a2, d2), this._preRenderCanvas = ra(a2, d2), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Da(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", Da(this._preRenderCtx), w ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ra(a2, d2), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = ra(a2, d2), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Da(this.overlaidCanvasCtx)), this._eventManager = new ea2(this), this.windowResizeHandler = K(window, "resize", function() {
            b._updateSize() && b.render();
          }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), S(this._toolBar, { position: "absolute", right: "1px", top: "1px" }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, K(
            this.overlaidCanvas,
            "click",
            function(a3) {
              b._mouseEventHandler(a3);
            },
            this.allDOMEventHandlers
          ), K(this.overlaidCanvas, "mousemove", function(a3) {
            b._mouseEventHandler(a3);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, "mouseup", function(a3) {
            b._mouseEventHandler(a3);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, "mousedown", function(a3) {
            b._mouseEventHandler(a3);
            ua(b._dropdownMenu);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, "mouseout", function(a3) {
            b._mouseEventHandler(a3);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(a3) {
            b._touchEventHandler(a3);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a3) {
            b._touchEventHandler(a3);
          }, this.allDOMEventHandlers), K(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(a3) {
            b._touchEventHandler(a3);
          }, this.allDOMEventHandlers), K(
            this.overlaidCanvas,
            window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel",
            function(a3) {
              b._touchEventHandler(a3);
            },
            this.allDOMEventHandlers
          ), this.toolTip = new Z2(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found');
        }
        function v2(a2, d2) {
          for (var c2 = [], b, e = 0; e < a2.length; e++)
            if (0 == e)
              c2.push(a2[0]);
            else {
              var f, l2, t;
              t = e - 1;
              f = 0 === t ? 0 : t - 1;
              l2 = t === a2.length - 1 ? t : t + 1;
              b = Math.abs((a2[l2].x - a2[f].x) / (0 === a2[l2].x - a2[t].x ? 0.01 : a2[l2].x - a2[t].x)) * (d2 - 1) / 2 + 1;
              var D = (a2[l2].x - a2[f].x) / b;
              b = (a2[l2].y - a2[f].y) / b;
              c2[c2.length] = a2[t].x > a2[f].x && 0 < D || a2[t].x < a2[f].x && 0 > D ? { x: a2[t].x + D / 3, y: a2[t].y + b / 3 } : { x: a2[t].x, y: a2[t].y + b / 9 };
              t = e;
              f = 0 === t ? 0 : t - 1;
              l2 = t === a2.length - 1 ? t : t + 1;
              b = Math.abs((a2[l2].x - a2[f].x) / (0 === a2[t].x - a2[f].x ? 0.01 : a2[t].x - a2[f].x)) * (d2 - 1) / 2 + 1;
              D = (a2[l2].x - a2[f].x) / b;
              b = (a2[l2].y - a2[f].y) / b;
              c2[c2.length] = a2[t].x > a2[f].x && 0 < D || a2[t].x < a2[f].x && 0 > D ? { x: a2[t].x - D / 3, y: a2[t].y - b / 3 } : { x: a2[t].x, y: a2[t].y - b / 9 };
              c2[c2.length] = a2[e];
            }
          return c2;
        }
        function B2(a2, d2, c2, b, e, f, l2, t, D, k) {
          var m = 0;
          k ? (l2.color = f, t.color = f) : k = 1;
          m = D ? Math.abs(e - c2) : Math.abs(b - d2);
          m = 0 < l2.trimLength ? Math.abs(m * l2.trimLength / 100) : Math.abs(m - l2.length);
          D ? (c2 += m / 2, e -= m / 2) : (d2 += m / 2, b -= m / 2);
          var m = 1 === Math.round(l2.thickness) % 2 ? 0.5 : 0, p2 = 1 === Math.round(t.thickness) % 2 ? 0.5 : 0;
          a2.save();
          a2.globalAlpha = k;
          a2.strokeStyle = t.color || f;
          a2.lineWidth = t.thickness || 2;
          a2.setLineDash && a2.setLineDash(J(t.dashType, t.thickness));
          a2.beginPath();
          D && 0 < t.thickness ? (a2.moveTo(b - l2.thickness / 2, Math.round((c2 + e) / 2) - p2), a2.lineTo(d2 + l2.thickness / 2, Math.round((c2 + e) / 2) - p2)) : 0 < t.thickness && (a2.moveTo(Math.round((d2 + b) / 2) - p2, c2 + l2.thickness / 2), a2.lineTo(Math.round((d2 + b) / 2) - p2, e - l2.thickness / 2));
          a2.stroke();
          a2.strokeStyle = l2.color || f;
          a2.lineWidth = l2.thickness || 2;
          a2.setLineDash && a2.setLineDash(J(l2.dashType, l2.thickness));
          a2.beginPath();
          D && 0 < l2.thickness ? (a2.moveTo(b - m, c2), a2.lineTo(b - m, e), a2.moveTo(d2 + m, c2), a2.lineTo(d2 + m, e)) : 0 < l2.thickness && (a2.moveTo(d2, c2 + m), a2.lineTo(b, c2 + m), a2.moveTo(d2, e - m), a2.lineTo(b, e - m));
          a2.stroke();
          a2.restore();
        }
        function R2(a2, d2) {
          R2.base.constructor.call(
            this,
            "Legend",
            "legend",
            d2,
            null,
            a2
          );
          this.chart = a2;
          this.canvas = a2.canvas;
          this.ctx = this.chart.ctx;
          this.ghostCtx = this.chart._eventManager.ghostCtx;
          this.items = [];
          this.optionsName = "legend";
          this.height = this.width = 0;
          this.orientation = null;
          this.dataSeries = [];
          this.bounds = { x1: null, y1: null, x2: null, y2: null };
          "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
          this.lineHeight = Ya(this.fontFamily, this.fontSize, this.fontWeight);
          this.horizontalSpacing = this.fontSize;
        }
        function U(a2, d2, c2, b) {
          U.base.constructor.call(
            this,
            "DataSeries",
            "data",
            d2,
            c2,
            a2
          );
          this.chart = a2;
          this.canvas = a2.canvas;
          this._ctx = a2.canvas.ctx;
          this.index = c2;
          this.noDataPointsInPlotArea = 0;
          this.id = b;
          this.chart._eventManager.objectMap[b] = { id: b, objectType: "dataSeries", dataSeriesIndex: c2 };
          a2 = d2.dataPoints ? d2.dataPoints.length : 0;
          this.dataPointEOs = [];
          for (d2 = 0; d2 < a2; d2++)
            this.dataPointEOs[d2] = {};
          this.dataPointIds = [];
          this.plotUnit = [];
          this.axisY = this.axisX = null;
          this.optionsName = "data";
          this.isOptionsInArray = true;
          null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);
          this.axisPlacement = this.getDefaultAxisPlacement();
          "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));
        }
        function A(a2, d2, c2, b, e, f) {
          A.base.constructor.call(this, "Axis", d2, c2, b, a2);
          this.chart = a2;
          this.canvas = a2.canvas;
          this.ctx = a2.ctx;
          this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;
          this.labels = [];
          this.dataSeries = [];
          this._stripLineLabels = this._ticks = this._labels = null;
          this.dataInfo = {
            min: Infinity,
            max: -Infinity,
            viewPortMin: Infinity,
            viewPortMax: -Infinity,
            minDiff: Infinity
          };
          this.isOptionsInArray = true;
          "axisX" === e ? ("left" === f || "bottom" === f ? (this.optionsName = "axisX", r(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = "axisX2", r(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : "left" === f || "bottom" === f ? (this.optionsName = "axisY", r(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = "axisY2", r(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[b]);
          "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
          "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
          this.type = e;
          "axisX" !== e || c2 && "undefined" !== typeof c2.gridThickness || (this.gridThickness = 0);
          this._position = f;
          this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null };
          this.labelAngle = (this.labelAngle % 360 + 360) % 360;
          90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
          this.options.scaleBreaks && (this.scaleBreaks = new V2(
            this.chart,
            this.options.scaleBreaks,
            ++this.chart._eventManager.lastObjectId,
            this
          ));
          this.stripLines = [];
          if (this.options.stripLines && 0 < this.options.stripLines.length)
            for (a2 = 0; a2 < this.options.stripLines.length; a2++)
              this.stripLines.push(new P(this.chart, this.options.stripLines[a2], a2, ++this.chart._eventManager.lastObjectId, this));
          this.options.crosshair && (this.crosshair = new Y2(this.chart, this.options.crosshair, this));
          this._titleTextBlock = null;
          this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);
          this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
          this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);
          this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
          null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
          null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
          this.trackChanges("viewportMinimum");
          this.trackChanges("viewportMaximum");
        }
        function V2(a2, d2, c2, b) {
          V2.base.constructor.call(
            this,
            "ScaleBreaks",
            "scaleBreaks",
            d2,
            null,
            b
          );
          this.id = c2;
          this.chart = a2;
          this.ctx = this.chart.ctx;
          this.axis = b;
          this.optionsName = "scaleBreaks";
          this.isOptionsInArray = false;
          this._appliedBreaks = [];
          this.customBreaks = [];
          this.autoBreaks = [];
          "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
          this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
          if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
            for (a2 = 0; a2 < this.options.customBreaks.length; a2++)
              this.customBreaks.push(new da2(this.chart, "customBreaks", this.options.customBreaks[a2], a2, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a2].startValue && ("number" === typeof this.customBreaks[a2].endValue && this.customBreaks[a2].endValue !== this.customBreaks[a2].startValue) && this._appliedBreaks.push(this.customBreaks[a2]);
            this._appliedBreaks.sort(function(a3, b2) {
              return a3.startValue - b2.startValue;
            });
            for (a2 = 0; a2 < this._appliedBreaks.length - 1; a2++)
              this._appliedBreaks[a2].endValue >= this._appliedBreaks[a2 + 1].startValue && (this._appliedBreaks[a2].endValue = Math.max(this._appliedBreaks[a2].endValue, this._appliedBreaks[a2 + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a2 + " and " + (a2 + 1) + " are overlapping."), this._appliedBreaks.splice(a2, 2), a2--);
          }
        }
        function da2(a2, d2, c2, b, e, f) {
          da2.base.constructor.call(this, "Break", d2, c2, b, f);
          this.id = e;
          this.chart = a2;
          this.ctx = this.chart.ctx;
          this.scaleBreaks = f;
          this.optionsName = d2;
          this.isOptionsInArray = true;
          this.type = c2.type ? this.type : f.type;
          this.fillOpacity = r(c2.fillOpacity) ? f.fillOpacity : this.fillOpacity;
          this.lineThickness = r(c2.lineThickness) ? f.lineThickness : this.lineThickness;
          this.color = c2.color ? this.color : f.color;
          this.lineColor = c2.lineColor ? this.lineColor : f.lineColor;
          this.lineDashType = c2.lineDashType ? this.lineDashType : f.lineDashType;
          !r(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
          !r(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
          "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a2 = this.startValue, this.startValue = this.endValue, this.endValue = a2);
          this.spacing = "undefined" === typeof c2.spacing ? f.spacing : c2.spacing;
          "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = f.spacing);
          this.size = f.parent.logarithmic ? 1 : 0;
        }
        function P(a2, d2, c2, b, e) {
          P.base.constructor.call(this, "StripLine", "stripLines", d2, c2, e);
          this.id = b;
          this.chart = a2;
          this.ctx = this.chart.ctx;
          this.label = this.label;
          this.axis = e;
          this.optionsName = "stripLines";
          this.isOptionsInArray = true;
          this._thicknessType = "pixel";
          null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null);
        }
        function Y2(a2, d2, c2) {
          Y2.base.constructor.call(this, "Crosshair", "crosshair", d2, null, c2);
          this.chart = a2;
          this.ctx = this.chart.ctx;
          this.axis = c2;
          this.optionsName = "crosshair";
          this._thicknessType = "pixel";
        }
        function Z2(a2, d2) {
          Z2.base.constructor.call(this, "ToolTip", "toolTip", d2, null, a2);
          this.chart = a2;
          this.canvas = a2.canvas;
          this.ctx = this.chart.ctx;
          this.currentDataPointIndex = this.currentSeriesIndex = -1;
          this._prevY = this._prevX = NaN;
          this.containerTransitionDuration = 0.1;
          this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
          this.optionsName = "toolTip";
          this._initialize();
        }
        function ea2(a2) {
          this.chart = a2;
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.ghostCanvas = ra(this.chart.width, this.chart.height, true);
          this.ghostCtx = this.ghostCanvas.getContext("2d");
          this.mouseoveredObjectMaps = [];
        }
        function ja2(a2) {
          this.chart = a2;
          this.ctx = this.chart.plotArea.ctx;
          this.animations = [];
          this.animationRequestId = null;
        }
        na(n, X);
        n.prototype.destroy = function() {
          var a2 = this.allDOMEventHandlers;
          this._animator && this._animator.cancelAllAnimations();
          this._panTimerId && clearTimeout(this._panTimerId);
          for (var d2 = 0; d2 < a2.length; d2++) {
            var c2 = a2[d2][0], b = a2[d2][1], e = a2[d2][2], f = a2[d2][3], f = f || false;
            c2.removeEventListener ? c2.removeEventListener(b, e, f) : c2.detachEvent && c2.detachEvent("on" + b, e);
          }
          this.allDOMEventHandlers = [];
          for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); )
            this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
          for (; this.container && this.container.hasChildNodes(); )
            this.container.removeChild(this.container.lastChild);
          for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes(); )
            this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
          this.container = this._canvasJSContainer = null;
          this.toolTip.container = null;
          this.canvas && xa(this.canvas);
          this.overlaidCanvas && xa(this.overlaidCanvas);
          this._preRenderCanvas && xa(this._preRenderCanvas);
          this._breaksCanvas && xa(this._breaksCanvas);
          this._eventManager && this._eventManager.ghostCanvas && xa(this._eventManager.ghostCanvas);
          this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = null;
        };
        n.prototype._updateOptions = function() {
          var a2 = this;
          this.updateOption("width");
          this.updateOption("height");
          this.updateOption("dataPointWidth");
          this.updateOption("dataPointMinWidth");
          this.updateOption("dataPointMaxWidth");
          this.updateOption("interactivityEnabled");
          this.updateOption("theme");
          this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof za[this.colorSet] ? za[this.colorSet] : za.colorSet1);
          this.updateOption("backgroundColor");
          this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
          this.updateOption("culture");
          this._cultureInfo = new Ka(this.options.culture);
          this.updateOption("animationEnabled");
          this.animationEnabled = this.animationEnabled && w;
          this.updateOption("animationDuration");
          this.updateOption("rangeChanging");
          this.updateOption("rangeChanged");
          this.updateOption("exportEnabled");
          this.updateOption("exportFileName");
          this.updateOption("zoomType");
          this.toolbar = new Ua(this, this.options.toolbar);
          if (this.options.zoomEnabled || this.panEnabled) {
            if (this._zoomButton)
              S(this._zoomButton, { borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, backgroundColor: a2.toolbar.itemBackgroundColor, color: a2.toolbar.fontColor }), pa(this, this._zoomButton, "zoom");
            else {
              var d2 = false;
              ua(this._zoomButton = document.createElement("button"));
              pa(this, this._zoomButton, "pan");
              this._toolBar.appendChild(this._zoomButton);
              this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor;
              K(this._zoomButton, "touchstart", function(a3) {
                d2 = true;
              }, this.allDOMEventHandlers);
              K(this._zoomButton, "click", function() {
                a2.zoomEnabled ? (a2.zoomEnabled = false, a2.panEnabled = true, pa(a2, a2._zoomButton, "zoom")) : (a2.zoomEnabled = true, a2.panEnabled = false, pa(a2, a2._zoomButton, "pan"));
                a2.render();
              }, this.allDOMEventHandlers);
              K(this._zoomButton, "mousemove", function() {
                d2 ? d2 = false : (S(a2._zoomButton, {
                  backgroundColor: a2.toolbar.itemBackgroundColorOnHover,
                  color: a2.toolbar.fontColorOnHover,
                  transition: "0.4s",
                  WebkitTransition: "0.4s"
                }), 0 >= navigator.userAgent.search("MSIE") && S(a2._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
              }, this.allDOMEventHandlers);
              K(this._zoomButton, "mouseout", function() {
                d2 || (S(a2._zoomButton, { backgroundColor: a2.toolbar.itemBackgroundColor, color: a2.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && S(a2._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
              }, this.allDOMEventHandlers);
            }
            this._resetButton ? (S(this._resetButton, { borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, backgroundColor: a2.toolbar.itemBackgroundColor, color: a2.toolbar.fontColor }), this._resetButton.title = this._cultureInfo.resetText) : (d2 = false, ua(this._resetButton = document.createElement("button")), pa(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor, this._toolBar.appendChild(this._resetButton), K(this._resetButton, "touchstart", function(a3) {
              d2 = true;
            }, this.allDOMEventHandlers), K(this._resetButton, "click", function() {
              a2.toolTip.hide();
              a2.toolTip && a2.toolTip.enabled && a2.toolTip.dispatchEvent("hidden", { chart: a2, toolTip: a2.toolTip }, a2.toolTip);
              a2.zoomEnabled || a2.panEnabled ? (a2.zoomEnabled = true, a2.panEnabled = false, pa(a2, a2._zoomButton, "pan"), a2._defaultCursor = "default", a2.overlaidCanvas.style.cursor = a2._defaultCursor) : (a2.zoomEnabled = false, a2.panEnabled = false);
              if (a2.sessionVariables.axisX)
                for (var b = 0; b < a2.sessionVariables.axisX.length; b++)
                  a2.sessionVariables.axisX[b].newViewportMinimum = null, a2.sessionVariables.axisX[b].newViewportMaximum = null;
              if (a2.sessionVariables.axisX2)
                for (b = 0; b < a2.sessionVariables.axisX2.length; b++)
                  a2.sessionVariables.axisX2[b].newViewportMinimum = null, a2.sessionVariables.axisX2[b].newViewportMaximum = null;
              if (a2.sessionVariables.axisY)
                for (b = 0; b < a2.sessionVariables.axisY.length; b++)
                  a2.sessionVariables.axisY[b].newViewportMinimum = null, a2.sessionVariables.axisY[b].newViewportMaximum = null;
              if (a2.sessionVariables.axisY2)
                for (b = 0; b < a2.sessionVariables.axisY2.length; b++)
                  a2.sessionVariables.axisY2[b].newViewportMinimum = null, a2.sessionVariables.axisY2[b].newViewportMaximum = null;
              a2.resetOverlayedCanvas();
              0 >= navigator.userAgent.search("MSIE") && S(a2._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" });
              ua(a2._zoomButton, a2._resetButton);
              a2.stockChart && (a2.stockChart._rangeEventParameter = { stockChart: a2.stockChart, source: "chart", index: a2.stockChart.charts.indexOf(a2), minimum: null, maximum: null });
              a2._dispatchRangeEvent("rangeChanging", "reset");
              a2.stockChart && (a2.stockChart._rangeEventParameter.type = "rangeChanging", a2.stockChart.dispatchEvent("rangeChanging", a2.stockChart._rangeEventParameter, a2.stockChart));
              a2.render();
              a2.syncCharts && a2.syncCharts(null, null);
              a2._dispatchRangeEvent("rangeChanged", "reset");
              a2.stockChart && (a2.stockChart._rangeEventParameter.type = "rangeChanged", a2.stockChart.dispatchEvent("rangeChanged", a2.stockChart._rangeEventParameter, a2.stockChart));
            }, this.allDOMEventHandlers), K(this._resetButton, "mousemove", function() {
              d2 || (S(a2._resetButton, {
                backgroundColor: a2.toolbar.itemBackgroundColorOnHover,
                color: a2.toolbar.fontColorOnHover,
                transition: "0.4s",
                WebkitTransition: "0.4s"
              }), 0 >= navigator.userAgent.search("MSIE") && S(a2._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }));
            }, this.allDOMEventHandlers), K(this._resetButton, "mouseout", function() {
              d2 || (S(a2._resetButton, { backgroundColor: a2.toolbar.itemBackgroundColor, color: a2.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && S(a2._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }));
            }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a2._defaultCursor);
            this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a2._zoomButton.getAttribute("state") === a2._cultureInfo.zoomText ? (this.panEnabled = true, this.zoomEnabled = false) : (this.zoomEnabled = true, this.panEnabled = false), Ma(a2._zoomButton, a2._resetButton)) : (this.zoomEnabled = true, this.panEnabled = false));
          } else
            this.panEnabled = this.zoomEnabled = false;
          hb(this);
          "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? pa(a2, a2._zoomButton, "zoom") : pa(a2, a2._zoomButton, "pan"), a2._resetButton.getAttribute("state") !== a2._cultureInfo.resetText && pa(a2, a2._resetButton, "reset"));
          this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
          for (var c2 in this.toolTip.options)
            this.toolTip.options.hasOwnProperty(c2) && this.toolTip.updateOption(c2);
        };
        n.prototype._updateSize = function() {
          var a2;
          a2 = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas];
          var d2 = 0, c2 = 0;
          this.options.width ? d2 = this.width : this.width = d2 = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;
          this.options.height ? c2 = this.height : this.height = c2 = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
          if (this.canvas.width !== d2 * ia || this.canvas.height !== c2 * ia) {
            for (var b = 0; b < a2.length; b++)
              Na(a2[b], d2, c2);
            this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height, width: this.width, height: this.height };
            a2 = true;
          } else
            a2 = false;
          return a2;
        };
        n.prototype._initialize = function() {
          this.isNavigator = r(this.parent) || r(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? false : true;
          this._animator ? this._animator.cancelAllAnimations() : this._animator = new ja2(this);
          this.removeAllEventListeners();
          this.disableToolTip = false;
          this._axes = [];
          this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
          this._updateOptions();
          this.animatedRender = w && this.animationEnabled && 0 === this.renderCount;
          this._updateSize();
          this.clearCanvas();
          this.ctx.beginPath();
          this.axisX = [];
          this.axisX2 = [];
          this.axisY = [];
          this.axisY2 = [];
          this._indexLabels = [];
          this._dataInRenderedOrder = [];
          this._events = [];
          this._eventManager && this._eventManager.reset();
          this.plotInfo = { axisPlacement: null, plotTypes: [] };
          this.layoutManager = new Fa(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);
          this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
          this.data = [];
          this.title = null;
          this.subtitles = [];
          var a2 = 0, d2 = null;
          if (this.options.data) {
            for (var c2 = 0; c2 < this.options.data.length; c2++)
              if (a2++, !this.options.data[c2].type || 0 <= n._supportedChartTypes.indexOf(this.options.data[c2].type)) {
                var b = new U(this, this.options.data[c2], a2 - 1, ++this._eventManager.lastObjectId);
                "error" === b.type && (b.linkedDataSeriesIndex = r(this.options.data[c2].linkedDataSeriesIndex) ? c2 - 1 : this.options.data[c2].linkedDataSeriesIndex, 0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof b.linkedDataSeriesIndex || "error" === this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null);
                null === b.name && (b.name = "DataSeries " + a2);
                null === b.color ? 1 < this.options.data.length ? (b._colorSet = [this.selectedColorSet[b.index % this.selectedColorSet.length]], b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "candlestick" === b.type || "ohlc" === b.type || "waterfall" === b.type || "boxAndWhisker" === b.type ? [this.selectedColorSet[0]] : this.selectedColorSet : b._colorSet = [b.color];
                null === b.markerSize && (("line" === b.type || "stepLine" === b.type || "spline" === b.type || 0 <= b.type.toLowerCase().indexOf("area")) && b.dataPoints && b.dataPoints.length < this.width / 16 || "scatter" === b.type) && (b.markerSize = 8);
                "bubble" !== b.type && "scatter" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some(function(a3) {
                  return a3.x;
                }) && b.dataPoints.sort(h) : b.dataPoints.sort(h));
                this.data.push(b);
                var e = b.axisPlacement, d2 = d2 || e, f;
                "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (f = 'You cannot combine "' + b.type + '" with pie chart');
                if (f && window.console) {
                  window.console.log(f);
                  return;
                }
              }
            for (c2 = 0; c2 < this.data.length; c2++) {
              if ("none" == d2 && "error" === this.data[c2].type && window.console) {
                window.console.log('You cannot combine "' + b.type + '" with error chart');
                return;
              }
              "error" === this.data[c2].type && (this.data[c2].axisPlacement = this.plotInfo.axisPlacement = d2 || "normal", this.data[c2]._linkedSeries = null === this.data[c2].linkedDataSeriesIndex ? null : this.data[this.data[c2].linkedDataSeriesIndex]);
            }
          }
          this._objectsInitialized = true;
          this._plotAreaElements = [];
        };
        n._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
        n.prototype.setLayout = function() {
          for (var a2 = this._plotAreaElements, d2 = 0; d2 < this.data.length; d2++)
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
              if (!this.data[d2].axisYType || "primary" === this.data[d2].axisYType)
                if (this.options.axisY && 0 < this.options.axisY.length) {
                  if (!this.axisY.length)
                    for (var c2 = 0; c2 < this.options.axisY.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c2] = new A(this, "axisY", this.options.axisY[c2], c2, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c2] = new A(this, "axisY", this.options.axisY[c2], c2, "axisY", "bottom"));
                  this.data[d2].axisY = this.axisY[0 <= this.data[d2].axisYIndex && this.data[d2].axisYIndex < this.axisY.length ? this.data[d2].axisYIndex : 0];
                  this.axisY[0 <= this.data[d2].axisYIndex && this.data[d2].axisYIndex < this.axisY.length ? this.data[d2].axisYIndex : 0].dataSeries.push(this.data[d2]);
                } else
                  this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new A(
                    this,
                    "axisY",
                    this.options.axisY,
                    0,
                    "axisY",
                    "left"
                  )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new A(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[d2].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[d2]);
              if ("secondary" === this.data[d2].axisYType)
                if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                  if (!this.axisY2.length)
                    for (c2 = 0; c2 < this.options.axisY2.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c2] = new A(
                        this,
                        "axisY2",
                        this.options.axisY2[c2],
                        c2,
                        "axisY",
                        "right"
                      )) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c2] = new A(this, "axisY2", this.options.axisY2[c2], c2, "axisY", "top"));
                  this.data[d2].axisY = this.axisY2[0 <= this.data[d2].axisYIndex && this.data[d2].axisYIndex < this.axisY2.length ? this.data[d2].axisYIndex : 0];
                  this.axisY2[0 <= this.data[d2].axisYIndex && this.data[d2].axisYIndex < this.axisY2.length ? this.data[d2].axisYIndex : 0].dataSeries.push(this.data[d2]);
                } else
                  this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new A(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new A(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[d2].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[d2]);
              if (!this.data[d2].axisXType || "primary" === this.data[d2].axisXType)
                if (this.options.axisX && 0 < this.options.axisX.length) {
                  if (!this.axisX.length)
                    for (c2 = 0; c2 < this.options.axisX.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c2] = new A(this, "axisX", this.options.axisX[c2], c2, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c2] = new A(this, "axisX", this.options.axisX[c2], c2, "axisX", "left"));
                  this.data[d2].axisX = this.axisX[0 <= this.data[d2].axisXIndex && this.data[d2].axisXIndex < this.axisX.length ? this.data[d2].axisXIndex : 0];
                  this.axisX[0 <= this.data[d2].axisXIndex && this.data[d2].axisXIndex < this.axisX.length ? this.data[d2].axisXIndex : 0].dataSeries.push(this.data[d2]);
                } else
                  this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new A(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new A(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[d2].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[d2]);
              if ("secondary" === this.data[d2].axisXType)
                if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                  if (!this.axisX2.length)
                    for (c2 = 0; c2 < this.options.axisX2.length; c2++)
                      "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c2] = new A(this, "axisX2", this.options.axisX2[c2], c2, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c2] = new A(this, "axisX2", this.options.axisX2[c2], c2, "axisX", "right"));
                  this.data[d2].axisX = this.axisX2[0 <= this.data[d2].axisXIndex && this.data[d2].axisXIndex < this.axisX2.length ? this.data[d2].axisXIndex : 0];
                  this.axisX2[0 <= this.data[d2].axisXIndex && this.data[d2].axisXIndex < this.axisX2.length ? this.data[d2].axisXIndex : 0].dataSeries.push(this.data[d2]);
                } else
                  this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new A(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new A(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[d2].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[d2]);
            }
          if (this.axisY) {
            for (c2 = 1; c2 < this.axisY.length; c2++)
              "undefined" === typeof this.axisY[c2].options.gridThickness && (this.axisY[c2].gridThickness = 0);
            for (c2 = 0; c2 < this.axisY.length - 1; c2++)
              "undefined" === typeof this.axisY[c2].options.margin && (this.axisY[c2].margin = 10);
          }
          if (this.axisY2) {
            for (c2 = 1; c2 < this.axisY2.length; c2++)
              "undefined" === typeof this.axisY2[c2].options.gridThickness && (this.axisY2[c2].gridThickness = 0);
            for (c2 = 0; c2 < this.axisY2.length - 1; c2++)
              "undefined" === typeof this.axisY2[c2].options.margin && (this.axisY2[c2].margin = 10);
          }
          this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
          if (this.axisX)
            for (c2 = 0; c2 < this.axisX.length; c2++)
              "undefined" === typeof this.axisX[c2].options.gridThickness && (this.axisX[c2].gridThickness = 0);
          if (this.axisX2)
            for (c2 = 0; c2 < this.axisX2.length; c2++)
              "undefined" === typeof this.axisX2[c2].options.gridThickness && (this.axisX2[c2].gridThickness = 0);
          this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
          c2 = false;
          if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) {
            for (d2 = 0; d2 < this._axes.length; d2++)
              if (!r(this._axes[d2].viewportMinimum) || !r(this._axes[d2].viewportMaximum)) {
                c2 = true;
                break;
              }
          }
          c2 ? (Ma(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor) : (ua(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = true, this.panEnabled = false));
          fb(this);
          this._processData();
          this.options.title && (this.title = new ya(this, this.options.title), this.title.dockInsidePlotArea ? a2.push(this.title) : this.title.setLayout());
          if (this.options.subtitles)
            for (d2 = 0; d2 < this.options.subtitles.length; d2++)
              c2 = new Ja(this, this.options.subtitles[d2], d2), this.subtitles.push(c2), c2.dockInsidePlotArea ? a2.push(c2) : c2.setLayout();
          this.legend = new R2(this, this.options.legend);
          for (d2 = 0; d2 < this.data.length; d2++)
            (this.data[d2].showInLegend || "pie" === this.data[d2].type || "doughnut" === this.data[d2].type || "funnel" === this.data[d2].type || "pyramid" === this.data[d2].type) && this.legend.dataSeries.push(this.data[d2]);
          this.legend.dockInsidePlotArea ? a2.push(this.legend) : this.legend.setLayout();
          for (d2 = 0; d2 < this._axes.length; d2++)
            if (this._axes[d2].scaleBreaks && this._axes[d2].scaleBreaks._appliedBreaks.length) {
              w ? (this._breaksCanvas = ra(this.width, this.height, true), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
              break;
            }
          this._preRenderCanvas = ra(this.width, this.height);
          this._preRenderCtx = this._preRenderCanvas.getContext("2d");
          "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || A.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        };
        n.prototype.renderElements = function() {
          if (this.height) {
            var a2 = this._plotAreaElements;
            this.title && !this.title.dockInsidePlotArea && this.title.render();
            for (var d2 = 0; d2 < this.subtitles.length; d2++)
              this.subtitles[d2].dockInsidePlotArea || this.subtitles[d2].render();
            this.legend.dockInsidePlotArea || this.legend.render();
            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement)
              A.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);
            else if ("none" === this.plotInfo.axisPlacement)
              this.preparePlotArea();
            else
              return;
            for (d2 = 0; d2 < a2.length; d2++)
              a2[d2].setLayout(), a2[d2].render();
            var c2 = [];
            if (this.animatedRender) {
              var b = ra(this.width, this.height);
              b.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height);
            }
            ib(this);
            var a2 = this.ctx.miterLimit, e;
            this.ctx.miterLimit = 3;
            w && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));
            for (d2 = 0; d2 < this.plotInfo.plotTypes.length; d2++)
              for (var f = this.plotInfo.plotTypes[d2], l2 = 0; l2 < f.plotUnits.length; l2++) {
                var t = f.plotUnits[l2], D = null;
                t.targetCanvas && xa(t.targetCanvas);
                t.targetCanvas = null;
                this.animatedRender && (t.targetCanvas = ra(this.width, this.height), t.targetCanvasCtx = t.targetCanvas.getContext("2d"), e = t.targetCanvasCtx.miterLimit, t.targetCanvasCtx.miterLimit = 3);
                "line" === t.type ? D = this.renderLine(t) : "stepLine" === t.type ? D = this.renderStepLine(t) : "spline" === t.type ? D = this.renderSpline(t) : "column" === t.type ? D = this.renderColumn(t) : "bar" === t.type ? D = this.renderBar(t) : "area" === t.type ? D = this.renderArea(t) : "stepArea" === t.type ? D = this.renderStepArea(t) : "splineArea" === t.type ? D = this.renderSplineArea(t) : "stackedColumn" === t.type ? D = this.renderStackedColumn(t) : "stackedColumn100" === t.type ? D = this.renderStackedColumn100(t) : "stackedBar" === t.type ? D = this.renderStackedBar(t) : "stackedBar100" === t.type ? D = this.renderStackedBar100(t) : "stackedArea" === t.type ? D = this.renderStackedArea(t) : "stackedArea100" === t.type ? D = this.renderStackedArea100(t) : "bubble" === t.type ? D = D = this.renderBubble(t) : "scatter" === t.type ? D = this.renderScatter(t) : "pie" === t.type ? this.renderPie(t) : "doughnut" === t.type ? this.renderPie(t) : "funnel" === t.type ? D = this.renderFunnel(t) : "pyramid" === t.type ? D = this.renderFunnel(t) : "candlestick" === t.type ? D = this.renderCandlestick(t) : "ohlc" === t.type ? D = this.renderCandlestick(t) : "rangeColumn" === t.type ? D = this.renderRangeColumn(t) : "error" === t.type ? D = this.renderError(t) : "rangeBar" === t.type ? D = this.renderRangeBar(t) : "rangeArea" === t.type ? D = this.renderRangeArea(t) : "rangeSplineArea" === t.type ? D = this.renderRangeSplineArea(t) : "waterfall" === t.type ? D = this.renderWaterfall(t) : "boxAndWhisker" === t.type && (D = this.renderBoxAndWhisker(t));
                for (var k = 0; k < t.dataSeriesIndexes.length; k++)
                  this._dataInRenderedOrder.push(this.data[t.dataSeriesIndexes[k]]);
                this.animatedRender && (t.targetCanvasCtx.miterLimit = e, D && c2.push(D));
              }
            this.ctx.miterLimit = a2;
            this.animatedRender && this._breaksCanvasCtx && c2.push({ source: this._breaksCanvasCtx, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 });
            this.animatedRender && 0 < this._indexLabels.length && (e = ra(this.width, this.height).getContext("2d"), c2.push(this.renderIndexLabels(e)));
            var m = this;
            if (0 < c2.length)
              m.disableToolTip = true, m._animator.animate(200, m.animationDuration, function(a3) {
                m.ctx.clearRect(0, 0, m.width, m.height);
                m.ctx.drawImage(b, 0, 0, Math.floor(m.width * ia), Math.floor(m.height * ia), 0, 0, m.width, m.height);
                for (var e2 = 0; e2 < c2.length; e2++)
                  D = c2[e2], 1 > a3 && "undefined" !== typeof D.startTimePercent ? a3 >= D.startTimePercent && D.animationCallback(D.easingFunction(a3 - D.startTimePercent, 0, 1, 1 - D.startTimePercent), D) : D.animationCallback(D.easingFunction(a3, 0, 1, 1), D);
                m.dispatchEvent("dataAnimationIterationEnd", { chart: m });
              }, function() {
                c2 = [];
                for (var a3 = 0; a3 < m.plotInfo.plotTypes.length; a3++)
                  for (var e2 = m.plotInfo.plotTypes[a3], d3 = 0; d3 < e2.plotUnits.length; d3++) {
                    var f2 = e2.plotUnits[d3];
                    f2.targetCanvas && xa(f2.targetCanvas);
                    f2.targetCanvas = null;
                  }
                b = null;
                m.disableToolTip = false;
                m.dispatchEvent("dataAnimationEnd", { chart: m });
              });
            else {
              if (m._breaksCanvas)
                if (w)
                  m.plotArea.ctx.drawImage(m._breaksCanvas, 0, 0, this.width, this.height);
                else
                  for (k = 0; k < m._axes.length; k++)
                    m._axes[k].createMask();
              0 < m._indexLabels.length && m.renderIndexLabels();
              m.dispatchEvent("dataAnimationIterationEnd", { chart: m });
              m.dispatchEvent("dataAnimationEnd", { chart: m });
            }
            this.attachPlotAreaEventHandlers();
            this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || ua(this._zoomButton, this._resetButton);
            this.toolTip._updateToolTip();
            this.renderCount++;
            Ia && (m = this, setTimeout(function() {
              var a3 = document.getElementById("ghostCanvasCopy");
              a3 && (Na(a3, m.width, m.height), a3.getContext("2d").drawImage(
                m._eventManager.ghostCanvas,
                0,
                0
              ));
            }, 2e3));
            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
            for (k = 0; k < this._axes.length; k++)
              this._axes[k].maskCanvas && (delete this._axes[k].maskCanvas, delete this._axes[k].maskCtx);
          }
        };
        n.prototype.render = function(a2) {
          a2 && (this.options = a2);
          this._initialize();
          this.setLayout();
          this.renderElements();
          this._preRenderCanvas && xa(this._preRenderCanvas);
        };
        n.prototype.attachPlotAreaEventHandlers = function() {
          this.attachEvent({
            context: this,
            chart: this,
            mousedown: this._plotAreaMouseDown,
            mouseup: this._plotAreaMouseUp,
            mousemove: this._plotAreaMouseMove,
            cursor: this.panEnabled ? "move" : "default",
            capture: true,
            bounds: this.plotArea
          });
        };
        n.prototype.categoriseDataSeries = function() {
          for (var a2 = "", d2 = 0; d2 < this.data.length; d2++)
            if (a2 = this.data[d2], a2.dataPoints && (0 !== a2.dataPoints.length && a2.visible) && 0 <= n._supportedChartTypes.indexOf(a2.type)) {
              for (var c2 = null, b = false, e = null, f = false, l2 = 0; l2 < this.plotInfo.plotTypes.length; l2++)
                if (this.plotInfo.plotTypes[l2].type === a2.type) {
                  b = true;
                  c2 = this.plotInfo.plotTypes[l2];
                  break;
                }
              b || (c2 = {
                type: a2.type,
                totalDataSeries: 0,
                plotUnits: []
              }, this.plotInfo.plotTypes.push(c2));
              for (l2 = 0; l2 < c2.plotUnits.length; l2++)
                if (c2.plotUnits[l2].axisYType === a2.axisYType && c2.plotUnits[l2].axisXType === a2.axisXType && c2.plotUnits[l2].axisYIndex === a2.axisYIndex && c2.plotUnits[l2].axisXIndex === a2.axisXIndex) {
                  f = true;
                  e = c2.plotUnits[l2];
                  break;
                }
              f || (e = { type: a2.type, previousDataSeriesCount: 0, index: c2.plotUnits.length, plotType: c2, axisXType: a2.axisXType, axisYType: a2.axisYType, axisYIndex: a2.axisYIndex, axisXIndex: a2.axisXIndex, axisY: "primary" === a2.axisYType ? this.axisY[0 <= a2.axisYIndex && a2.axisYIndex < this.axisY.length ? a2.axisYIndex : 0] : this.axisY2[0 <= a2.axisYIndex && a2.axisYIndex < this.axisY2.length ? a2.axisYIndex : 0], axisX: "primary" === a2.axisXType ? this.axisX[0 <= a2.axisXIndex && a2.axisXIndex < this.axisX.length ? a2.axisXIndex : 0] : this.axisX2[0 <= a2.axisXIndex && a2.axisXIndex < this.axisX2.length ? a2.axisXIndex : 0], dataSeriesIndexes: [], yTotals: [], yAbsTotals: [] }, c2.plotUnits.push(e));
              c2.totalDataSeries++;
              e.dataSeriesIndexes.push(d2);
              a2.plotUnit = e;
            }
          for (d2 = 0; d2 < this.plotInfo.plotTypes.length; d2++)
            for (c2 = this.plotInfo.plotTypes[d2], l2 = a2 = 0; l2 < c2.plotUnits.length; l2++)
              c2.plotUnits[l2].previousDataSeriesCount = a2, a2 += c2.plotUnits[l2].dataSeriesIndexes.length;
        };
        n.prototype.assignIdToDataPoints = function() {
          for (var a2 = 0; a2 < this.data.length; a2++) {
            var d2 = this.data[a2];
            if (d2.dataPoints)
              for (var c2 = d2.dataPoints.length, b = 0; b < c2; b++)
                d2.dataPointIds[b] = ++this._eventManager.lastObjectId;
          }
        };
        n.prototype._processData = function() {
          this.assignIdToDataPoints();
          this.categoriseDataSeries();
          for (var a2 = 0; a2 < this.plotInfo.plotTypes.length; a2++)
            for (var d2 = this.plotInfo.plotTypes[a2], c2 = 0; c2 < d2.plotUnits.length; c2++) {
              var b = d2.plotUnits[c2];
              "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type ? this._processMultiseriesPlotUnit(b) : "stackedColumn" === b.type || "stackedBar" === b.type || "stackedArea" === b.type ? this._processStackedPlotUnit(b) : "stackedColumn100" === b.type || "stackedBar100" === b.type || "stackedArea100" === b.type ? this._processStacked100PlotUnit(b) : "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? this._processMultiYPlotUnit(b) : "waterfall" === b.type && this._processSpecificPlotUnit(b);
            }
          this.calculateAutoBreaks();
        };
        n.prototype._processMultiseriesPlotUnit = function(a2) {
          if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length))
            for (var d2 = a2.axisY.dataInfo, c2 = a2.axisX.dataInfo, b, e, f = false, l2 = 0; l2 < a2.dataSeriesIndexes.length; l2++) {
              var t = this.data[a2.dataSeriesIndexes[l2]], D = 0, k = false, m = false, p2;
              if ("normal" === t.axisPlacement || "xySwapped" === t.axisPlacement)
                var q = a2.axisX.sessionVariables.newViewportMinimum ? a2.axisX.sessionVariables.newViewportMinimum : a2.axisX.options && a2.axisX.options.viewportMinimum ? a2.axisX.options.viewportMinimum : a2.axisX.options && a2.axisX.options.minimum ? a2.axisX.options.minimum : a2.axisX.logarithmic ? 0 : -Infinity, g = a2.axisX.sessionVariables.newViewportMaximum ? a2.axisX.sessionVariables.newViewportMaximum : a2.axisX.options && a2.axisX.options.viewportMaximum ? a2.axisX.options.viewportMaximum : a2.axisX.options && a2.axisX.options.maximum ? a2.axisX.options.maximum : Infinity;
              if (t.dataPoints[D].x && t.dataPoints[D].x.getTime || "dateTime" === t.xValueType)
                f = true;
              for (D = 0; D < t.dataPoints.length; D++) {
                "undefined" === typeof t.dataPoints[D].x && (t.dataPoints[D].x = D + (a2.axisX.logarithmic ? 1 : 0));
                t.dataPoints[D].x.getTime ? (f = true, b = t.dataPoints[D].x.getTime()) : b = t.dataPoints[D].x;
                e = t.dataPoints[D].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                e < d2.min && "number" === typeof e && (d2.min = e);
                e > d2.max && "number" === typeof e && (d2.max = e);
                if (0 < D) {
                  if (a2.axisX.logarithmic) {
                    var s = b / t.dataPoints[D - 1].x;
                    1 > s && (s = 1 / s);
                    c2.minDiff > s && 1 !== s && (c2.minDiff = s);
                  } else
                    s = b - t.dataPoints[D - 1].x, 0 > s && (s *= -1), c2.minDiff > s && 0 !== s && (c2.minDiff = s);
                  null !== e && null !== t.dataPoints[D - 1].y && (a2.axisY.logarithmic ? (s = e / t.dataPoints[D - 1].y, 1 > s && (s = 1 / s), d2.minDiff > s && 1 !== s && (d2.minDiff = s)) : (s = e - t.dataPoints[D - 1].y, 0 > s && (s *= -1), d2.minDiff > s && 0 !== s && (d2.minDiff = s)));
                }
                if (b < q && !k)
                  null !== e && (p2 = b);
                else {
                  if (!k && (k = true, 0 < D)) {
                    D -= 2;
                    continue;
                  }
                  if (b > g && !m)
                    m = true;
                  else if (b > g && m)
                    continue;
                  t.dataPoints[D].label && (a2.axisX.labels[b] = t.dataPoints[D].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === e ? c2.viewPortMin === b && p2 < b && (c2.viewPortMin = p2) : (e < d2.viewPortMin && "number" === typeof e && (d2.viewPortMin = e), e > d2.viewPortMax && "number" === typeof e && (d2.viewPortMax = e));
                }
              }
              t.axisX.valueType = t.xValueType = f ? "dateTime" : "number";
            }
        };
        n.prototype._processStackedPlotUnit = function(a2) {
          if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length)) {
            for (var d2 = a2.axisY.dataInfo, c2 = a2.axisX.dataInfo, b, e, f = false, l2 = [], t = [], D = Infinity, k = -Infinity, m = 0; m < a2.dataSeriesIndexes.length; m++) {
              var p2 = this.data[a2.dataSeriesIndexes[m]], q = 0, g = false, s = false, h2;
              if ("normal" === p2.axisPlacement || "xySwapped" === p2.axisPlacement)
                var ca = a2.axisX.sessionVariables.newViewportMinimum ? a2.axisX.sessionVariables.newViewportMinimum : a2.axisX.options && a2.axisX.options.viewportMinimum ? a2.axisX.options.viewportMinimum : a2.axisX.options && a2.axisX.options.minimum ? a2.axisX.options.minimum : -Infinity, u2 = a2.axisX.sessionVariables.newViewportMaximum ? a2.axisX.sessionVariables.newViewportMaximum : a2.axisX.options && a2.axisX.options.viewportMaximum ? a2.axisX.options.viewportMaximum : a2.axisX.options && a2.axisX.options.maximum ? a2.axisX.options.maximum : Infinity;
              if (p2.dataPoints[q].x && p2.dataPoints[q].x.getTime || "dateTime" === p2.xValueType)
                f = true;
              for (q = 0; q < p2.dataPoints.length; q++) {
                "undefined" === typeof p2.dataPoints[q].x && (p2.dataPoints[q].x = q + (a2.axisX.logarithmic ? 1 : 0));
                p2.dataPoints[q].x.getTime ? (f = true, b = p2.dataPoints[q].x.getTime()) : b = p2.dataPoints[q].x;
                e = r(p2.dataPoints[q].y) ? 0 : p2.dataPoints[q].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                if (0 < q) {
                  if (a2.axisX.logarithmic) {
                    var n2 = b / p2.dataPoints[q - 1].x;
                    1 > n2 && (n2 = 1 / n2);
                    c2.minDiff > n2 && 1 !== n2 && (c2.minDiff = n2);
                  } else
                    n2 = b - p2.dataPoints[q - 1].x, 0 > n2 && (n2 *= -1), c2.minDiff > n2 && 0 !== n2 && (c2.minDiff = n2);
                  null !== e && null !== p2.dataPoints[q - 1].y && (a2.axisY.logarithmic ? 0 < e && (n2 = e / p2.dataPoints[q - 1].y, 1 > n2 && (n2 = 1 / n2), d2.minDiff > n2 && 1 !== n2 && (d2.minDiff = n2)) : (n2 = e - p2.dataPoints[q - 1].y, 0 > n2 && (n2 *= -1), d2.minDiff > n2 && 0 !== n2 && (d2.minDiff = n2)));
                }
                if (b < ca && !g)
                  null !== p2.dataPoints[q].y && (h2 = b);
                else {
                  if (!g && (g = true, 0 < q)) {
                    q -= 2;
                    continue;
                  }
                  if (b > u2 && !s)
                    s = true;
                  else if (b > u2 && s)
                    continue;
                  p2.dataPoints[q].label && (a2.axisX.labels[b] = p2.dataPoints[q].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === p2.dataPoints[q].y ? c2.viewPortMin === b && h2 < b && (c2.viewPortMin = h2) : (a2.yTotals[b] = (a2.yTotals[b] ? a2.yTotals[b] : 0) + e, a2.yAbsTotals[b] = (a2.yAbsTotals[b] ? a2.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? l2[b] ? l2[b] += e : (l2[b] = e, D = Math.min(e, D)) : t[b] ? t[b] += e : (t[b] = e, k = Math.max(e, k)));
                }
              }
              a2.axisY.scaleBreaks && (a2.axisY.scaleBreaks.autoCalculate && 1 <= a2.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (d2.dataPointYPositiveSums ? (d2.dataPointYPositiveSums.push.apply(d2.dataPointYPositiveSums, l2), d2.dataPointYNegativeSums.push.apply(d2.dataPointYPositiveSums, t)) : (d2.dataPointYPositiveSums = l2, d2.dataPointYNegativeSums = t));
              p2.axisX.valueType = p2.xValueType = f ? "dateTime" : "number";
            }
            for (q in l2)
              l2.hasOwnProperty(q) && !isNaN(q) && (a2 = l2[q], a2 < d2.min && (d2.min = Math.min(a2, D)), a2 > d2.max && (d2.max = a2), q < c2.viewPortMin || q > c2.viewPortMax || (a2 < d2.viewPortMin && (d2.viewPortMin = Math.min(a2, D)), a2 > d2.viewPortMax && (d2.viewPortMax = a2)));
            for (q in t)
              t.hasOwnProperty(q) && !isNaN(q) && (a2 = t[q], a2 < d2.min && (d2.min = a2), a2 > d2.max && (d2.max = Math.max(a2, k)), q < c2.viewPortMin || q > c2.viewPortMax || (a2 < d2.viewPortMin && (d2.viewPortMin = a2), a2 > d2.viewPortMax && (d2.viewPortMax = Math.max(a2, k))));
          }
        };
        n.prototype._processStacked100PlotUnit = function(a2) {
          if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length)) {
            for (var d2 = a2.axisY.dataInfo, c2 = a2.axisX.dataInfo, b, e, f = false, l2 = false, t = false, D = [], k = 0; k < a2.dataSeriesIndexes.length; k++) {
              var m = this.data[a2.dataSeriesIndexes[k]], p2 = 0, q = false, g = false, s;
              if ("normal" === m.axisPlacement || "xySwapped" === m.axisPlacement)
                var h2 = a2.axisX.sessionVariables.newViewportMinimum ? a2.axisX.sessionVariables.newViewportMinimum : a2.axisX.options && a2.axisX.options.viewportMinimum ? a2.axisX.options.viewportMinimum : a2.axisX.options && a2.axisX.options.minimum ? a2.axisX.options.minimum : -Infinity, n2 = a2.axisX.sessionVariables.newViewportMaximum ? a2.axisX.sessionVariables.newViewportMaximum : a2.axisX.options && a2.axisX.options.viewportMaximum ? a2.axisX.options.viewportMaximum : a2.axisX.options && a2.axisX.options.maximum ? a2.axisX.options.maximum : Infinity;
              if (m.dataPoints[p2].x && m.dataPoints[p2].x.getTime || "dateTime" === m.xValueType)
                f = true;
              for (p2 = 0; p2 < m.dataPoints.length; p2++) {
                "undefined" === typeof m.dataPoints[p2].x && (m.dataPoints[p2].x = p2 + (a2.axisX.logarithmic ? 1 : 0));
                m.dataPoints[p2].x.getTime ? (f = true, b = m.dataPoints[p2].x.getTime()) : b = m.dataPoints[p2].x;
                e = r(m.dataPoints[p2].y) ? null : m.dataPoints[p2].y;
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                if (0 < p2) {
                  if (a2.axisX.logarithmic) {
                    var u2 = b / m.dataPoints[p2 - 1].x;
                    1 > u2 && (u2 = 1 / u2);
                    c2.minDiff > u2 && 1 !== u2 && (c2.minDiff = u2);
                  } else
                    u2 = b - m.dataPoints[p2 - 1].x, 0 > u2 && (u2 *= -1), c2.minDiff > u2 && 0 !== u2 && (c2.minDiff = u2);
                  r(e) || null === m.dataPoints[p2 - 1].y || (a2.axisY.logarithmic ? 0 < e && (u2 = e / m.dataPoints[p2 - 1].y, 1 > u2 && (u2 = 1 / u2), d2.minDiff > u2 && 1 !== u2 && (d2.minDiff = u2)) : (u2 = e - m.dataPoints[p2 - 1].y, 0 > u2 && (u2 *= -1), d2.minDiff > u2 && 0 !== u2 && (d2.minDiff = u2)));
                }
                if (b < h2 && !q)
                  null !== e && (s = b);
                else {
                  if (!q && (q = true, 0 < p2)) {
                    p2 -= 2;
                    continue;
                  }
                  if (b > n2 && !g)
                    g = true;
                  else if (b > n2 && g)
                    continue;
                  m.dataPoints[p2].label && (a2.axisX.labels[b] = m.dataPoints[p2].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  null === e ? c2.viewPortMin === b && s < b && (c2.viewPortMin = s) : (a2.yTotals[b] = (a2.yTotals[b] ? a2.yTotals[b] : 0) + e, a2.yAbsTotals[b] = (a2.yAbsTotals[b] ? a2.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? l2 = true : 0 > e && (t = true), D[b] = D[b] ? D[b] + Math.abs(e) : Math.abs(e));
                }
              }
              m.axisX.valueType = m.xValueType = f ? "dateTime" : "number";
            }
            a2.axisY.logarithmic ? (d2.max = r(d2.viewPortMax) ? 99 * Math.pow(a2.axisY.logarithmBase, -0.05) : Math.max(d2.viewPortMax, 99 * Math.pow(a2.axisY.logarithmBase, -0.05)), d2.min = r(d2.viewPortMin) ? 1 : Math.min(d2.viewPortMin, 1)) : l2 && !t ? (d2.max = r(d2.viewPortMax) ? 99 : Math.max(d2.viewPortMax, 99), d2.min = r(d2.viewPortMin) ? 1 : Math.min(d2.viewPortMin, 1)) : l2 && t ? (d2.max = r(d2.viewPortMax) ? 99 : Math.max(d2.viewPortMax, 99), d2.min = r(d2.viewPortMin) ? -99 : Math.min(d2.viewPortMin, -99)) : !l2 && t && (d2.max = r(d2.viewPortMax) ? -1 : Math.max(d2.viewPortMax, -1), d2.min = r(d2.viewPortMin) ? -99 : Math.min(d2.viewPortMin, -99));
            d2.viewPortMin = d2.min;
            d2.viewPortMax = d2.max;
            a2.dataPointYSums = D;
          }
        };
        n.prototype._processMultiYPlotUnit = function(a2) {
          if (a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length))
            for (var d2 = a2.axisY.dataInfo, c2 = a2.axisX.dataInfo, b, e, f, l2, t = false, D = 0; D < a2.dataSeriesIndexes.length; D++) {
              var k = this.data[a2.dataSeriesIndexes[D]], m = 0, p2 = false, q = false, g, s, h2;
              if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement)
                var n2 = a2.axisX.sessionVariables.newViewportMinimum ? a2.axisX.sessionVariables.newViewportMinimum : a2.axisX.options && a2.axisX.options.viewportMinimum ? a2.axisX.options.viewportMinimum : a2.axisX.options && a2.axisX.options.minimum ? a2.axisX.options.minimum : a2.axisX.logarithmic ? 0 : -Infinity, u2 = a2.axisX.sessionVariables.newViewportMaximum ? a2.axisX.sessionVariables.newViewportMaximum : a2.axisX.options && a2.axisX.options.viewportMaximum ? a2.axisX.options.viewportMaximum : a2.axisX.options && a2.axisX.options.maximum ? a2.axisX.options.maximum : Infinity;
              if (k.dataPoints[m].x && k.dataPoints[m].x.getTime || "dateTime" === k.xValueType)
                t = true;
              for (m = 0; m < k.dataPoints.length; m++) {
                "undefined" === typeof k.dataPoints[m].x && (k.dataPoints[m].x = m + (a2.axisX.logarithmic ? 1 : 0));
                k.dataPoints[m].x.getTime ? (t = true, b = k.dataPoints[m].x.getTime()) : b = k.dataPoints[m].x;
                if ((e = k.dataPoints[m].y) && e.length) {
                  f = Math.min.apply(null, e);
                  l2 = Math.max.apply(null, e);
                  s = true;
                  for (var r2 = 0; r2 < e.length; r2++)
                    null === e.k && (s = false);
                  s && (p2 || (h2 = g), g = b);
                }
                b < c2.min && (c2.min = b);
                b > c2.max && (c2.max = b);
                f < d2.min && (d2.min = f);
                l2 > d2.max && (d2.max = l2);
                0 < m && (a2.axisX.logarithmic ? (s = b / k.dataPoints[m - 1].x, 1 > s && (s = 1 / s), c2.minDiff > s && 1 !== s && (c2.minDiff = s)) : (s = b - k.dataPoints[m - 1].x, 0 > s && (s *= -1), c2.minDiff > s && 0 !== s && (c2.minDiff = s)), e && (null !== e[0] && k.dataPoints[m - 1].y && null !== k.dataPoints[m - 1].y[0]) && (a2.axisY.logarithmic ? (s = e[0] / k.dataPoints[m - 1].y[0], 1 > s && (s = 1 / s), d2.minDiff > s && 1 !== s && (d2.minDiff = s)) : (s = e[0] - k.dataPoints[m - 1].y[0], 0 > s && (s *= -1), d2.minDiff > s && 0 !== s && (d2.minDiff = s))));
                if (!(b < n2) || p2) {
                  if (!p2 && (p2 = true, 0 < m)) {
                    m -= 2;
                    g = h2;
                    continue;
                  }
                  if (b > u2 && !q)
                    q = true;
                  else if (b > u2 && q)
                    continue;
                  k.dataPoints[m].label && (a2.axisX.labels[b] = k.dataPoints[m].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  if (c2.viewPortMin === b && e) {
                    for (r2 = 0; r2 < e.length; r2++)
                      if (null === e[r2] && g < b) {
                        c2.viewPortMin = g;
                        break;
                      }
                  }
                  null === e ? c2.viewPortMin === b && g < b && (c2.viewPortMin = g) : (f < d2.viewPortMin && (d2.viewPortMin = f), l2 > d2.viewPortMax && (d2.viewPortMax = l2));
                }
              }
              k.axisX.valueType = k.xValueType = t ? "dateTime" : "number";
            }
        };
        n.prototype._processSpecificPlotUnit = function(a2) {
          if ("waterfall" === a2.type && a2.dataSeriesIndexes && !(1 > a2.dataSeriesIndexes.length))
            for (var d2 = a2.axisY.dataInfo, c2 = a2.axisX.dataInfo, b, e, f = false, l2 = 0; l2 < a2.dataSeriesIndexes.length; l2++) {
              var t = this.data[a2.dataSeriesIndexes[l2]], D = 0, k = false, m = false, p2 = b = 0;
              if ("normal" === t.axisPlacement || "xySwapped" === t.axisPlacement)
                var q = a2.axisX.sessionVariables.newViewportMinimum ? a2.axisX.sessionVariables.newViewportMinimum : a2.axisX.options && a2.axisX.options.viewportMinimum ? a2.axisX.options.viewportMinimum : a2.axisX.options && a2.axisX.options.minimum ? a2.axisX.options.minimum : a2.axisX.logarithmic ? 0 : -Infinity, g = a2.axisX.sessionVariables.newViewportMaximum ? a2.axisX.sessionVariables.newViewportMaximum : a2.axisX.options && a2.axisX.options.viewportMaximum ? a2.axisX.options.viewportMaximum : a2.axisX.options && a2.axisX.options.maximum ? a2.axisX.options.maximum : Infinity;
              if (t.dataPoints[D].x && t.dataPoints[D].x.getTime || "dateTime" === t.xValueType)
                f = true;
              for (D = 0; D < t.dataPoints.length; D++)
                "undefined" !== typeof t.dataPoints[D].isCumulativeSum && true === t.dataPoints[D].isCumulativeSum ? (t.dataPointEOs[D].cumulativeSumYStartValue = 0, t.dataPointEOs[D].cumulativeSum = 0 === D ? 0 : t.dataPointEOs[D - 1].cumulativeSum, t.dataPoints[D].y = 0 === D ? 0 : t.dataPointEOs[D - 1].cumulativeSum) : "undefined" !== typeof t.dataPoints[D].isIntermediateSum && true === t.dataPoints[D].isIntermediateSum ? (t.dataPointEOs[D].cumulativeSumYStartValue = p2, t.dataPointEOs[D].cumulativeSum = 0 === D ? 0 : t.dataPointEOs[D - 1].cumulativeSum, t.dataPoints[D].y = 0 === D ? 0 : b, p2 = 0 === D ? 0 : t.dataPointEOs[D - 1].cumulativeSum, b = 0) : (e = "number" !== typeof t.dataPoints[D].y ? 0 : t.dataPoints[D].y, t.dataPointEOs[D].cumulativeSumYStartValue = 0 === D ? 0 : t.dataPointEOs[D - 1].cumulativeSum, t.dataPointEOs[D].cumulativeSum = 0 === D ? e : t.dataPointEOs[D - 1].cumulativeSum + e, b += e);
              for (D = 0; D < t.dataPoints.length; D++)
                if ("undefined" === typeof t.dataPoints[D].x && (t.dataPoints[D].x = D + (a2.axisX.logarithmic ? 1 : 0)), t.dataPoints[D].x.getTime ? (f = true, b = t.dataPoints[D].x.getTime()) : b = t.dataPoints[D].x, e = t.dataPoints[D].y, b < c2.min && (c2.min = b), b > c2.max && (c2.max = b), t.dataPointEOs[D].cumulativeSum < d2.min && (d2.min = t.dataPointEOs[D].cumulativeSum), t.dataPointEOs[D].cumulativeSum > d2.max && (d2.max = t.dataPointEOs[D].cumulativeSum), 0 < D && (a2.axisX.logarithmic ? (p2 = b / t.dataPoints[D - 1].x, 1 > p2 && (p2 = 1 / p2), c2.minDiff > p2 && 1 !== p2 && (c2.minDiff = p2)) : (p2 = b - t.dataPoints[D - 1].x, 0 > p2 && (p2 *= -1), c2.minDiff > p2 && 0 !== p2 && (c2.minDiff = p2)), null !== e && null !== t.dataPoints[D - 1].y && (a2.axisY.logarithmic ? (e = t.dataPointEOs[D].cumulativeSum / t.dataPointEOs[D - 1].cumulativeSum, 1 > e && (e = 1 / e), d2.minDiff > e && 1 !== e && (d2.minDiff = e)) : (e = t.dataPointEOs[D].cumulativeSum - t.dataPointEOs[D - 1].cumulativeSum, 0 > e && (e *= -1), d2.minDiff > e && 0 !== e && (d2.minDiff = e)))), !(b < q) || k) {
                  if (!k && (k = true, 0 < D)) {
                    D -= 2;
                    continue;
                  }
                  if (b > g && !m)
                    m = true;
                  else if (b > g && m)
                    continue;
                  t.dataPoints[D].label && (a2.axisX.labels[b] = t.dataPoints[D].label);
                  b < c2.viewPortMin && (c2.viewPortMin = b);
                  b > c2.viewPortMax && (c2.viewPortMax = b);
                  0 < D && (t.dataPointEOs[D - 1].cumulativeSum < d2.viewPortMin && (d2.viewPortMin = t.dataPointEOs[D - 1].cumulativeSum), t.dataPointEOs[D - 1].cumulativeSum > d2.viewPortMax && (d2.viewPortMax = t.dataPointEOs[D - 1].cumulativeSum));
                  t.dataPointEOs[D].cumulativeSum < d2.viewPortMin && (d2.viewPortMin = t.dataPointEOs[D].cumulativeSum);
                  t.dataPointEOs[D].cumulativeSum > d2.viewPortMax && (d2.viewPortMax = t.dataPointEOs[D].cumulativeSum);
                }
              t.axisX.valueType = t.xValueType = f ? "dateTime" : "number";
            }
        };
        n.prototype.calculateAutoBreaks = function() {
          function a2(a3, b2, c3, e2) {
            if (e2)
              return c3 = Math.pow(
                Math.min(c3 * a3 / b2, b2 / a3),
                0.2
              ), 1 >= c3 && (c3 = Math.pow(1 > a3 ? 1 / a3 : Math.min(b2 / a3, a3), 0.25)), { startValue: a3 * c3, endValue: b2 / c3 };
            c3 = 0.2 * Math.min(c3 - b2 + a3, b2 - a3);
            0 >= c3 && (c3 = 0.25 * Math.min(b2 - a3, Math.abs(a3)));
            return { startValue: a3 + c3, endValue: b2 - c3 };
          }
          function d2(a3) {
            if (a3.dataSeriesIndexes && !(1 > a3.dataSeriesIndexes.length)) {
              var b2 = a3.axisX.scaleBreaks && a3.axisX.scaleBreaks.autoCalculate && 1 <= a3.axisX.scaleBreaks.maxNumberOfAutoBreaks, c3 = a3.axisY.scaleBreaks && a3.axisY.scaleBreaks.autoCalculate && 1 <= a3.axisY.scaleBreaks.maxNumberOfAutoBreaks;
              if (b2 || c3)
                for (var d3 = a3.axisY.dataInfo, g2 = a3.axisX.dataInfo, f2, k2 = g2.min, l3 = g2.max, m2 = d3.min, p3 = d3.max, g2 = g2._dataRanges, d3 = d3._dataRanges, q2, t2 = 0, D2 = 0; D2 < a3.dataSeriesIndexes.length; D2++) {
                  var h2 = e.data[a3.dataSeriesIndexes[D2]];
                  if (!(4 > h2.dataPoints.length)) {
                    for (t2 = 0; t2 < h2.dataPoints.length; t2++)
                      if (b2 && (q2 = (l3 + 1 - k2) * Math.max(parseFloat(a3.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, f2 = h2.dataPoints[t2].x.getTime ? h2.dataPoints[t2].x.getTime() : h2.dataPoints[t2].x, q2 = Math.floor((f2 - k2) / q2), f2 < g2[q2].min && (g2[q2].min = f2), f2 > g2[q2].max && (g2[q2].max = f2)), c3) {
                        var n2 = (p3 + 1 - m2) * Math.max(parseFloat(a3.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                        if ((f2 = "waterfall" === a3.type ? h2.dataPointEOs[t2].cumulativeSum : h2.dataPoints[t2].y) && f2.length)
                          for (var w2 = 0; w2 < f2.length; w2++)
                            q2 = Math.floor((f2[w2] - m2) / n2), f2[w2] < d3[q2].min && (d3[q2].min = f2[w2]), f2[w2] > d3[q2].max && (d3[q2].max = f2[w2]);
                        else
                          r(f2) || (q2 = Math.floor((f2 - m2) / n2), f2 < d3[q2].min && (d3[q2].min = f2), f2 > d3[q2].max && (d3[q2].max = f2));
                      }
                  }
                }
            }
          }
          function c2(a3) {
            if (a3.dataSeriesIndexes && !(1 > a3.dataSeriesIndexes.length) && a3.axisX.scaleBreaks && a3.axisX.scaleBreaks.autoCalculate && 1 <= a3.axisX.scaleBreaks.maxNumberOfAutoBreaks)
              for (var b2 = a3.axisX.dataInfo, c3 = b2.min, d3 = b2.max, g2 = b2._dataRanges, f2, k2 = 0, l3 = 0; l3 < a3.dataSeriesIndexes.length; l3++) {
                var m2 = e.data[a3.dataSeriesIndexes[l3]];
                if (!(4 > m2.dataPoints.length))
                  for (k2 = 0; k2 < m2.dataPoints.length; k2++)
                    f2 = (d3 + 1 - c3) * Math.max(parseFloat(a3.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, b2 = m2.dataPoints[k2].x.getTime ? m2.dataPoints[k2].x.getTime() : m2.dataPoints[k2].x, f2 = Math.floor((b2 - c3) / f2), b2 < g2[f2].min && (g2[f2].min = b2), b2 > g2[f2].max && (g2[f2].max = b2);
              }
          }
          for (var b, e = this, f = false, l2 = 0; l2 < this._axes.length; l2++)
            if (this._axes[l2].scaleBreaks && this._axes[l2].scaleBreaks.autoCalculate && 1 <= this._axes[l2].scaleBreaks.maxNumberOfAutoBreaks) {
              f = true;
              this._axes[l2].dataInfo._dataRanges = [];
              for (var t = 0; t < 100 / Math.max(parseFloat(this._axes[l2].scaleBreaks.collapsibleThreshold) || 10, 10); t++)
                this._axes[l2].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity });
            }
          if (f) {
            for (l2 = 0; l2 < this.plotInfo.plotTypes.length; l2++)
              for (f = this.plotInfo.plotTypes[l2], t = 0; t < f.plotUnits.length; t++)
                b = f.plotUnits[t], "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type || "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "waterfall" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? d2(b) : 0 <= b.type.indexOf("stacked") && c2(b);
            for (l2 = 0; l2 < this._axes.length; l2++)
              if (this._axes[l2].dataInfo._dataRanges) {
                var D = this._axes[l2].dataInfo.min;
                b = (this._axes[l2].dataInfo.max + 1 - D) * Math.max(parseFloat(this._axes[l2].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                var k = this._axes[l2].dataInfo._dataRanges, m, p2, f = [];
                if (this._axes[l2].dataInfo.dataPointYPositiveSums) {
                  var q = this._axes[l2].dataInfo.dataPointYPositiveSums;
                  m = k;
                  for (t in q)
                    if (q.hasOwnProperty(t) && !isNaN(t) && (p2 = q[t], !r(p2))) {
                      var g = Math.floor((p2 - D) / b);
                      p2 < m[g].min && (m[g].min = p2);
                      p2 > m[g].max && (m[g].max = p2);
                    }
                  delete this._axes[l2].dataInfo.dataPointYPositiveSums;
                }
                if (this._axes[l2].dataInfo.dataPointYNegativeSums) {
                  q = this._axes[l2].dataInfo.dataPointYNegativeSums;
                  m = k;
                  for (t in q)
                    q.hasOwnProperty(t) && !isNaN(t) && (p2 = -1 * q[t], r(p2) || (g = Math.floor((p2 - D) / b), p2 < m[g].min && (m[g].min = p2), p2 > m[g].max && (m[g].max = p2)));
                  delete this._axes[l2].dataInfo.dataPointYNegativeSums;
                }
                for (t = 0; t < k.length - 1; t++)
                  if (m = k[t].max, isFinite(m))
                    for (; t < k.length - 1; )
                      if (D = k[t + 1].min, isFinite(D)) {
                        p2 = D - m;
                        p2 > b && f.push({ diff: p2, start: m, end: D });
                        break;
                      } else
                        t++;
                if (this._axes[l2].scaleBreaks.customBreaks) {
                  for (t = 0; t < this._axes[l2].scaleBreaks.customBreaks.length; t++)
                    for (b = 0; b < f.length; b++)
                      if (this._axes[l2].scaleBreaks.customBreaks[t].startValue <= f[b].start && f[b].start <= this._axes[l2].scaleBreaks.customBreaks[t].endValue || this._axes[l2].scaleBreaks.customBreaks[t].startValue <= f[b].start && f[b].start <= this._axes[l2].scaleBreaks.customBreaks[t].endValue || f[b].start <= this._axes[l2].scaleBreaks.customBreaks[t].startValue && this._axes[l2].scaleBreaks.customBreaks[t].startValue <= f[b].end || f[b].start <= this._axes[l2].scaleBreaks.customBreaks[t].endValue && this._axes[l2].scaleBreaks.customBreaks[t].endValue <= f[b].end)
                        f.splice(b, 1), b--;
                }
                f.sort(function(a3, b2) {
                  return b2.diff - a3.diff;
                });
                for (t = 0; t < Math.min(f.length, this._axes[l2].scaleBreaks.maxNumberOfAutoBreaks); t++)
                  b = a2(f[t].start, f[t].end, this._axes[l2].logarithmic ? this._axes[l2].dataInfo.max / this._axes[l2].dataInfo.min : this._axes[l2].dataInfo.max - this._axes[l2].dataInfo.min, this._axes[l2].logarithmic), this._axes[l2].scaleBreaks.autoBreaks.push(new da2(this, "autoBreaks", b, t, ++this._eventManager.lastObjectId, this._axes[l2].scaleBreaks)), this._axes[l2].scaleBreaks._appliedBreaks.push(this._axes[l2].scaleBreaks.autoBreaks[this._axes[l2].scaleBreaks.autoBreaks.length - 1]);
                this._axes[l2].scaleBreaks._appliedBreaks.sort(function(a3, b2) {
                  return a3.startValue - b2.startValue;
                });
              }
          }
        };
        n.prototype.renderCrosshairs = function(a2) {
          for (var d2 = 0; d2 < this.axisX.length; d2++)
            this.axisX[d2] != a2 && (this.axisX[d2].crosshair && this.axisX[d2].crosshair.enabled && !this.axisX[d2].crosshair._hidden) && this.axisX[d2].showCrosshair(this.axisX[d2].crosshair._updatedValue);
          for (d2 = 0; d2 < this.axisX2.length; d2++)
            this.axisX2[d2] != a2 && (this.axisX2[d2].crosshair && this.axisX2[d2].crosshair.enabled && !this.axisX2[d2].crosshair._hidden) && this.axisX2[d2].showCrosshair(this.axisX2[d2].crosshair._updatedValue);
          for (d2 = 0; d2 < this.axisY.length; d2++)
            this.axisY[d2] != a2 && (this.axisY[d2].crosshair && this.axisY[d2].crosshair.enabled && !this.axisY[d2].crosshair._hidden) && this.axisY[d2].showCrosshair(this.axisY[d2].crosshair._updatedValue);
          for (d2 = 0; d2 < this.axisY2.length; d2++)
            this.axisY2[d2] != a2 && (this.axisY2[d2].crosshair && this.axisY2[d2].crosshair.enabled && !this.axisY2[d2].crosshair._hidden) && this.axisY2[d2].showCrosshair(this.axisY2[d2].crosshair._updatedValue);
        };
        n.prototype.getDataPointAtXY = function(a2, d2, c2) {
          c2 = c2 || false;
          for (var b = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {
            var f = null;
            (f = this._dataInRenderedOrder[e].getDataPointAtXY(a2, d2, c2)) && b.push(f);
          }
          a2 = null;
          d2 = false;
          for (c2 = 0; c2 < b.length; c2++)
            if ("line" === b[c2].dataSeries.type || "stepLine" === b[c2].dataSeries.type || "area" === b[c2].dataSeries.type || "stepArea" === b[c2].dataSeries.type) {
              if (e = la("markerSize", b[c2].dataPoint, b[c2].dataSeries) || 8, b[c2].distance <= e / 2) {
                d2 = true;
                break;
              }
            }
          for (c2 = 0; c2 < b.length; c2++)
            d2 && "line" !== b[c2].dataSeries.type && "stepLine" !== b[c2].dataSeries.type && "area" !== b[c2].dataSeries.type && "stepArea" !== b[c2].dataSeries.type || (a2 ? b[c2].distance <= a2.distance && (a2 = b[c2]) : a2 = b[c2]);
          return a2;
        };
        n.prototype.getObjectAtXY = function(a2, d2, c2) {
          var b = null;
          if (c2 = this.getDataPointAtXY(a2, d2, c2 || false))
            b = c2.dataSeries.dataPointIds[c2.dataPointIndex];
          else if (w)
            b = $a(a2, d2, this._eventManager.ghostCtx);
          else
            for (c2 = 0; c2 < this.legend.items.length; c2++) {
              var e = this.legend.items[c2];
              a2 >= e.x1 && (a2 <= e.x2 && d2 >= e.y1 && d2 <= e.y2) && (b = e.id);
            }
          return b;
        };
        n.prototype.getAutoFontSize = mb;
        n.prototype.resetOverlayedCanvas = function() {
          this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
        };
        n.prototype.clearCanvas = lb;
        n.prototype.attachEvent = function(a2) {
          this._events.push(a2);
        };
        n.prototype._touchEventHandler = function(a2) {
          if (a2.changedTouches && this.interactivityEnabled) {
            var d2 = [], c2 = a2.changedTouches, b = c2 ? c2[0] : a2, e = null;
            switch (a2.type) {
              case "touchstart":
              case "MSPointerDown":
                d2 = ["mousemove", "mousedown"];
                this._lastTouchData = Pa(b);
                this._lastTouchData.time = new Date();
                break;
              case "touchmove":
              case "MSPointerMove":
                d2 = ["mousemove"];
                break;
              case "touchend":
              case "MSPointerUp":
                var f = this._lastTouchData && this._lastTouchData.time ? new Date() - this._lastTouchData.time : 0, d2 = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > f ? ["mouseup", "click"] : ["mouseup"];
                break;
              default:
                return;
            }
            if (!(c2 && 1 < c2.length)) {
              e = Pa(b);
              e.time = new Date();
              try {
                var l2 = e.y - this._lastTouchData.y, f = e.time - this._lastTouchData.time;
                if (1 < Math.abs(l2) && this._lastTouchData.scroll || 5 < Math.abs(l2) && 250 > f)
                  this._lastTouchData.scroll = true;
              } catch (t) {
              }
              this._lastTouchEventType = a2.type;
              if (this._lastTouchData.scroll && this.zoomEnabled)
                this.isDrag && this.resetOverlayedCanvas(), this.isDrag = false;
              else
                for (c2 = 0; c2 < d2.length; c2++)
                  if (e = d2[c2], l2 = document.createEvent("MouseEvent"), l2.initMouseEvent(e, true, true, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, false, false, false, false, 0, null), b.target.dispatchEvent(l2), !r(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < f || "click" === e)
                    a2.preventManipulation && a2.preventManipulation(), a2.preventDefault && a2.cancelable && a2.preventDefault();
            }
          }
        };
        n.prototype._dispatchRangeEvent = function(a2, d2) {
          var c2 = { chart: this };
          c2.type = a2;
          c2.trigger = d2;
          var b = [];
          this.axisX && 0 < this.axisX.length && b.push("axisX");
          this.axisX2 && 0 < this.axisX2.length && b.push("axisX2");
          this.axisY && 0 < this.axisY.length && b.push("axisY");
          this.axisY2 && 0 < this.axisY2.length && b.push("axisY2");
          for (var e = 0; e < b.length; e++)
            if (r(c2[b[e]]) && (c2[b[e]] = []), "axisY" === b[e])
              for (var f = 0; f < this.axisY.length; f++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum });
            else if ("axisY2" === b[e])
              for (f = 0; f < this.axisY2.length; f++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum });
            else if ("axisX" === b[e])
              for (f = 0; f < this.axisX.length; f++)
                c2[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum });
            else if ("axisX2" === b[e])
              for (f = 0; f < this.axisX2.length; f++)
                c2[b[e]].push({
                  viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum,
                  viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum
                });
          this.dispatchEvent(a2, c2, this);
        };
        n.prototype._mouseEventHandler = function(a2) {
          "undefined" === typeof a2.target && a2.srcElement && (a2.target = a2.srcElement);
          var d2 = Pa(a2), c2 = a2.type, b, e;
          a2.which ? e = 3 == a2.which : a2.button && (e = 2 == a2.button);
          n.capturedEventParam && (b = n.capturedEventParam, "mouseup" === c2 && (n.capturedEventParam = null, b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener(
            "mouseup",
            b.chart._mouseEventHandler,
            false
          )), b.hasOwnProperty(c2) && ("mouseup" !== c2 || b.chart.overlaidCanvas.releaseCapture ? a2.target !== b.chart.overlaidCanvas && w || b[c2].call(b.context, d2.x, d2.y) : a2.target !== b.chart.overlaidCanvas && (b.chart.isDrag = false)));
          if (this.interactivityEnabled) {
            if (this._ignoreNextEvent)
              this._ignoreNextEvent = false;
            else if (a2.preventManipulation && a2.preventManipulation(), a2.preventDefault && a2.preventDefault(), Ia && window.console && (window.console.log(c2 + " --> x: " + d2.x + "; y:" + d2.y), e && window.console.log(a2.which), "mouseup" === c2 && window.console.log("mouseup")), !e) {
              if (!n.capturedEventParam && this._events) {
                for (var f = 0; f < this._events.length; f++)
                  if (this._events[f].hasOwnProperty(c2))
                    if (b = this._events[f], e = b.bounds, d2.x >= e.x1 && d2.x <= e.x2 && d2.y >= e.y1 && d2.y <= e.y2) {
                      b[c2].call(b.context, d2.x, d2.y);
                      "mousedown" === c2 && true === b.capture ? (n.capturedEventParam = b, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, false)) : "mouseup" === c2 && (b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, false));
                      break;
                    } else
                      b = null;
                a2.target.style.cursor = b && b.cursor ? b.cursor : this._defaultCursor;
              }
              c2 = this.plotArea;
              if (d2.x < c2.x1 || d2.x > c2.x2 || d2.y < c2.y1 || d2.y > c2.y2) {
                this.toolTip && this.toolTip.enabled ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip)) : this.resetOverlayedCanvas();
                for (f = 0; f < this.axisX.length; f++)
                  this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && (this.axisX[f].crosshair.hide(), this.axisX[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[f].options }, this.axisX[f].crosshair));
                for (f = 0; f < this.axisX2.length; f++)
                  this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && (this.axisX2[f].crosshair.hide(), this.axisX2[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[f].options }, this.axisX2[f].crosshair));
                for (f = 0; f < this.axisY.length; f++)
                  this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && (this.axisY[f].crosshair.hide(), this.axisY[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[f].options }, this.axisY[f].crosshair));
                for (f = 0; f < this.axisY2.length; f++)
                  this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && (this.axisY2[f].crosshair.hide(), this.axisY2[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[f].options }, this.axisY2[f].crosshair));
              }
              this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a2);
            }
          }
        };
        n.prototype._plotAreaMouseDown = function(a2, d2) {
          this.isDrag = true;
          this.dragStartPoint = { x: a2, y: d2 };
        };
        n.prototype._plotAreaMouseUp = function(a2, d2) {
          if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
            var c2 = d2 - this.dragStartPoint.y, b = a2 - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), l2 = false;
            this.resetOverlayedCanvas();
            if ("xySwapped" === this.plotInfo.axisPlacement)
              var t = f, f = e, e = t;
            if (this.panEnabled || this.zoomEnabled) {
              if (this.panEnabled)
                for (e = f = 0; e < this._axes.length; e++)
                  c2 = this._axes[e], c2.logarithmic ? c2.viewportMinimum < c2.minimum ? (f = c2.minimum / c2.viewportMinimum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum * f, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum * f, l2 = true) : c2.viewportMaximum > c2.maximum && (f = c2.viewportMaximum / c2.maximum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum / f, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum / f, l2 = true) : c2.viewportMinimum < c2.minimum ? (f = c2.minimum - c2.viewportMinimum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum + f, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum + f, l2 = true) : c2.viewportMaximum > c2.maximum && (f = c2.viewportMaximum - c2.maximum, c2.sessionVariables.newViewportMinimum = c2.viewportMinimum - f, c2.sessionVariables.newViewportMaximum = c2.viewportMaximum - f, l2 = true);
              else if ((!e || 2 < Math.abs(b)) && (!f || 2 < Math.abs(c2)) && this.zoomEnabled) {
                if (!this.dragStartPoint)
                  return;
                c2 = e ? this.dragStartPoint.x : this.plotArea.x1;
                b = f ? this.dragStartPoint.y : this.plotArea.y1;
                e = e ? a2 : this.plotArea.x2;
                f = f ? d2 : this.plotArea.y2;
                2 < Math.abs(c2 - e) && 2 < Math.abs(b - f) && this._zoomPanToSelectedRegion(
                  c2,
                  b,
                  e,
                  f
                ) && (l2 = true);
              }
              l2 && (this._ignoreNextEvent = true, this._dispatchRangeEvent("rangeChanging", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: this.stockChart.sessionVariables._axisXMin, maximum: this.stockChart.sessionVariables._axisXMax }), this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent(
                "rangeChanging",
                this.stockChart._rangeEventParameter,
                this.stockChart
              )), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter.type = "rangeChanged", this.stockChart.dispatchEvent("rangeChanged", this.stockChart._rangeEventParameter, this.stockChart)), l2 && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Ma(this._zoomButton, this._resetButton), pa(this, this._zoomButton, "pan"), pa(
                this,
                this._resetButton,
                "reset"
              )));
            }
          }
          this.isDrag = false;
          if ("none" !== this.plotInfo.axisPlacement) {
            this.resetOverlayedCanvas();
            if (this.axisX && 0 < this.axisX.length)
              for (l2 = 0; l2 < this.axisX.length; l2++)
                this.axisX[l2].crosshair && this.axisX[l2].crosshair.enabled && this.axisX[l2].renderCrosshair(a2, d2);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (l2 = 0; l2 < this.axisX2.length; l2++)
                this.axisX2[l2].crosshair && this.axisX2[l2].crosshair.enabled && this.axisX2[l2].renderCrosshair(a2, d2);
            if (this.axisY && 0 < this.axisY.length)
              for (l2 = 0; l2 < this.axisY.length; l2++)
                this.axisY[l2].crosshair && this.axisY[l2].crosshair.enabled && this.axisY[l2].renderCrosshair(a2, d2);
            if (this.axisY2 && 0 < this.axisY2.length)
              for (l2 = 0; l2 < this.axisY2.length; l2++)
                this.axisY2[l2].crosshair && this.axisY2[l2].crosshair.enabled && this.axisY2[l2].renderCrosshair(a2, d2);
            if (this.axisX && 0 < this.axisX.length)
              for (l2 = 0; l2 < this.axisX.length; l2++)
                this.axisX[l2].crosshair && this.axisX[l2].crosshair.enabled && this.axisX[l2].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length)
              for (l2 = 0; l2 < this.axisX2.length; l2++)
                this.axisX2[l2].crosshair && this.axisX2[l2].crosshair.enabled && this.axisX2[l2].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length)
              for (l2 = 0; l2 < this.axisY.length; l2++)
                this.axisY[l2].crosshair && this.axisY[l2].crosshair.enabled && this.axisY[l2].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length)
              for (l2 = 0; l2 < this.axisY2.length; l2++)
                this.axisY2[l2].crosshair && this.axisY2[l2].crosshair.enabled && this.axisY2[l2].crosshair.renderLabel();
          }
        };
        n.prototype._plotAreaMouseMove = function(a2, d2) {
          if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
            var c2 = 0, b = 0, e = c2 = null, e = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), l2 = this;
            "xySwapped" === this.plotInfo.axisPlacement && (c2 = f, f = e, e = c2);
            c2 = this.dragStartPoint.x - a2;
            b = this.dragStartPoint.y - d2;
            if (2 < Math.abs(c2) && 8 > Math.abs(c2) && (this.panEnabled || this.zoomEnabled)) {
              this.toolTip.hide();
              this.toolTip && this.toolTip.enabled && this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip);
              for (var t = 0; t < this.axisX.length; t++)
                this.axisX[t].crosshair && this.axisX[t].crosshair.enabled && (this.axisX[t].crosshair.hide(), this.axisX[t].crosshair.dispatchEvent(
                  "hidden",
                  { chart: this, axis: this.axisX[t].options },
                  this.axisX[t].crosshair
                ));
              for (t = 0; t < this.axisX2.length; t++)
                this.axisX2[t].crosshair && this.axisX2[t].crosshair.enabled && (this.axisX2[t].crosshair.hide(), this.axisX2[t].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[t].options }, this.axisX2[t].crosshair));
              for (t = 0; t < this.axisY.length; t++)
                this.axisY[t].crosshair && this.axisY[t].crosshair.enabled && (this.axisY[t].crosshair.hide(), this.axisY[t].crosshair.dispatchEvent(
                  "hidden",
                  { chart: this, axis: this.axisY[t].options },
                  this.axisY[t].crosshair
                ));
              for (t = 0; t < this.axisY2.length; t++)
                this.axisY2[t].crosshair && this.axisY2[t].crosshair.enabled && (this.axisY2[t].crosshair.hide(), this.axisY2[t].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY2[t].options }, this.axisY2[t].crosshair));
            } else
              this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a2, d2);
            if ((!e || 2 < Math.abs(c2) || !f || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) {
              if (this.panEnabled)
                e = { x1: e ? this.plotArea.x1 + c2 : this.plotArea.x1, y1: f ? this.plotArea.y1 + b : this.plotArea.y1, x2: e ? this.plotArea.x2 + c2 : this.plotArea.x2, y2: f ? this.plotArea.y2 + b : this.plotArea.y2 }, clearTimeout(l2._panTimerId), l2._panTimerId = setTimeout(function(b2, c3, e2, f2) {
                  return function() {
                    l2._zoomPanToSelectedRegion(b2, c3, e2, f2, true) && (l2._dispatchRangeEvent("rangeChanging", "pan"), l2.stockChart && (l2.stockChart.navigator && l2.stockChart.navigator.enabled) && (l2.stockChart._rangeEventParameter.type = "rangeChanging", l2.stockChart.dispatchEvent("rangeChanging", l2.stockChart._rangeEventParameter, l2.stockChart)), l2.render(), l2._dispatchRangeEvent("rangeChanged", "pan"), l2.stockChart && (l2.stockChart.navigator && l2.stockChart.navigator.enabled) && (l2.stockChart._rangeEventParameter.type = "rangeChanged", l2.stockChart.dispatchEvent("rangeChanged", l2.stockChart._rangeEventParameter, l2.stockChart)), l2.dragStartPoint.x = a2, l2.dragStartPoint.y = d2);
                  };
                }(e.x1, e.y1, e.x2, e.y2), 0);
              else if (this.zoomEnabled) {
                this.resetOverlayedCanvas();
                c2 = this.overlaidCanvasCtx.globalAlpha;
                this.overlaidCanvasCtx.fillStyle = "#A89896";
                var b = e ? this.dragStartPoint.x : this.plotArea.x1, t = f ? this.dragStartPoint.y : this.plotArea.y1, D = e ? a2 - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, k = f ? d2 - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                this.validateRegion(b, t, e ? a2 : this.plotArea.x2 - this.plotArea.x1, f ? d2 : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5");
                this.overlaidCanvasCtx.globalAlpha = 0.7;
                this.overlaidCanvasCtx.fillRect(b, t, D, k);
                this.overlaidCanvasCtx.globalAlpha = c2;
              }
            }
          } else if (this.toolTip.mouseMoveHandler(
            a2,
            d2
          ), "none" !== this.plotInfo.axisPlacement) {
            if (this.axisX && 0 < this.axisX.length)
              for (e = 0; e < this.axisX.length; e++)
                this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a2, d2);
            if (this.axisX2 && 0 < this.axisX2.length)
              for (e = 0; e < this.axisX2.length; e++)
                this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a2, d2);
            if (this.axisY && 0 < this.axisY.length)
              for (e = 0; e < this.axisY.length; e++)
                this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(
                  a2,
                  d2
                );
            if (this.axisY2 && 0 < this.axisY2.length)
              for (e = 0; e < this.axisY2.length; e++)
                this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a2, d2);
            if (this.axisX && 0 < this.axisX.length)
              for (e = 0; e < this.axisX.length; e++)
                this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].crosshair.renderLabel();
            if (this.axisX2 && 0 < this.axisX2.length)
              for (e = 0; e < this.axisX2.length; e++)
                this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].crosshair.renderLabel();
            if (this.axisY && 0 < this.axisY.length)
              for (e = 0; e < this.axisY.length; e++)
                this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].crosshair.renderLabel();
            if (this.axisY2 && 0 < this.axisY2.length)
              for (e = 0; e < this.axisY2.length; e++)
                this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].crosshair.renderLabel();
          }
        };
        n.prototype._zoomPanToSelectedRegion = function(a2, d2, c2, b, e) {
          a2 = this.validateRegion(a2, d2, c2, b, e);
          d2 = a2.axesWithValidRange;
          c2 = a2.axesRanges;
          if (a2.isValid)
            for (b = 0; b < d2.length; b++)
              e = c2[b], d2[b].setViewPortRange(e.val1, e.val2), this.syncCharts && "y" != this.zoomType && this.syncCharts(e.val1, e.val2), this.stockChart && (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: e.val1, maximum: e.val2 });
          return a2.isValid;
        };
        n.prototype.validateRegion = function(a2, d2, c2, b, e) {
          e = e || false;
          for (var f = 0 <= this.zoomType.indexOf("x"), l2 = 0 <= this.zoomType.indexOf("y"), t = false, D = [], k = [], m = [], p2 = 0; p2 < this._axes.length; p2++)
            ("axisX" === this._axes[p2].type && f || "axisY" === this._axes[p2].type && l2) && k.push(this._axes[p2]);
          for (l2 = 0; l2 < k.length; l2++) {
            var p2 = k[l2], f = false, q = p2.convertPixelToValue({ x: a2, y: d2 }), g = p2.convertPixelToValue({ x: c2, y: b });
            if (q > g)
              var s = g, g = q, q = s;
            if (p2.scaleBreaks)
              for (s = 0; !f && s < p2.scaleBreaks._appliedBreaks.length; s++)
                f = p2.scaleBreaks._appliedBreaks[s].startValue <= q && p2.scaleBreaks._appliedBreaks[s].endValue >= g;
            if (isFinite(p2.dataInfo.minDiff)) {
              if (s = p2.getApparentDifference(q, g, null, true), !(f || !(this.panEnabled && p2.scaleBreaks && p2.scaleBreaks._appliedBreaks.length) && (p2.logarithmic && s < Math.pow(p2.dataInfo.minDiff, 3) || !p2.logarithmic && s < 3 * Math.abs(p2.dataInfo.minDiff)) || q < p2.minimum || g > p2.maximum))
                D.push(p2), m.push({ val1: q, val2: g }), t = true;
              else if (!e) {
                t = false;
                break;
              }
            }
          }
          return { isValid: t, axesWithValidRange: D, axesRanges: m };
        };
        n.prototype.preparePlotArea = function() {
          var a2 = this.plotArea;
          !w && (0 < a2.x1 || 0 < a2.y1) && a2.ctx.translate(a2.x1, a2.y1);
          if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
            var d2 = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
            if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
              var c2 = this.axisY[0];
              a2.x1 = d2.x1 < d2.x2 ? d2.x1 : c2.lineCoordinates.x1;
              a2.y1 = d2.y1 < c2.lineCoordinates.y1 ? d2.y1 : c2.lineCoordinates.y1;
              a2.x2 = d2.x2 > c2.lineCoordinates.x2 ? d2.x2 : c2.lineCoordinates.x2;
              a2.y2 = d2.y2 > d2.y1 ? d2.y2 : c2.lineCoordinates.y2;
              a2.width = a2.x2 - a2.x1;
              a2.height = a2.y2 - a2.y1;
            }
            this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c2 = this.axisY2[0], a2.x1 = d2.x1 < d2.x2 ? d2.x1 : c2.lineCoordinates.x1, a2.y1 = d2.y1 < c2.lineCoordinates.y1 ? d2.y1 : c2.lineCoordinates.y1, a2.x2 = d2.x2 > c2.lineCoordinates.x2 ? d2.x2 : c2.lineCoordinates.x2, a2.y2 = d2.y2 > d2.y1 ? d2.y2 : c2.lineCoordinates.y2, a2.width = a2.x2 - a2.x1, a2.height = a2.y2 - a2.y1);
          } else
            d2 = this.layoutManager.getFreeSpace(), a2.x1 = d2.x1, a2.x2 = d2.x2, a2.y1 = d2.y1, a2.y2 = d2.y2, a2.width = d2.width, a2.height = d2.height;
          w || (a2.canvas.width = a2.width, a2.canvas.height = a2.height, a2.canvas.style.left = a2.x1 + "px", a2.canvas.style.top = a2.y1 + "px", (0 < a2.x1 || 0 < a2.y1) && a2.ctx.translate(-a2.x1, -a2.y1));
          a2.layoutManager = new Fa(a2.x1, a2.y1, a2.x2, a2.y2, 2);
        };
        n.prototype.renderIndexLabels = function(a2) {
          var d2 = a2 || this.plotArea.ctx, c2 = this.plotArea, b = 0, e = 0, f = 0, l2 = f = e = 0, t = 0, D = b = 0, k = 0;
          for (a2 = 0; a2 < this._indexLabels.length; a2++) {
            var m = this._indexLabels[a2], p2 = m.chartType.toLowerCase(), q, g, l2 = la("indexLabelFontColor", m.dataPoint, m.dataSeries), s = la("indexLabelFontSize", m.dataPoint, m.dataSeries), t = la("indexLabelFontFamily", m.dataPoint, m.dataSeries), D = la("indexLabelFontStyle", m.dataPoint, m.dataSeries), k = la("indexLabelFontWeight", m.dataPoint, m.dataSeries), h2 = la("indexLabelBackgroundColor", m.dataPoint, m.dataSeries);
            q = la("indexLabelMaxWidth", m.dataPoint, m.dataSeries);
            g = la("indexLabelWrap", m.dataPoint, m.dataSeries);
            var n2 = la("indexLabelLineDashType", m.dataPoint, m.dataSeries), u2 = la("indexLabelLineColor", m.dataPoint, m.dataSeries), y = r(m.dataPoint.indexLabelLineThickness) ? r(m.dataSeries.options.indexLabelLineThickness) ? 0 : m.dataSeries.options.indexLabelLineThickness : m.dataPoint.indexLabelLineThickness, b = 0 < y ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, x = { percent: null, total: null }, z = null;
            if (0 <= m.dataSeries.type.indexOf("stacked") || "pie" === m.dataSeries.type || "doughnut" === m.dataSeries.type)
              x = this.getPercentAndTotal(m.dataSeries, m.dataPoint);
            if (m.dataSeries.indexLabelFormatter || m.dataPoint.indexLabelFormatter)
              z = { chart: this, dataSeries: m.dataSeries, dataPoint: m.dataPoint, index: m.indexKeyword, total: x.total, percent: x.percent };
            var G = m.dataPoint.indexLabelFormatter ? m.dataPoint.indexLabelFormatter(z) : m.dataPoint.indexLabel ? this.replaceKeywordsWithValue(m.dataPoint.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : m.dataSeries.indexLabelFormatter ? m.dataSeries.indexLabelFormatter(z) : m.dataSeries.indexLabel ? this.replaceKeywordsWithValue(m.dataSeries.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : null;
            if (null !== G && "" !== G) {
              var x = la("indexLabelPlacement", m.dataPoint, m.dataSeries), z = la("indexLabelOrientation", m.dataPoint, m.dataSeries), C2 = la("indexLabelTextAlign", m.dataPoint, m.dataSeries), v3 = m.direction, e = m.dataSeries.axisX, f = m.dataSeries.axisY, A2 = false, h2 = new ka(d2, { x: 0, y: 0, maxWidth: q ? q : 0.5 * this.width, maxHeight: g ? 5 * s : 1.5 * s, angle: "horizontal" === z ? 0 : -90, text: G, padding: 0, backgroundColor: h2, textAlign: C2, fontSize: s, fontFamily: t, fontWeight: k, fontColor: l2, fontStyle: D, textBaseline: "middle" });
              h2.measureText();
              m.dataSeries.indexLabelMaxWidth = h2.maxWidth;
              if ("stackedarea100" === p2) {
                if (m.point.x < c2.x1 || m.point.x > c2.x2 || m.point.y < c2.y1 - 1 || m.point.y > c2.y2 + 1)
                  continue;
              } else if ("rangearea" === p2 || "rangesplinearea" === p2) {
                if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < f.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > f.viewportMaximum)
                  continue;
              } else if (0 <= p2.indexOf("line") || 0 <= p2.indexOf("area") || 0 <= p2.indexOf("bubble") || 0 <= p2.indexOf("scatter")) {
                if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum || m.dataPoint.y < f.viewportMinimum || m.dataPoint.y > f.viewportMaximum)
                  continue;
              } else if (0 <= p2.indexOf("column") || "waterfall" === p2 || "error" === p2 && !m.axisSwapped) {
                if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum || m.bounds.y1 > c2.y2 || m.bounds.y2 < c2.y1)
                  continue;
              } else if (0 <= p2.indexOf("bar") || "error" === p2) {
                if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum || m.bounds.x1 > c2.x2 || m.bounds.x2 < c2.x1)
                  continue;
              } else if ("candlestick" === p2 || "ohlc" === p2) {
                if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < f.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > f.viewportMaximum)
                  continue;
              } else if (m.dataPoint.x < e.viewportMinimum || m.dataPoint.x > e.viewportMaximum)
                continue;
              l2 = t = 2;
              "horizontal" === z ? (D = h2.width, k = h2.height) : (k = h2.width, D = h2.height);
              if ("normal" === this.plotInfo.axisPlacement) {
                if (0 <= p2.indexOf("line") || 0 <= p2.indexOf("area"))
                  x = "auto", t = 4;
                else if (0 <= p2.indexOf("stacked"))
                  "auto" === x && (x = "inside");
                else if ("bubble" === p2 || "scatter" === p2)
                  x = "inside";
                q = m.point.x - ("horizontal" === z ? D / 2 : D / 2 - s / 2);
                "inside" !== x ? (e = c2.y1, f = c2.y2, 0 < v3 ? (g = m.point.y + ("horizontal" === z ? s / 2 : 0) - k - t - b, g < e && (g = "auto" === x ? Math.max(m.point.y, e) + s / 2 + t : e + s / 2 + t, A2 = g + k > m.point.y)) : (g = m.point.y + s / 2 + t + b, g > f - k && (g = "auto" === x ? Math.min(m.point.y, f) + s / 2 - k - t : f + s / 2 - k, A2 = g < m.point.y))) : (e = Math.max(
                  m.bounds.y1,
                  c2.y1
                ), f = Math.min(m.bounds.y2, c2.y2 - k + s / 2), b = 0 <= p2.indexOf("range") || "error" === p2 ? 0 < v3 ? Math.max(m.bounds.y1, c2.y1) + s / 2 + t : Math.min(m.bounds.y2, c2.y2) + s / 2 - k + t : (Math.max(m.bounds.y1, c2.y1) + Math.min(m.bounds.y2, c2.y2)) / 2 - k / 2 + s / 2 + ("horizontal" === z ? t : 0), 0 < v3 ? (g = Math.max(m.point.y, b), g < e && ("bubble" === p2 || "scatter" === p2) && (g = Math.max(m.point.y - k - t, c2.y1 + t))) : (g = Math.min(m.point.y, b), g > f - k - t && ("bubble" === p2 || "scatter" === p2) && (g = Math.min(m.point.y + t, c2.y2 - k - t))), g = Math.min(g, f));
              } else
                0 <= p2.indexOf("line") || 0 <= p2.indexOf("area") || 0 <= p2.indexOf("scatter") ? (x = "auto", l2 = 4) : 0 <= p2.indexOf("stacked") ? "auto" === x && (x = "inside") : "bubble" === p2 && (x = "inside"), g = m.point.y + s / 2 - k / 2 + t, "inside" !== x ? (e = c2.x1, f = c2.x2, 0 > v3 ? (q = m.point.x - ("horizontal" === z ? D : D - s / 2) - l2 - b, q < e && (q = "auto" === x ? Math.max(m.point.x, e) + l2 : e + l2, A2 = q + D > m.point.x)) : (q = m.point.x + ("horizontal" === z ? 0 : s / 2) + l2 + b, q > f - D - l2 - b && (q = "auto" === x ? Math.min(m.point.x, f) - ("horizontal" === z ? D : D / 2) - l2 : f - D - l2, A2 = q < m.point.x))) : (e = Math.max(m.bounds.x1, c2.x1), Math.min(m.bounds.x2, c2.x2), b = 0 <= p2.indexOf("range") || "error" === p2 ? 0 > v3 ? Math.max(m.bounds.x1, c2.x1) + s / 2 + l2 : Math.min(m.bounds.x2, c2.x2) - D / 2 - l2 + ("horizontal" === z ? 0 : s / 2) : (Math.max(m.bounds.x1, c2.x1) + Math.min(m.bounds.x2, c2.x2)) / 2 + ("horizontal" === z ? 0 : s / 2), q = 0 > v3 ? Math.max(m.point.x, b) - ("horizontal" === z ? D / 2 : 0) : Math.min(m.point.x, b) - D / 2, q = Math.max(q, e));
              "vertical" === z && (g += k - s / 2);
              h2.x = q;
              h2.y = g;
              h2.render(true);
              y && ("inside" !== x && (0 > p2.indexOf("bar") && ("error" !== p2 || !m.axisSwapped) && m.point.x > c2.x1 && m.point.x < c2.x2 || !A2) && (0 > p2.indexOf("column") && ("error" !== p2 || m.axisSwapped) && m.point.y > c2.y1 && m.point.y < c2.y2 || !A2)) && (d2.lineWidth = y, d2.strokeStyle = u2 ? u2 : "gray", d2.setLineDash && d2.setLineDash(J(n2, y)), d2.beginPath(), d2.moveTo(m.point.x, m.point.y), 0 <= p2.indexOf("bar") || "error" === p2 && m.axisSwapped ? d2.lineTo(q + (0 < m.direction ? -l2 : D + l2) + ("vertical" === z ? -s / 2 : 0), g + ("vertical" === z ? -k / 2 : k / 2 - s / 2) - t) : 0 <= p2.indexOf("column") || "error" === p2 && !m.axisSwapped ? d2.lineTo(q + D / 2 - ("horizontal" === z ? 0 : s / 2), g + ("vertical" === z ? (g - k < m.point.y ? 0 : -k) + t : (g - s / 2 < m.point.y ? k : 0) - s / 2)) : d2.lineTo(q + D / 2 - ("horizontal" === z ? 0 : s / 2), g + ("vertical" === z ? g - k < m.point.y ? 0 : -k : (g - s / 2 < m.point.y ? k : 0) - s / 2)), d2.stroke());
            }
          }
          d2 = { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7 };
          for (a2 = 0; a2 < this._indexLabels.length; a2++)
            m = this._indexLabels[a2], h2 = la("indexLabelBackgroundColor", m.dataPoint, m.dataSeries), m.dataSeries.indexLabelBackgroundColor = r(h2) ? w ? "transparent" : null : h2;
          return d2;
        };
        n.prototype.renderLine = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c2.save();
            var e = this.plotArea;
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            for (var f = [], l2, t = 0; t < a2.dataSeriesIndexes.length; t++) {
              var D = a2.dataSeriesIndexes[t], k = this.data[D];
              c2.lineWidth = k.lineThickness;
              var m = k.dataPoints, p2 = "solid";
              if (c2.setLineDash) {
                var q = J(k.nullDataLineDashType, k.lineThickness), p2 = k.lineDashType, g = J(p2, k.lineThickness);
                c2.setLineDash(g);
              }
              var s = k.id;
              this._eventManager.objectMap[s] = {
                objectType: "dataSeries",
                dataSeriesIndex: D
              };
              s = O(s);
              b.strokeStyle = s;
              b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var s = k._colorSet, h2 = s = k.lineColor = k.options.lineColor ? k.options.lineColor : s[0];
              c2.strokeStyle = s;
              var n2 = true, u2 = 0, r2, x;
              c2.beginPath();
              if (0 < m.length) {
                for (var z = false, u2 = 0; u2 < m.length; u2++)
                  if (r2 = m[u2].x.getTime ? m[u2].x.getTime() : m[u2].x, !(r2 < a2.axisX.dataInfo.viewPortMin || r2 > a2.axisX.dataInfo.viewPortMax && (!k.connectNullData || !z)))
                    if ("number" !== typeof m[u2].y)
                      0 < u2 && !(k.connectNullData || z || n2) && (c2.stroke(), w && b.stroke()), z = true;
                    else {
                      r2 = a2.axisX.convertValueToPixel(r2);
                      x = a2.axisY.convertValueToPixel(m[u2].y);
                      var G = k.dataPointIds[u2];
                      this._eventManager.objectMap[G] = { id: G, objectType: "dataPoint", dataSeriesIndex: D, dataPointIndex: u2, x1: r2, y1: x };
                      n2 || z ? (!n2 && k.connectNullData ? (c2.setLineDash && (k.options.nullDataLineDashType || p2 === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c2.stroke(), c2.beginPath(), c2.moveTo(l2.x, l2.y), p2 = k.nullDataLineDashType, c2.setLineDash(q)), c2.lineTo(r2, x), w && b.lineTo(r2, x)) : (c2.beginPath(), c2.moveTo(r2, x), w && (b.beginPath(), b.moveTo(r2, x))), z = n2 = false) : (c2.lineTo(r2, x), w && b.lineTo(r2, x), 0 == u2 % 500 && (c2.stroke(), c2.beginPath(), c2.moveTo(r2, x), w && (b.stroke(), b.beginPath(), b.moveTo(r2, x))));
                      l2 = { x: r2, y: x };
                      u2 < m.length - 1 && (h2 !== (m[u2].lineColor || s) || p2 !== (m[u2].lineDashType || k.lineDashType)) && (c2.stroke(), c2.beginPath(), c2.moveTo(r2, x), h2 = m[u2].lineColor || s, c2.strokeStyle = h2, c2.setLineDash && (m[u2].lineDashType ? (p2 = m[u2].lineDashType, c2.setLineDash(J(p2, k.lineThickness))) : (p2 = k.lineDashType, c2.setLineDash(g))));
                      if (0 !== m[u2].markerSize && (0 < m[u2].markerSize || 0 < k.markerSize)) {
                        var C2 = k.getMarkerProperties(u2, r2, x, c2);
                        f.push(C2);
                        G = O(G);
                        w && f.push({ x: r2, y: x, ctx: b, type: C2.type, size: C2.size, color: G, borderColor: G, borderThickness: C2.borderThickness });
                      }
                      (m[u2].indexLabel || k.indexLabel || m[u2].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: m[u2], dataSeries: k, point: { x: r2, y: x }, direction: 0 > m[u2].y === a2.axisY.reversed ? 1 : -1, color: s });
                    }
                c2.stroke();
                w && b.stroke();
              }
            }
            $.drawMarkers(f);
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath());
            c2.restore();
            c2.beginPath();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderStepLine = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx;
            c2.save();
            var e = this.plotArea;
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            for (var f = [], l2, t = 0; t < a2.dataSeriesIndexes.length; t++) {
              var D = a2.dataSeriesIndexes[t], k = this.data[D];
              c2.lineWidth = k.lineThickness;
              var m = k.dataPoints, p2 = "solid";
              if (c2.setLineDash) {
                var q = J(k.nullDataLineDashType, k.lineThickness), p2 = k.lineDashType, g = J(p2, k.lineThickness);
                c2.setLineDash(g);
              }
              var s = k.id;
              this._eventManager.objectMap[s] = { objectType: "dataSeries", dataSeriesIndex: D };
              s = O(s);
              b.strokeStyle = s;
              b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var s = k._colorSet, h2 = s = k.lineColor = k.options.lineColor ? k.options.lineColor : s[0];
              c2.strokeStyle = s;
              var n2 = true, u2 = 0, r2, x;
              c2.beginPath();
              if (0 < m.length) {
                for (var z = false, u2 = 0; u2 < m.length; u2++)
                  if (r2 = m[u2].getTime ? m[u2].x.getTime() : m[u2].x, !(r2 < a2.axisX.dataInfo.viewPortMin || r2 > a2.axisX.dataInfo.viewPortMax && (!k.connectNullData || !z)))
                    if ("number" !== typeof m[u2].y)
                      0 < u2 && !(k.connectNullData || z || n2) && (c2.stroke(), w && b.stroke()), z = true;
                    else {
                      var G = x;
                      r2 = a2.axisX.convertValueToPixel(r2);
                      x = a2.axisY.convertValueToPixel(m[u2].y);
                      var C2 = k.dataPointIds[u2];
                      this._eventManager.objectMap[C2] = { id: C2, objectType: "dataPoint", dataSeriesIndex: D, dataPointIndex: u2, x1: r2, y1: x };
                      n2 || z ? (!n2 && k.connectNullData ? (c2.setLineDash && (k.options.nullDataLineDashType || p2 === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c2.stroke(), c2.beginPath(), c2.moveTo(l2.x, l2.y), p2 = k.nullDataLineDashType, c2.setLineDash(q)), c2.lineTo(r2, G), c2.lineTo(r2, x), w && (b.lineTo(r2, G), b.lineTo(r2, x))) : (c2.beginPath(), c2.moveTo(r2, x), w && (b.beginPath(), b.moveTo(r2, x))), z = n2 = false) : (c2.lineTo(r2, G), w && b.lineTo(r2, G), c2.lineTo(r2, x), w && b.lineTo(r2, x), 0 == u2 % 500 && (c2.stroke(), c2.beginPath(), c2.moveTo(r2, x), w && (b.stroke(), b.beginPath(), b.moveTo(r2, x))));
                      l2 = { x: r2, y: x };
                      u2 < m.length - 1 && (h2 !== (m[u2].lineColor || s) || p2 !== (m[u2].lineDashType || k.lineDashType)) && (c2.stroke(), c2.beginPath(), c2.moveTo(r2, x), h2 = m[u2].lineColor || s, c2.strokeStyle = h2, c2.setLineDash && (m[u2].lineDashType ? (p2 = m[u2].lineDashType, c2.setLineDash(J(p2, k.lineThickness))) : (p2 = k.lineDashType, c2.setLineDash(g))));
                      0 !== m[u2].markerSize && (0 < m[u2].markerSize || 0 < k.markerSize) && (G = k.getMarkerProperties(u2, r2, x, c2), f.push(G), C2 = O(C2), w && f.push({ x: r2, y: x, ctx: b, type: G.type, size: G.size, color: C2, borderColor: C2, borderThickness: G.borderThickness }));
                      (m[u2].indexLabel || k.indexLabel || m[u2].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: m[u2], dataSeries: k, point: { x: r2, y: x }, direction: 0 > m[u2].y === a2.axisY.reversed ? 1 : -1, color: s });
                    }
                c2.stroke();
                w && b.stroke();
              }
            }
            $.drawMarkers(f);
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath());
            c2.restore();
            c2.beginPath();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderSpline = function(a2) {
          function d2(a3) {
            a3 = v2(a3, 2);
            if (0 < a3.length) {
              b.beginPath();
              w && e.beginPath();
              b.moveTo(a3[0].x, a3[0].y);
              a3[0].newStrokeStyle && (b.strokeStyle = a3[0].newStrokeStyle);
              a3[0].newLineDashArray && b.setLineDash(a3[0].newLineDashArray);
              w && e.moveTo(a3[0].x, a3[0].y);
              for (var c3 = 0; c3 < a3.length - 3; c3 += 3)
                if (b.bezierCurveTo(a3[c3 + 1].x, a3[c3 + 1].y, a3[c3 + 2].x, a3[c3 + 2].y, a3[c3 + 3].x, a3[c3 + 3].y), w && e.bezierCurveTo(a3[c3 + 1].x, a3[c3 + 1].y, a3[c3 + 2].x, a3[c3 + 2].y, a3[c3 + 3].x, a3[c3 + 3].y), 0 < c3 && 0 === c3 % 3e3 || a3[c3 + 3].newStrokeStyle || a3[c3 + 3].newLineDashArray)
                  b.stroke(), b.beginPath(), b.moveTo(a3[c3 + 3].x, a3[c3 + 3].y), a3[c3 + 3].newStrokeStyle && (b.strokeStyle = a3[c3 + 3].newStrokeStyle), a3[c3 + 3].newLineDashArray && b.setLineDash(a3[c3 + 3].newLineDashArray), w && (e.stroke(), e.beginPath(), e.moveTo(a3[c3 + 3].x, a3[c3 + 3].y));
              b.stroke();
              w && e.stroke();
            }
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx;
            b.save();
            var f = this.plotArea;
            b.beginPath();
            b.rect(f.x1, f.y1, f.width, f.height);
            b.clip();
            for (var l2 = [], t = 0; t < a2.dataSeriesIndexes.length; t++) {
              var D = a2.dataSeriesIndexes[t], k = this.data[D];
              b.lineWidth = k.lineThickness;
              var m = k.dataPoints, p2 = "solid";
              if (b.setLineDash) {
                var q = J(k.nullDataLineDashType, k.lineThickness), p2 = k.lineDashType, g = J(p2, k.lineThickness);
                b.setLineDash(g);
              }
              var s = k.id;
              this._eventManager.objectMap[s] = { objectType: "dataSeries", dataSeriesIndex: D };
              s = O(s);
              e.strokeStyle = s;
              e.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
              var s = k._colorSet, h2 = s = k.lineColor = k.options.lineColor ? k.options.lineColor : s[0];
              b.strokeStyle = s;
              var r2 = 0, u2, n2, x = [];
              b.beginPath();
              if (0 < m.length) {
                for (n2 = false, r2 = 0; r2 < m.length; r2++)
                  if (u2 = m[r2].getTime ? m[r2].x.getTime() : m[r2].x, !(u2 < a2.axisX.dataInfo.viewPortMin || u2 > a2.axisX.dataInfo.viewPortMax && (!k.connectNullData || !n2)))
                    if ("number" !== typeof m[r2].y)
                      0 < r2 && !n2 && (k.connectNullData ? b.setLineDash && (0 < x.length && (k.options.nullDataLineDashType || !m[r2 - 1].lineDashType)) && (x[x.length - 1].newLineDashArray = q, p2 = k.nullDataLineDashType) : (d2(x), x = [])), n2 = true;
                    else {
                      u2 = a2.axisX.convertValueToPixel(u2);
                      n2 = a2.axisY.convertValueToPixel(m[r2].y);
                      var z = k.dataPointIds[r2];
                      this._eventManager.objectMap[z] = { id: z, objectType: "dataPoint", dataSeriesIndex: D, dataPointIndex: r2, x1: u2, y1: n2 };
                      x[x.length] = { x: u2, y: n2 };
                      r2 < m.length - 1 && (h2 !== (m[r2].lineColor || s) || p2 !== (m[r2].lineDashType || k.lineDashType)) && (h2 = m[r2].lineColor || s, x[x.length - 1].newStrokeStyle = h2, b.setLineDash && (m[r2].lineDashType ? (p2 = m[r2].lineDashType, x[x.length - 1].newLineDashArray = J(p2, k.lineThickness)) : (p2 = k.lineDashType, x[x.length - 1].newLineDashArray = g)));
                      if (0 !== m[r2].markerSize && (0 < m[r2].markerSize || 0 < k.markerSize)) {
                        var G = k.getMarkerProperties(r2, u2, n2, b);
                        l2.push(G);
                        z = O(z);
                        w && l2.push({ x: u2, y: n2, ctx: e, type: G.type, size: G.size, color: z, borderColor: z, borderThickness: G.borderThickness });
                      }
                      (m[r2].indexLabel || k.indexLabel || m[r2].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: m[r2], dataSeries: k, point: { x: u2, y: n2 }, direction: 0 > m[r2].y === a2.axisY.reversed ? 1 : -1, color: s });
                      n2 = false;
                    }
              }
              d2(x);
            }
            $.drawMarkers(l2);
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && b.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f.x1, f.y1, f.width, f.height), e.beginPath());
            b.restore();
            b.beginPath();
            return {
              source: c2,
              dest: this.plotArea.ctx,
              animationCallback: N.xClipAnimation,
              easingFunction: N.easing.linear,
              animationBase: 0
            };
          }
        };
        n.prototype.renderColumn = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = 0, l2, t, D, k = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a2.plotType.totalDataSeries)) << 0, p2 = a2.axisX.dataInfo.minDiff;
            isFinite(p2) || (p2 = 0.3 * Math.abs(a2.axisX.range));
            p2 = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a2.axisX.logarithmic ? Math.log(p2) / Math.log(a2.axisX.range) : Math.abs(p2) / Math.abs(a2.axisX.range)) / a2.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > m && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, m));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && m < f) && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            p2 < f && (p2 = f);
            p2 > m && (p2 = m);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (m = 0; m < a2.dataSeriesIndexes.length; m++) {
              var q = a2.dataSeriesIndexes[m], g = this.data[q], s = g.dataPoints;
              if (0 < s.length) {
                for (var h2 = 5 < p2 && g.bevelEnabled ? true : false, f = 0; f < s.length; f++)
                  if (s[f].getTime ? D = s[f].x.getTime() : D = s[f].x, !(D < a2.axisX.dataInfo.viewPortMin || D > a2.axisX.dataInfo.viewPortMax) && "number" === typeof s[f].y) {
                    l2 = a2.axisX.convertValueToPixel(D);
                    t = a2.axisY.convertValueToPixel(s[f].y);
                    l2 = a2.axisX.reversed ? l2 + a2.plotType.totalDataSeries * p2 / 2 - (a2.previousDataSeriesCount + m) * p2 << 0 : l2 - a2.plotType.totalDataSeries * p2 / 2 + (a2.previousDataSeriesCount + m) * p2 << 0;
                    var r2 = a2.axisX.reversed ? l2 - p2 << 0 : l2 + p2 << 0, u2;
                    0 <= s[f].y ? u2 = k : (u2 = t, t = k);
                    t > u2 && (b = t, t = u2, u2 = b);
                    b = s[f].color ? s[f].color : g._colorSet[f % g._colorSet.length];
                    ba(c2, a2.axisX.reversed ? r2 : l2, t, a2.axisX.reversed ? l2 : r2, u2, b, 0, null, h2 && (a2.axisY.reversed ? 0 > s[f].y : 0 <= s[f].y), (a2.axisY.reversed ? 0 <= s[f].y : 0 > s[f].y) && h2, false, false, g.fillOpacity);
                    b = g.dataPointIds[f];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: f, x1: l2, y1: t, x2: r2, y2: u2 };
                    b = O(b);
                    w && ba(
                      this._eventManager.ghostCtx,
                      a2.axisX.reversed ? r2 : l2,
                      t,
                      a2.axisX.reversed ? l2 : r2,
                      u2,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (s[f].indexLabel || g.indexLabel || s[f].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: s[f], dataSeries: g, point: { x: l2 + (r2 - l2) / 2, y: 0 > s[f].y === a2.axisY.reversed ? t : u2 }, direction: 0 > s[f].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: l2, y1: Math.min(t, u2), x2: r2, y2: Math.max(t, u2) }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.yScaleAnimation, easingFunction: N.easing.easeOutQuart, animationBase: k < a2.axisY.bounds.y1 ? a2.axisY.bounds.y1 : k > a2.axisY.bounds.y2 ? a2.axisY.bounds.y2 : k };
          }
        };
        n.prototype.renderStackedColumn = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = [], l2 = [], t = [], D = [], k = 0, m, p2, q = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) / a2.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < k) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            s < k && (s = k);
            s > g && (s = g);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a2.dataSeriesIndexes.length; g++) {
              var h2 = a2.dataSeriesIndexes[g], r2 = this.data[h2], u2 = r2.dataPoints;
              if (0 < u2.length) {
                var n2 = 5 < s && r2.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (k = 0; k < u2.length; k++)
                  if (b = u2[k].x.getTime ? u2[k].x.getTime() : u2[k].x, !(b < a2.axisX.dataInfo.viewPortMin || b > a2.axisX.dataInfo.viewPortMax) && "number" === typeof u2[k].y) {
                    m = a2.axisX.convertValueToPixel(b);
                    m = m - a2.plotType.plotUnits.length * s / 2 + a2.index * s << 0;
                    var x = m + s << 0, z;
                    if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 < u2[k].y)
                      t[b] = u2[k].y + (t[b] ? t[b] : 0), 0 < t[b] && (p2 = a2.axisY.convertValueToPixel(t[b]), z = "undefined" !== typeof f[b] ? f[b] : q, f[b] = p2);
                    else if (a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 >= u2[k].y)
                      D[b] = u2[k].y + (D[b] ? D[b] : 0), z = a2.axisY.convertValueToPixel(D[b]), p2 = "undefined" !== typeof l2[b] ? l2[b] : q, l2[b] = z;
                    else if (p2 = a2.axisY.convertValueToPixel(u2[k].y), 0 <= u2[k].y) {
                      var G = "undefined" !== typeof f[b] ? f[b] : 0;
                      p2 -= G;
                      z = q - G;
                      f[b] = G + (z - p2);
                    } else
                      G = l2[b] ? l2[b] : 0, z = p2 + G, p2 = q + G, l2[b] = G + (z - p2);
                    b = u2[k].color ? u2[k].color : r2._colorSet[k % r2._colorSet.length];
                    ba(c2, m, a2.axisY.reversed ? z : p2, x, a2.axisY.reversed ? p2 : z, b, 0, null, n2 && (a2.axisY.reversed ? 0 > u2[k].y : 0 <= u2[k].y), (a2.axisY.reversed ? 0 <= u2[k].y : 0 > u2[k].y) && n2, false, false, r2.fillOpacity);
                    b = r2.dataPointIds[k];
                    this._eventManager.objectMap[b] = {
                      id: b,
                      objectType: "dataPoint",
                      dataSeriesIndex: h2,
                      dataPointIndex: k,
                      x1: m,
                      y1: p2,
                      x2: x,
                      y2: z
                    };
                    b = O(b);
                    w && ba(this._eventManager.ghostCtx, m, p2, x, z, b, 0, null, false, false, false, false);
                    (u2[k].indexLabel || r2.indexLabel || u2[k].indexLabelFormatter || r2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: u2[k], dataSeries: r2, point: { x: m + (x - m) / 2, y: 0 <= u2[k].y ? p2 : z }, direction: 0 > u2[k].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: m, y1: Math.min(p2, z), x2: x, y2: Math.max(p2, z) }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.yScaleAnimation, easingFunction: N.easing.easeOutQuart, animationBase: q < a2.axisY.bounds.y1 ? a2.axisY.bounds.y1 : q > a2.axisY.bounds.y2 ? a2.axisY.bounds.y2 : q };
          }
        };
        n.prototype.renderStackedColumn100 = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = [], l2 = [], t = [], D = [], k = 0, m, p2, q = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) / a2.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < k) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            s < k && (s = k);
            s > g && (s = g);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a2.dataSeriesIndexes.length; g++) {
              var h2 = a2.dataSeriesIndexes[g], r2 = this.data[h2], u2 = r2.dataPoints;
              if (0 < u2.length) {
                for (var n2 = 5 < s && r2.bevelEnabled ? true : false, k = 0; k < u2.length; k++)
                  if (b = u2[k].x.getTime ? u2[k].x.getTime() : u2[k].x, !(b < a2.axisX.dataInfo.viewPortMin || b > a2.axisX.dataInfo.viewPortMax) && "number" === typeof u2[k].y) {
                    m = a2.axisX.convertValueToPixel(b);
                    p2 = 0 !== a2.dataPointYSums[b] ? 100 * (u2[k].y / a2.dataPointYSums[b]) : 0;
                    m = m - a2.plotType.plotUnits.length * s / 2 + a2.index * s << 0;
                    var x = m + s << 0, z;
                    if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 < u2[k].y) {
                      t[b] = p2 + ("undefined" !== typeof t[b] ? t[b] : 0);
                      if (0 >= t[b])
                        continue;
                      p2 = a2.axisY.convertValueToPixel(t[b]);
                      z = f[b] ? f[b] : q;
                      f[b] = p2;
                    } else if (a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 >= u2[k].y)
                      D[b] = p2 + ("undefined" !== typeof D[b] ? D[b] : 0), z = a2.axisY.convertValueToPixel(D[b]), p2 = l2[b] ? l2[b] : q, l2[b] = z;
                    else if (p2 = a2.axisY.convertValueToPixel(p2), 0 <= u2[k].y) {
                      var G = "undefined" !== typeof f[b] ? f[b] : 0;
                      p2 -= G;
                      z = q - G;
                      a2.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.y1 - p2) && (p2 = e.y1);
                      f[b] = G + (z - p2);
                    } else
                      G = "undefined" !== typeof l2[b] ? l2[b] : 0, z = p2 + G, p2 = q + G, a2.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.y2 - z) && (z = e.y2), l2[b] = G + (z - p2);
                    b = u2[k].color ? u2[k].color : r2._colorSet[k % r2._colorSet.length];
                    ba(c2, m, a2.axisY.reversed ? z : p2, x, a2.axisY.reversed ? p2 : z, b, 0, null, n2 && (a2.axisY.reversed ? 0 > u2[k].y : 0 <= u2[k].y), (a2.axisY.reversed ? 0 <= u2[k].y : 0 > u2[k].y) && n2, false, false, r2.fillOpacity);
                    b = r2.dataPointIds[k];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h2, dataPointIndex: k, x1: m, y1: p2, x2: x, y2: z };
                    b = O(b);
                    w && ba(this._eventManager.ghostCtx, m, p2, x, z, b, 0, null, false, false, false, false);
                    (u2[k].indexLabel || r2.indexLabel || u2[k].indexLabelFormatter || r2.indexLabelFormatter) && this._indexLabels.push({
                      chartType: "stackedColumn100",
                      dataPoint: u2[k],
                      dataSeries: r2,
                      point: { x: m + (x - m) / 2, y: 0 <= u2[k].y ? p2 : z },
                      direction: 0 > u2[k].y === a2.axisY.reversed ? 1 : -1,
                      bounds: { x1: m, y1: Math.min(p2, z), x2: x, y2: Math.max(p2, z) },
                      color: b
                    });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.yScaleAnimation, easingFunction: N.easing.easeOutQuart, animationBase: q < a2.axisY.bounds.y1 ? a2.axisY.bounds.y1 : q > a2.axisY.bounds.y2 ? a2.axisY.bounds.y2 : q };
          }
        };
        n.prototype.renderBar = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = 0, l2, t, D, k = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a2.plotType.totalDataSeries)) << 0, p2 = a2.axisX.dataInfo.minDiff;
            isFinite(p2) || (p2 = 0.3 * Math.abs(a2.axisX.range));
            p2 = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a2.axisX.logarithmic ? Math.log(p2) / Math.log(a2.axisX.range) : Math.abs(p2) / Math.abs(a2.axisX.range)) / a2.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > m && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, m));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && m < f) && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            p2 < f && (p2 = f);
            p2 > m && (p2 = m);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(
              e.x1,
              e.y1,
              e.width,
              e.height
            ), this._eventManager.ghostCtx.clip());
            for (m = 0; m < a2.dataSeriesIndexes.length; m++) {
              var q = a2.dataSeriesIndexes[m], g = this.data[q], s = g.dataPoints;
              if (0 < s.length) {
                var h2 = 5 < p2 && g.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (f = 0; f < s.length; f++)
                  if (s[f].getTime ? D = s[f].x.getTime() : D = s[f].x, !(D < a2.axisX.dataInfo.viewPortMin || D > a2.axisX.dataInfo.viewPortMax) && "number" === typeof s[f].y) {
                    t = a2.axisX.convertValueToPixel(D);
                    l2 = a2.axisY.convertValueToPixel(s[f].y);
                    t = a2.axisX.reversed ? t + a2.plotType.totalDataSeries * p2 / 2 - (a2.previousDataSeriesCount + m) * p2 << 0 : t - a2.plotType.totalDataSeries * p2 / 2 + (a2.previousDataSeriesCount + m) * p2 << 0;
                    var r2 = a2.axisX.reversed ? t - p2 << 0 : t + p2 << 0, u2;
                    0 <= s[f].y ? u2 = k : (u2 = l2, l2 = k);
                    b = s[f].color ? s[f].color : g._colorSet[f % g._colorSet.length];
                    ba(c2, a2.axisY.reversed ? l2 : u2, a2.axisX.reversed ? r2 : t, a2.axisY.reversed ? u2 : l2, a2.axisX.reversed ? t : r2, b, 0, null, h2, false, false, false, g.fillOpacity);
                    b = g.dataPointIds[f];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: f, x1: u2, y1: t, x2: l2, y2: r2 };
                    b = O(b);
                    w && ba(
                      this._eventManager.ghostCtx,
                      u2,
                      a2.axisX.reversed ? r2 : t,
                      l2,
                      a2.axisX.reversed ? t : r2,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (s[f].indexLabel || g.indexLabel || s[f].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: s[f], dataSeries: g, point: { x: 0 <= s[f].y ? l2 : u2, y: t + (r2 - t) / 2 }, direction: 0 > s[f].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(u2, l2), y1: t, x2: Math.max(u2, l2), y2: r2 }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(
              a2.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.xScaleAnimation, easingFunction: N.easing.easeOutQuart, animationBase: k < a2.axisY.bounds.x1 ? a2.axisY.bounds.x1 : k > a2.axisY.bounds.x2 ? a2.axisY.bounds.x2 : k };
          }
        };
        n.prototype.renderStackedBar = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = [], l2 = [], t = [], D = [], k = 0, m, p2, q = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) / a2.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < k) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            s < k && (s = k);
            s > g && (s = g);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a2.dataSeriesIndexes.length; g++) {
              var h2 = a2.dataSeriesIndexes[g], r2 = this.data[h2], u2 = r2.dataPoints;
              if (0 < u2.length) {
                var n2 = 5 < s && r2.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (k = 0; k < u2.length; k++)
                  if (b = u2[k].x.getTime ? u2[k].x.getTime() : u2[k].x, !(b < a2.axisX.dataInfo.viewPortMin || b > a2.axisX.dataInfo.viewPortMax) && "number" === typeof u2[k].y) {
                    p2 = a2.axisX.convertValueToPixel(b);
                    p2 = p2 - a2.plotType.plotUnits.length * s / 2 + a2.index * s << 0;
                    var x = p2 + s << 0, z;
                    if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 < u2[k].y)
                      t[b] = u2[k].y + (t[b] ? t[b] : 0), 0 < t[b] && (z = f[b] ? f[b] : q, f[b] = m = a2.axisY.convertValueToPixel(t[b]));
                    else if (a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 >= u2[k].y)
                      D[b] = u2[k].y + (D[b] ? D[b] : 0), m = l2[b] ? l2[b] : q, l2[b] = z = a2.axisY.convertValueToPixel(D[b]);
                    else if (m = a2.axisY.convertValueToPixel(u2[k].y), 0 <= u2[k].y) {
                      var G = f[b] ? f[b] : 0;
                      z = q + G;
                      m += G;
                      f[b] = G + (m - z);
                    } else
                      G = l2[b] ? l2[b] : 0, z = m - G, m = q - G, l2[b] = G + (m - z);
                    b = u2[k].color ? u2[k].color : r2._colorSet[k % r2._colorSet.length];
                    ba(c2, a2.axisY.reversed ? m : z, p2, a2.axisY.reversed ? z : m, x, b, 0, null, n2, false, false, false, r2.fillOpacity);
                    b = r2.dataPointIds[k];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h2, dataPointIndex: k, x1: z, y1: p2, x2: m, y2: x };
                    b = O(b);
                    w && ba(
                      this._eventManager.ghostCtx,
                      z,
                      p2,
                      m,
                      x,
                      b,
                      0,
                      null,
                      false,
                      false,
                      false,
                      false
                    );
                    (u2[k].indexLabel || r2.indexLabel || u2[k].indexLabelFormatter || r2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: u2[k], dataSeries: r2, point: { x: 0 <= u2[k].y ? m : z, y: p2 + (x - p2) / 2 }, direction: 0 > u2[k].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(z, m), y1: p2, x2: Math.max(z, m), y2: x }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(
              a2.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.xScaleAnimation, easingFunction: N.easing.easeOutQuart, animationBase: q < a2.axisY.bounds.x1 ? a2.axisY.bounds.x1 : q > a2.axisY.bounds.x2 ? a2.axisY.bounds.x2 : q };
          }
        };
        n.prototype.renderStackedBar100 = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = [], l2 = [], t = [], D = [], k = 0, m, p2, q = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, g = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) / a2.plotType.plotUnits.length) << 0;
            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, g));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && g < k) && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k));
            s < k && (s = k);
            s > g && (s = g);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (g = 0; g < a2.dataSeriesIndexes.length; g++) {
              var h2 = a2.dataSeriesIndexes[g], r2 = this.data[h2], u2 = r2.dataPoints;
              if (0 < u2.length) {
                var n2 = 5 < s && r2.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (k = 0; k < u2.length; k++)
                  if (b = u2[k].x.getTime ? u2[k].x.getTime() : u2[k].x, !(b < a2.axisX.dataInfo.viewPortMin || b > a2.axisX.dataInfo.viewPortMax) && "number" === typeof u2[k].y) {
                    p2 = a2.axisX.convertValueToPixel(b);
                    var x;
                    x = 0 !== a2.dataPointYSums[b] ? 100 * (u2[k].y / a2.dataPointYSums[b]) : 0;
                    p2 = p2 - a2.plotType.plotUnits.length * s / 2 + a2.index * s << 0;
                    var z = p2 + s << 0;
                    if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 < u2[k].y) {
                      t[b] = x + (t[b] ? t[b] : 0);
                      if (0 >= t[b])
                        continue;
                      x = f[b] ? f[b] : q;
                      f[b] = m = a2.axisY.convertValueToPixel(t[b]);
                    } else if (a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length && 0 >= u2[k].y)
                      D[b] = x + (D[b] ? D[b] : 0), m = l2[b] ? l2[b] : q, l2[b] = x = a2.axisY.convertValueToPixel(D[b]);
                    else if (m = a2.axisY.convertValueToPixel(x), 0 <= u2[k].y) {
                      var G = f[b] ? f[b] : 0;
                      x = q + G;
                      m += G;
                      a2.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.x2 - m) && (m = e.x2);
                      f[b] = G + (m - x);
                    } else
                      G = l2[b] ? l2[b] : 0, x = m - G, m = q - G, a2.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(e.x1 - x) && (x = e.x1), l2[b] = G + (m - x);
                    b = u2[k].color ? u2[k].color : r2._colorSet[k % r2._colorSet.length];
                    ba(c2, a2.axisY.reversed ? m : x, p2, a2.axisY.reversed ? x : m, z, b, 0, null, n2, false, false, false, r2.fillOpacity);
                    b = r2.dataPointIds[k];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h2, dataPointIndex: k, x1: x, y1: p2, x2: m, y2: z };
                    b = O(b);
                    w && ba(this._eventManager.ghostCtx, x, p2, m, z, b, 0, null, false, false, false, false);
                    (u2[k].indexLabel || r2.indexLabel || u2[k].indexLabelFormatter || r2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: u2[k], dataSeries: r2, point: { x: 0 <= u2[k].y ? m : x, y: p2 + (z - p2) / 2 }, direction: 0 > u2[k].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(x, m), y1: p2, x2: Math.max(x, m), y2: z }, color: b });
                  }
              }
            }
            w && (d2.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return {
              source: d2,
              dest: this.plotArea.ctx,
              animationCallback: N.xScaleAnimation,
              easingFunction: N.easing.easeOutQuart,
              animationBase: q < a2.axisY.bounds.x1 ? a2.axisY.bounds.x1 : q > a2.axisY.bounds.x2 ? a2.axisY.bounds.x2 : q
            };
          }
        };
        n.prototype.renderArea = function(a2) {
          var d2, c2;
          function b() {
            G && (0 < g.lineThickness && f.stroke(), a2.axisY.logarithmic || 0 >= a2.axisY.viewportMinimum && 0 <= a2.axisY.viewportMaximum ? z = x : 0 > a2.axisY.viewportMaximum ? z = t.y1 : 0 < a2.axisY.viewportMinimum && (z = x), f.lineTo(r2, z), f.lineTo(G.x, z), f.closePath(), f.globalAlpha = g.fillOpacity, f.fill(), f.globalAlpha = 1, w && (l2.lineTo(r2, z), l2.lineTo(G.x, z), l2.closePath(), l2.fill()), f.beginPath(), f.moveTo(
              r2,
              u2
            ), l2.beginPath(), l2.moveTo(r2, u2), G = { x: r2, y: u2 });
          }
          var e = a2.targetCanvasCtx || this.plotArea.ctx, f = w ? this._preRenderCtx : e;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var l2 = this._eventManager.ghostCtx, t = a2.axisY.lineCoordinates, D = [], k = this.plotArea, m;
            f.save();
            w && l2.save();
            f.beginPath();
            f.rect(k.x1, k.y1, k.width, k.height);
            f.clip();
            w && (l2.beginPath(), l2.rect(k.x1, k.y1, k.width, k.height), l2.clip());
            for (var p2 = 0; p2 < a2.dataSeriesIndexes.length; p2++) {
              var q = a2.dataSeriesIndexes[p2], g = this.data[q], s = g.dataPoints, D = g.id;
              this._eventManager.objectMap[D] = { objectType: "dataSeries", dataSeriesIndex: q };
              D = O(D);
              l2.fillStyle = D;
              D = [];
              d2 = true;
              var h2 = 0, r2, u2, n2, x = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), z, G = null;
              if (0 < s.length) {
                var C2 = g._colorSet[h2 % g._colorSet.length], v3 = g.lineColor = g.options.lineColor || C2, A2 = v3;
                f.fillStyle = C2;
                f.strokeStyle = v3;
                f.lineWidth = g.lineThickness;
                c2 = "solid";
                if (f.setLineDash) {
                  var M = J(g.nullDataLineDashType, g.lineThickness);
                  c2 = g.lineDashType;
                  var T = J(c2, g.lineThickness);
                  f.setLineDash(T);
                }
                for (var ga = true; h2 < s.length; h2++)
                  if (n2 = s[h2].x.getTime ? s[h2].x.getTime() : s[h2].x, !(n2 < a2.axisX.dataInfo.viewPortMin || n2 > a2.axisX.dataInfo.viewPortMax && (!g.connectNullData || !ga)))
                    if ("number" !== typeof s[h2].y)
                      g.connectNullData || (ga || d2) || b(), ga = true;
                    else {
                      r2 = a2.axisX.convertValueToPixel(n2);
                      u2 = a2.axisY.convertValueToPixel(s[h2].y);
                      d2 || ga ? (!d2 && g.connectNullData ? (f.setLineDash && (g.options.nullDataLineDashType || c2 === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (d2 = r2, c2 = u2, r2 = m.x, u2 = m.y, b(), f.moveTo(m.x, m.y), r2 = d2, u2 = c2, G = m, c2 = g.nullDataLineDashType, f.setLineDash(M)), f.lineTo(
                        r2,
                        u2
                      ), w && l2.lineTo(r2, u2)) : (f.beginPath(), f.moveTo(r2, u2), w && (l2.beginPath(), l2.moveTo(r2, u2)), G = { x: r2, y: u2 }), ga = d2 = false) : (f.lineTo(r2, u2), w && l2.lineTo(r2, u2), 0 == h2 % 250 && b());
                      m = { x: r2, y: u2 };
                      h2 < s.length - 1 && (A2 !== (s[h2].lineColor || v3) || c2 !== (s[h2].lineDashType || g.lineDashType)) && (b(), A2 = s[h2].lineColor || v3, f.strokeStyle = A2, f.setLineDash && (s[h2].lineDashType ? (c2 = s[h2].lineDashType, f.setLineDash(J(c2, g.lineThickness))) : (c2 = g.lineDashType, f.setLineDash(T))));
                      var aa = g.dataPointIds[h2];
                      this._eventManager.objectMap[aa] = {
                        id: aa,
                        objectType: "dataPoint",
                        dataSeriesIndex: q,
                        dataPointIndex: h2,
                        x1: r2,
                        y1: u2
                      };
                      0 !== s[h2].markerSize && (0 < s[h2].markerSize || 0 < g.markerSize) && (n2 = g.getMarkerProperties(h2, r2, u2, f), D.push(n2), aa = O(aa), w && D.push({ x: r2, y: u2, ctx: l2, type: n2.type, size: n2.size, color: aa, borderColor: aa, borderThickness: n2.borderThickness }));
                      (s[h2].indexLabel || g.indexLabel || s[h2].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: s[h2], dataSeries: g, point: { x: r2, y: u2 }, direction: 0 > s[h2].y === a2.axisY.reversed ? 1 : -1, color: C2 });
                    }
                b();
                $.drawMarkers(D);
              }
            }
            w && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && f.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && f.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
            f.restore();
            return {
              source: e,
              dest: this.plotArea.ctx,
              animationCallback: N.xClipAnimation,
              easingFunction: N.easing.linear,
              animationBase: 0
            };
          }
        };
        n.prototype.renderSplineArea = function(a2) {
          function d2() {
            var c3 = v2(y, 2);
            if (0 < c3.length) {
              if (0 < m.lineThickness) {
                b.beginPath();
                b.moveTo(c3[0].x, c3[0].y);
                c3[0].newStrokeStyle && (b.strokeStyle = c3[0].newStrokeStyle);
                c3[0].newLineDashArray && b.setLineDash(c3[0].newLineDashArray);
                for (var d3 = 0; d3 < c3.length - 3; d3 += 3)
                  if (b.bezierCurveTo(c3[d3 + 1].x, c3[d3 + 1].y, c3[d3 + 2].x, c3[d3 + 2].y, c3[d3 + 3].x, c3[d3 + 3].y), w && e.bezierCurveTo(c3[d3 + 1].x, c3[d3 + 1].y, c3[d3 + 2].x, c3[d3 + 2].y, c3[d3 + 3].x, c3[d3 + 3].y), c3[d3 + 3].newStrokeStyle || c3[d3 + 3].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(c3[d3 + 3].x, c3[d3 + 3].y), c3[d3 + 3].newStrokeStyle && (b.strokeStyle = c3[d3 + 3].newStrokeStyle), c3[d3 + 3].newLineDashArray && b.setLineDash(c3[d3 + 3].newLineDashArray);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(c3[0].x, c3[0].y);
              w && (e.beginPath(), e.moveTo(c3[0].x, c3[0].y));
              for (d3 = 0; d3 < c3.length - 3; d3 += 3)
                b.bezierCurveTo(c3[d3 + 1].x, c3[d3 + 1].y, c3[d3 + 2].x, c3[d3 + 2].y, c3[d3 + 3].x, c3[d3 + 3].y), w && e.bezierCurveTo(c3[d3 + 1].x, c3[d3 + 1].y, c3[d3 + 2].x, c3[d3 + 2].y, c3[d3 + 3].x, c3[d3 + 3].y);
              a2.axisY.logarithmic || 0 >= a2.axisY.viewportMinimum && 0 <= a2.axisY.viewportMaximum ? n2 = r2 : 0 > a2.axisY.viewportMaximum ? n2 = f.y1 : 0 < a2.axisY.viewportMinimum && (n2 = r2);
              u2 = { x: c3[0].x, y: c3[0].y };
              b.lineTo(c3[c3.length - 1].x, n2);
              b.lineTo(u2.x, n2);
              b.closePath();
              b.globalAlpha = m.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              w && (e.lineTo(c3[c3.length - 1].x, n2), e.lineTo(u2.x, n2), e.closePath(), e.fill());
            }
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, f = a2.axisY.lineCoordinates, l2 = [], t = this.plotArea;
            b.save();
            w && e.save();
            b.beginPath();
            b.rect(t.x1, t.y1, t.width, t.height);
            b.clip();
            w && (e.beginPath(), e.rect(t.x1, t.y1, t.width, t.height), e.clip());
            for (var h2 = 0; h2 < a2.dataSeriesIndexes.length; h2++) {
              var k = a2.dataSeriesIndexes[h2], m = this.data[k], p2 = m.dataPoints, l2 = m.id;
              this._eventManager.objectMap[l2] = { objectType: "dataSeries", dataSeriesIndex: k };
              l2 = O(l2);
              e.fillStyle = l2;
              var l2 = [], q = 0, g, s, r2 = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), n2, u2 = null, y = [];
              if (0 < p2.length) {
                var x = m._colorSet[q % m._colorSet.length], z = m.lineColor = m.options.lineColor || x, G = z;
                b.fillStyle = x;
                b.strokeStyle = z;
                b.lineWidth = m.lineThickness;
                var C2 = "solid";
                if (b.setLineDash) {
                  var A2 = J(m.nullDataLineDashType, m.lineThickness), C2 = m.lineDashType, B3 = J(C2, m.lineThickness);
                  b.setLineDash(B3);
                }
                for (s = false; q < p2.length; q++)
                  if (g = p2[q].x.getTime ? p2[q].x.getTime() : p2[q].x, !(g < a2.axisX.dataInfo.viewPortMin || g > a2.axisX.dataInfo.viewPortMax && (!m.connectNullData || !s)))
                    if ("number" !== typeof p2[q].y)
                      0 < q && !s && (m.connectNullData ? b.setLineDash && (0 < y.length && (m.options.nullDataLineDashType || !p2[q - 1].lineDashType)) && (y[y.length - 1].newLineDashArray = A2, C2 = m.nullDataLineDashType) : (d2(), y = [])), s = true;
                    else {
                      g = a2.axisX.convertValueToPixel(g);
                      s = a2.axisY.convertValueToPixel(p2[q].y);
                      var M = m.dataPointIds[q];
                      this._eventManager.objectMap[M] = { id: M, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: q, x1: g, y1: s };
                      y[y.length] = { x: g, y: s };
                      q < p2.length - 1 && (G !== (p2[q].lineColor || z) || C2 !== (p2[q].lineDashType || m.lineDashType)) && (G = p2[q].lineColor || z, y[y.length - 1].newStrokeStyle = G, b.setLineDash && (p2[q].lineDashType ? (C2 = p2[q].lineDashType, y[y.length - 1].newLineDashArray = J(C2, m.lineThickness)) : (C2 = m.lineDashType, y[y.length - 1].newLineDashArray = B3)));
                      if (0 !== p2[q].markerSize && (0 < p2[q].markerSize || 0 < m.markerSize)) {
                        var T = m.getMarkerProperties(q, g, s, b);
                        l2.push(T);
                        M = O(M);
                        w && l2.push({ x: g, y: s, ctx: e, type: T.type, size: T.size, color: M, borderColor: M, borderThickness: T.borderThickness });
                      }
                      (p2[q].indexLabel || m.indexLabel || p2[q].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                        chartType: "splineArea",
                        dataPoint: p2[q],
                        dataSeries: m,
                        point: { x: g, y: s },
                        direction: 0 > p2[q].y === a2.axisY.reversed ? 1 : -1,
                        color: x
                      });
                      s = false;
                    }
                d2();
                $.drawMarkers(l2);
              }
            }
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && b.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(t.x1, t.y1, t.width, t.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderStepArea = function(a2) {
          var d2, c2;
          function b() {
            G && (0 < g.lineThickness && f.stroke(), a2.axisY.logarithmic || 0 >= a2.axisY.viewportMinimum && 0 <= a2.axisY.viewportMaximum ? z = x : 0 > a2.axisY.viewportMaximum ? z = t.y1 : 0 < a2.axisY.viewportMinimum && (z = x), f.lineTo(n2, z), f.lineTo(G.x, z), f.closePath(), f.globalAlpha = g.fillOpacity, f.fill(), f.globalAlpha = 1, w && (l2.lineTo(n2, z), l2.lineTo(G.x, z), l2.closePath(), l2.fill()), f.beginPath(), f.moveTo(n2, u2), l2.beginPath(), l2.moveTo(n2, u2), G = { x: n2, y: u2 });
          }
          var e = a2.targetCanvasCtx || this.plotArea.ctx, f = w ? this._preRenderCtx : e;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var l2 = this._eventManager.ghostCtx, t = a2.axisY.lineCoordinates, h2 = [], k = this.plotArea, m;
            f.save();
            w && l2.save();
            f.beginPath();
            f.rect(k.x1, k.y1, k.width, k.height);
            f.clip();
            w && (l2.beginPath(), l2.rect(k.x1, k.y1, k.width, k.height), l2.clip());
            for (var p2 = 0; p2 < a2.dataSeriesIndexes.length; p2++) {
              var q = a2.dataSeriesIndexes[p2], g = this.data[q], s = g.dataPoints, h2 = g.id;
              this._eventManager.objectMap[h2] = { objectType: "dataSeries", dataSeriesIndex: q };
              h2 = O(h2);
              l2.fillStyle = h2;
              h2 = [];
              d2 = true;
              var r2 = 0, n2, u2, y, x = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), z, G = null;
              c2 = false;
              if (0 < s.length) {
                var C2 = g._colorSet[r2 % g._colorSet.length], v3 = g.lineColor = g.options.lineColor || C2, A2 = v3;
                f.fillStyle = C2;
                f.strokeStyle = v3;
                f.lineWidth = g.lineThickness;
                var M = "solid";
                if (f.setLineDash) {
                  var T = J(g.nullDataLineDashType, g.lineThickness), M = g.lineDashType, E = J(M, g.lineThickness);
                  f.setLineDash(E);
                }
                for (; r2 < s.length; r2++)
                  if (y = s[r2].x.getTime ? s[r2].x.getTime() : s[r2].x, !(y < a2.axisX.dataInfo.viewPortMin || y > a2.axisX.dataInfo.viewPortMax && (!g.connectNullData || !c2))) {
                    var aa = u2;
                    "number" !== typeof s[r2].y ? (g.connectNullData || (c2 || d2) || b(), c2 = true) : (n2 = a2.axisX.convertValueToPixel(y), u2 = a2.axisY.convertValueToPixel(s[r2].y), d2 || c2 ? (!d2 && g.connectNullData ? (f.setLineDash && (g.options.nullDataLineDashType || M === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (d2 = n2, c2 = u2, n2 = m.x, u2 = m.y, b(), f.moveTo(m.x, m.y), n2 = d2, u2 = c2, G = m, M = g.nullDataLineDashType, f.setLineDash(T)), f.lineTo(n2, aa), f.lineTo(n2, u2), w && (l2.lineTo(n2, aa), l2.lineTo(n2, u2))) : (f.beginPath(), f.moveTo(n2, u2), w && (l2.beginPath(), l2.moveTo(n2, u2)), G = { x: n2, y: u2 }), c2 = d2 = false) : (f.lineTo(n2, aa), w && l2.lineTo(n2, aa), f.lineTo(n2, u2), w && l2.lineTo(n2, u2), 0 == r2 % 250 && b()), m = { x: n2, y: u2 }, r2 < s.length - 1 && (A2 !== (s[r2].lineColor || v3) || M !== (s[r2].lineDashType || g.lineDashType)) && (b(), A2 = s[r2].lineColor || v3, f.strokeStyle = A2, f.setLineDash && (s[r2].lineDashType ? (M = s[r2].lineDashType, f.setLineDash(J(M, g.lineThickness))) : (M = g.lineDashType, f.setLineDash(E)))), y = g.dataPointIds[r2], this._eventManager.objectMap[y] = { id: y, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: r2, x1: n2, y1: u2 }, 0 !== s[r2].markerSize && (0 < s[r2].markerSize || 0 < g.markerSize) && (aa = g.getMarkerProperties(r2, n2, u2, f), h2.push(aa), y = O(y), w && h2.push({ x: n2, y: u2, ctx: l2, type: aa.type, size: aa.size, color: y, borderColor: y, borderThickness: aa.borderThickness })), (s[r2].indexLabel || g.indexLabel || s[r2].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: s[r2], dataSeries: g, point: { x: n2, y: u2 }, direction: 0 > s[r2].y === a2.axisY.reversed ? 1 : -1, color: C2 }));
                  }
                b();
                $.drawMarkers(h2);
              }
            }
            w && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && f.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && f.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), f.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
            f.restore();
            return { source: e, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderStackedArea = function(a2) {
          function d2() {
            if (!(1 > k.length)) {
              for (0 < C2.lineThickness && b.stroke(); 0 < k.length; ) {
                var a3 = k.pop();
                b.lineTo(a3.x, a3.y);
                w && n2.lineTo(a3.x, a3.y);
              }
              b.closePath();
              b.globalAlpha = C2.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              b.beginPath();
              w && (n2.closePath(), n2.fill(), n2.beginPath());
              k = [];
            }
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = null, f = null, l2 = [], t = this.plotArea, h2 = [], k = [], m = [], p2 = [], q = 0, g, s, r2 = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), n2 = this._eventManager.ghostCtx, u2, y, x;
            w && n2.beginPath();
            b.save();
            w && n2.save();
            b.beginPath();
            b.rect(t.x1, t.y1, t.width, t.height);
            b.clip();
            w && (n2.beginPath(), n2.rect(t.x1, t.y1, t.width, t.height), n2.clip());
            for (var e = [], z = 0; z < a2.dataSeriesIndexes.length; z++) {
              var G = a2.dataSeriesIndexes[z], C2 = this.data[G], v3 = C2.dataPoints;
              C2.dataPointIndexes = [];
              for (q = 0; q < v3.length; q++)
                G = v3[q].x.getTime ? v3[q].x.getTime() : v3[q].x, C2.dataPointIndexes[G] = q, e[G] || (m.push(G), e[G] = true);
              m.sort(Ra);
            }
            for (z = 0; z < a2.dataSeriesIndexes.length; z++) {
              G = a2.dataSeriesIndexes[z];
              C2 = this.data[G];
              v3 = C2.dataPoints;
              y = true;
              k = [];
              q = C2.id;
              this._eventManager.objectMap[q] = { objectType: "dataSeries", dataSeriesIndex: G };
              q = O(q);
              n2.fillStyle = q;
              if (0 < m.length) {
                var e = C2._colorSet[0], A2 = C2.lineColor = C2.options.lineColor || e, M = A2;
                b.fillStyle = e;
                b.strokeStyle = A2;
                b.lineWidth = C2.lineThickness;
                x = "solid";
                if (b.setLineDash) {
                  var T = J(C2.nullDataLineDashType, C2.lineThickness);
                  x = C2.lineDashType;
                  var E = J(x, C2.lineThickness);
                  b.setLineDash(E);
                }
                for (var aa = true, q = 0; q < m.length; q++) {
                  var f = m[q], ha = null, ha = 0 <= C2.dataPointIndexes[f] ? v3[C2.dataPointIndexes[f]] : { x: f, y: null };
                  if (!(f < a2.axisX.dataInfo.viewPortMin || f > a2.axisX.dataInfo.viewPortMax && (!C2.connectNullData || !aa)))
                    if ("number" !== typeof ha.y)
                      C2.connectNullData || (aa || y) || d2(), aa = true;
                    else {
                      g = a2.axisX.convertValueToPixel(f);
                      var ma = h2[f] ? h2[f] : 0;
                      if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length) {
                        p2[f] = ha.y + (p2[f] ? p2[f] : 0);
                        if (0 >= p2[f] && a2.axisY.logarithmic)
                          continue;
                        s = a2.axisY.convertValueToPixel(p2[f]);
                      } else
                        s = a2.axisY.convertValueToPixel(ha.y), s -= ma;
                      k.push({ x: g, y: r2 - ma });
                      h2[f] = r2 - s;
                      y || aa ? (!y && C2.connectNullData ? (b.setLineDash && (C2.options.nullDataLineDashType || x === C2.lineDashType && C2.lineDashType !== C2.nullDataLineDashType) && (y = k.pop(), x = k[k.length - 1], d2(), b.moveTo(u2.x, u2.y), k.push(x), k.push(y), x = C2.nullDataLineDashType, b.setLineDash(T)), b.lineTo(g, s), w && n2.lineTo(g, s)) : (b.beginPath(), b.moveTo(g, s), w && (n2.beginPath(), n2.moveTo(g, s))), aa = y = false) : (b.lineTo(g, s), w && n2.lineTo(g, s), 0 == q % 250 && (d2(), b.moveTo(g, s), w && n2.moveTo(g, s), k.push({ x: g, y: r2 - ma })));
                      u2 = { x: g, y: s };
                      q < v3.length - 1 && (M !== (v3[q].lineColor || A2) || x !== (v3[q].lineDashType || C2.lineDashType)) && (d2(), b.beginPath(), b.moveTo(g, s), k.push({ x: g, y: r2 - ma }), M = v3[q].lineColor || A2, b.strokeStyle = M, b.setLineDash && (v3[q].lineDashType ? (x = v3[q].lineDashType, b.setLineDash(J(x, C2.lineThickness))) : (x = C2.lineDashType, b.setLineDash(E))));
                      if (0 <= C2.dataPointIndexes[f]) {
                        var B3 = C2.dataPointIds[C2.dataPointIndexes[f]];
                        this._eventManager.objectMap[B3] = { id: B3, objectType: "dataPoint", dataSeriesIndex: G, dataPointIndex: C2.dataPointIndexes[f], x1: g, y1: s };
                      }
                      0 <= C2.dataPointIndexes[f] && 0 !== ha.markerSize && (0 < ha.markerSize || 0 < C2.markerSize) && (ma = C2.getMarkerProperties(C2.dataPointIndexes[f], g, s, b), l2.push(ma), f = O(B3), w && l2.push({ x: g, y: s, ctx: n2, type: ma.type, size: ma.size, color: f, borderColor: f, borderThickness: ma.borderThickness }));
                      (ha.indexLabel || C2.indexLabel || ha.indexLabelFormatter || C2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: ha, dataSeries: C2, point: { x: g, y: s }, direction: 0 > v3[q].y === a2.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                d2();
                b.moveTo(g, s);
                w && n2.moveTo(g, s);
              }
              delete C2.dataPointIndexes;
            }
            $.drawMarkers(l2);
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && b.drawImage(
              a2.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(t.x1, t.y1, t.width, t.height), n2.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderStackedArea100 = function(a2) {
          function d2() {
            for (0 < C2.lineThickness && b.stroke(); 0 < k.length; ) {
              var a3 = k.pop();
              b.lineTo(a3.x, a3.y);
              w && x.lineTo(a3.x, a3.y);
            }
            b.closePath();
            b.globalAlpha = C2.fillOpacity;
            b.fill();
            b.globalAlpha = 1;
            b.beginPath();
            w && (x.closePath(), x.fill(), x.beginPath());
            k = [];
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = null, f = null, l2 = this.plotArea, t = [], h2 = [], k = [], m = [], p2 = [], q = 0, g, s, r2, n2, u2, y = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), x = this._eventManager.ghostCtx;
            b.save();
            w && x.save();
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            w && (x.beginPath(), x.rect(
              l2.x1,
              l2.y1,
              l2.width,
              l2.height
            ), x.clip());
            for (var e = [], z = 0; z < a2.dataSeriesIndexes.length; z++) {
              var G = a2.dataSeriesIndexes[z], C2 = this.data[G], v3 = C2.dataPoints;
              C2.dataPointIndexes = [];
              for (q = 0; q < v3.length; q++)
                G = v3[q].x.getTime ? v3[q].x.getTime() : v3[q].x, C2.dataPointIndexes[G] = q, e[G] || (m.push(G), e[G] = true);
              m.sort(Ra);
            }
            for (z = 0; z < a2.dataSeriesIndexes.length; z++) {
              G = a2.dataSeriesIndexes[z];
              C2 = this.data[G];
              v3 = C2.dataPoints;
              n2 = true;
              e = C2.id;
              this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: G };
              e = O(e);
              x.fillStyle = e;
              k = [];
              if (0 < m.length) {
                var e = C2._colorSet[q % C2._colorSet.length], A2 = C2.lineColor = C2.options.lineColor || e, M = A2;
                b.fillStyle = e;
                b.strokeStyle = A2;
                b.lineWidth = C2.lineThickness;
                u2 = "solid";
                if (b.setLineDash) {
                  var T = J(C2.nullDataLineDashType, C2.lineThickness);
                  u2 = C2.lineDashType;
                  var E = J(u2, C2.lineThickness);
                  b.setLineDash(E);
                }
                for (var aa = true, q = 0; q < m.length; q++) {
                  var f = m[q], ha = null, ha = 0 <= C2.dataPointIndexes[f] ? v3[C2.dataPointIndexes[f]] : { x: f, y: null };
                  if (!(f < a2.axisX.dataInfo.viewPortMin || f > a2.axisX.dataInfo.viewPortMax && (!C2.connectNullData || !aa)))
                    if ("number" !== typeof ha.y)
                      C2.connectNullData || (aa || n2) || d2(), aa = true;
                    else {
                      var ma;
                      ma = 0 !== a2.dataPointYSums[f] ? 100 * (ha.y / a2.dataPointYSums[f]) : 0;
                      g = a2.axisX.convertValueToPixel(f);
                      var B3 = h2[f] ? h2[f] : 0;
                      if (a2.axisY.logarithmic || a2.axisY.scaleBreaks && 0 < a2.axisY.scaleBreaks._appliedBreaks.length) {
                        p2[f] = ma + (p2[f] ? p2[f] : 0);
                        if (0 >= p2[f] && a2.axisY.logarithmic)
                          continue;
                        s = a2.axisY.convertValueToPixel(p2[f]);
                      } else
                        s = a2.axisY.convertValueToPixel(ma), s -= B3;
                      k.push({ x: g, y: y - B3 });
                      h2[f] = y - s;
                      n2 || aa ? (!n2 && C2.connectNullData ? (b.setLineDash && (C2.options.nullDataLineDashType || u2 === C2.lineDashType && C2.lineDashType !== C2.nullDataLineDashType) && (n2 = k.pop(), u2 = k[k.length - 1], d2(), b.moveTo(r2.x, r2.y), k.push(u2), k.push(n2), u2 = C2.nullDataLineDashType, b.setLineDash(T)), b.lineTo(g, s), w && x.lineTo(g, s)) : (b.beginPath(), b.moveTo(g, s), w && (x.beginPath(), x.moveTo(g, s))), aa = n2 = false) : (b.lineTo(g, s), w && x.lineTo(g, s), 0 == q % 250 && (d2(), b.moveTo(g, s), w && x.moveTo(g, s), k.push({ x: g, y: y - B3 })));
                      r2 = { x: g, y: s };
                      q < v3.length - 1 && (M !== (v3[q].lineColor || A2) || u2 !== (v3[q].lineDashType || C2.lineDashType)) && (d2(), b.beginPath(), b.moveTo(g, s), k.push({ x: g, y: y - B3 }), M = v3[q].lineColor || A2, b.strokeStyle = M, b.setLineDash && (v3[q].lineDashType ? (u2 = v3[q].lineDashType, b.setLineDash(J(u2, C2.lineThickness))) : (u2 = C2.lineDashType, b.setLineDash(E))));
                      if (0 <= C2.dataPointIndexes[f]) {
                        var F = C2.dataPointIds[C2.dataPointIndexes[f]];
                        this._eventManager.objectMap[F] = { id: F, objectType: "dataPoint", dataSeriesIndex: G, dataPointIndex: C2.dataPointIndexes[f], x1: g, y1: s };
                      }
                      0 <= C2.dataPointIndexes[f] && 0 !== ha.markerSize && (0 < ha.markerSize || 0 < C2.markerSize) && (B3 = C2.getMarkerProperties(q, g, s, b), t.push(B3), f = O(F), w && t.push({ x: g, y: s, ctx: x, type: B3.type, size: B3.size, color: f, borderColor: f, borderThickness: B3.borderThickness }));
                      (ha.indexLabel || C2.indexLabel || ha.indexLabelFormatter || C2.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: ha, dataSeries: C2, point: { x: g, y: s }, direction: 0 > v3[q].y === a2.axisY.reversed ? 1 : -1, color: e });
                    }
                }
                d2();
                b.moveTo(g, s);
                w && x.moveTo(g, s);
              }
              delete C2.dataPointIndexes;
            }
            $.drawMarkers(t);
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && b.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(l2.x1, l2.y1, l2.width, l2.height), x.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderBubble = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = this.plotArea, e = 0, f, l2;
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(b.x1, b.y1, b.width, b.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var t = -Infinity, h2 = Infinity, k = 0; k < a2.dataSeriesIndexes.length; k++)
              for (var m = a2.dataSeriesIndexes[k], p2 = this.data[m], q = p2.dataPoints, g = 0, e = 0; e < q.length; e++)
                f = q[e].getTime ? f = q[e].x.getTime() : f = q[e].x, f < a2.axisX.dataInfo.viewPortMin || f > a2.axisX.dataInfo.viewPortMax || "undefined" === typeof q[e].z || (g = q[e].z, g > t && (t = g), g < h2 && (h2 = g));
            for (var s = 25 * Math.PI, r2 = Math.max(Math.pow(0.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI, s), k = 0; k < a2.dataSeriesIndexes.length; k++)
              if (m = a2.dataSeriesIndexes[k], p2 = this.data[m], q = p2.dataPoints, 0 < q.length) {
                for (c2.strokeStyle = "#4572A7 ", e = 0; e < q.length; e++)
                  if (f = q[e].getTime ? f = q[e].x.getTime() : f = q[e].x, !(f < a2.axisX.dataInfo.viewPortMin || f > a2.axisX.dataInfo.viewPortMax) && "number" === typeof q[e].y) {
                    f = a2.axisX.convertValueToPixel(f);
                    l2 = a2.axisY.convertValueToPixel(q[e].y);
                    var g = q[e].z, n2 = 2 * Math.max(Math.sqrt((t === h2 ? r2 / 2 : s + (r2 - s) / (t - h2) * (g - h2)) / Math.PI) << 0, 1), g = p2.getMarkerProperties(e, c2);
                    g.size = n2;
                    c2.globalAlpha = p2.fillOpacity;
                    $.drawMarker(f, l2, c2, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                    c2.globalAlpha = 1;
                    var u2 = p2.dataPointIds[e];
                    this._eventManager.objectMap[u2] = { id: u2, objectType: "dataPoint", dataSeriesIndex: m, dataPointIndex: e, x1: f, y1: l2, size: n2 };
                    n2 = O(u2);
                    w && $.drawMarker(f, l2, this._eventManager.ghostCtx, g.type, g.size, n2, n2, g.borderThickness);
                    (q[e].indexLabel || p2.indexLabel || q[e].indexLabelFormatter || p2.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: q[e], dataSeries: p2, point: { x: f, y: l2 }, direction: 1, bounds: { x1: f - g.size / 2, y1: l2 - g.size / 2, x2: f + g.size / 2, y2: l2 + g.size / 2 }, color: null });
                  }
              }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(
              a2.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        n.prototype.renderScatter = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = this.plotArea, e = 0, f, l2;
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(b.x1, b.y1, b.width, b.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip());
            for (var t = 0; t < a2.dataSeriesIndexes.length; t++) {
              var h2 = a2.dataSeriesIndexes[t], k = this.data[h2], m = k.dataPoints;
              if (0 < m.length) {
                c2.strokeStyle = "#4572A7 ";
                Math.pow(0.3 * Math.min(
                  b.height,
                  b.width
                ) / 2, 2);
                for (var p2 = 0, q = 0, e = 0; e < m.length; e++)
                  if (f = m[e].getTime ? f = m[e].x.getTime() : f = m[e].x, !(f < a2.axisX.dataInfo.viewPortMin || f > a2.axisX.dataInfo.viewPortMax) && "number" === typeof m[e].y) {
                    f = a2.axisX.convertValueToPixel(f);
                    l2 = a2.axisY.convertValueToPixel(m[e].y);
                    var g = k.getMarkerProperties(e, f, l2, c2);
                    c2.globalAlpha = k.fillOpacity;
                    $.drawMarker(g.x, g.y, g.ctx, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                    c2.globalAlpha = 1;
                    Math.sqrt((p2 - f) * (p2 - f) + (q - l2) * (q - l2)) < Math.min(g.size, 5) && m.length > Math.min(
                      this.plotArea.width,
                      this.plotArea.height
                    ) || (p2 = k.dataPointIds[e], this._eventManager.objectMap[p2] = { id: p2, objectType: "dataPoint", dataSeriesIndex: h2, dataPointIndex: e, x1: f, y1: l2 }, p2 = O(p2), w && $.drawMarker(g.x, g.y, this._eventManager.ghostCtx, g.type, g.size, p2, p2, g.borderThickness), (m[e].indexLabel || k.indexLabel || m[e].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: m[e], dataSeries: k, point: { x: f, y: l2 }, direction: 1, bounds: { x1: f - g.size / 2, y1: l2 - g.size / 2, x2: f + g.size / 2, y2: l2 + g.size / 2 }, color: null }), p2 = f, q = l2);
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return {
              source: d2,
              dest: this.plotArea.ctx,
              animationCallback: N.fadeInAnimation,
              easingFunction: N.easing.easeInQuad,
              animationBase: 0
            };
          }
        };
        n.prototype.renderCandlestick = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2, b = this._eventManager.ghostCtx;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = null, f = null, l2 = this.plotArea, t = 0, h2, k, m, p2, q, g, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * l2.width * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) << 0;
            this.dataPointMaxWidth && e > f && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && f < e) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            s < e && (s = e);
            s > f && (s = f);
            c2.save();
            w && b.save();
            c2.beginPath();
            c2.rect(l2.x1, l2.y1, l2.width, l2.height);
            c2.clip();
            w && (b.beginPath(), b.rect(l2.x1, l2.y1, l2.width, l2.height), b.clip());
            for (var n2 = 0; n2 < a2.dataSeriesIndexes.length; n2++) {
              var ca = a2.dataSeriesIndexes[n2], u2 = this.data[ca], y = u2.dataPoints;
              if (0 < y.length) {
                for (var x = 5 < s && u2.bevelEnabled ? true : false, t = 0; t < y.length; t++)
                  if (y[t].getTime ? g = y[t].x.getTime() : g = y[t].x, !(g < a2.axisX.dataInfo.viewPortMin || g > a2.axisX.dataInfo.viewPortMax) && !r(y[t].y) && y[t].y.length && "number" === typeof y[t].y[0] && "number" === typeof y[t].y[1] && "number" === typeof y[t].y[2] && "number" === typeof y[t].y[3]) {
                    h2 = a2.axisX.convertValueToPixel(g);
                    k = a2.axisY.convertValueToPixel(y[t].y[0]);
                    m = a2.axisY.convertValueToPixel(y[t].y[1]);
                    p2 = a2.axisY.convertValueToPixel(y[t].y[2]);
                    q = a2.axisY.convertValueToPixel(y[t].y[3]);
                    var z = h2 - s / 2 << 0, G = z + s << 0, f = u2.options.fallingColor ? u2.fallingColor : u2._colorSet[0], e = y[t].color ? y[t].color : u2._colorSet[0], C2 = Math.round(Math.max(1, 0.15 * s)), v3 = 0 === C2 % 2 ? 0 : 0.5, A2 = u2.dataPointIds[t];
                    this._eventManager.objectMap[A2] = { id: A2, objectType: "dataPoint", dataSeriesIndex: ca, dataPointIndex: t, x1: z, y1: k, x2: G, y2: m, x3: h2, y3: p2, x4: h2, y4: q, borderThickness: C2, color: e };
                    c2.strokeStyle = e;
                    c2.beginPath();
                    c2.lineWidth = C2;
                    b.lineWidth = Math.max(C2, 4);
                    "candlestick" === u2.type ? (c2.moveTo(h2 - v3, m), c2.lineTo(h2 - v3, Math.min(k, q)), c2.stroke(), c2.moveTo(h2 - v3, Math.max(k, q)), c2.lineTo(h2 - v3, p2), c2.stroke(), ba(c2, z, Math.min(k, q), G, Math.max(k, q), y[t].y[0] <= y[t].y[3] ? u2.risingColor : f, C2, e, x, x, false, false, u2.fillOpacity), w && (e = O(A2), b.strokeStyle = e, b.moveTo(h2 - v3, m), b.lineTo(h2 - v3, Math.min(
                      k,
                      q
                    )), b.stroke(), b.moveTo(h2 - v3, Math.max(k, q)), b.lineTo(h2 - v3, p2), b.stroke(), ba(b, z, Math.min(k, q), G, Math.max(k, q), e, 0, null, false, false, false, false))) : "ohlc" === u2.type && (c2.moveTo(h2 - v3, m), c2.lineTo(h2 - v3, p2), c2.stroke(), c2.beginPath(), c2.moveTo(h2, k), c2.lineTo(z, k), c2.stroke(), c2.beginPath(), c2.moveTo(h2, q), c2.lineTo(G, q), c2.stroke(), w && (e = O(A2), b.strokeStyle = e, b.moveTo(h2 - v3, m), b.lineTo(h2 - v3, p2), b.stroke(), b.beginPath(), b.moveTo(h2, k), b.lineTo(z, k), b.stroke(), b.beginPath(), b.moveTo(h2, q), b.lineTo(G, q), b.stroke()));
                    (y[t].indexLabel || u2.indexLabel || y[t].indexLabelFormatter || u2.indexLabelFormatter) && this._indexLabels.push({ chartType: u2.type, dataPoint: y[t], dataSeries: u2, point: { x: z + (G - z) / 2, y: a2.axisY.reversed ? p2 : m }, direction: 1, bounds: { x1: z, y1: Math.min(m, p2), x2: G, y2: Math.max(m, p2) }, color: e });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(l2.x1, l2.y1, l2.width, l2.height), b.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        n.prototype.renderBoxAndWhisker = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2, b = this._eventManager.ghostCtx;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = null, f = this.plotArea, l2 = 0, t, h2, k, m, p2, q, g, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, l2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, s = a2.axisX.dataInfo.minDiff;
            isFinite(s) || (s = 0.3 * Math.abs(a2.axisX.range));
            s = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * f.width * (a2.axisX.logarithmic ? Math.log(s) / Math.log(a2.axisX.range) : Math.abs(s) / Math.abs(a2.axisX.range)) << 0;
            this.dataPointMaxWidth && e > l2 && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && l2 < e) && (l2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
            s < e && (s = e);
            s > l2 && (s = l2);
            c2.save();
            w && b.save();
            c2.beginPath();
            c2.rect(f.x1, f.y1, f.width, f.height);
            c2.clip();
            w && (b.beginPath(), b.rect(f.x1, f.y1, f.width, f.height), b.clip());
            for (var n2 = false, n2 = !!a2.axisY.reversed, ca = 0; ca < a2.dataSeriesIndexes.length; ca++) {
              var u2 = a2.dataSeriesIndexes[ca], y = this.data[u2], x = y.dataPoints;
              if (0 < x.length) {
                for (var z = 5 < s && y.bevelEnabled ? true : false, l2 = 0; l2 < x.length; l2++)
                  if (x[l2].getTime ? g = x[l2].x.getTime() : g = x[l2].x, !(g < a2.axisX.dataInfo.viewPortMin || g > a2.axisX.dataInfo.viewPortMax) && !r(x[l2].y) && x[l2].y.length && "number" === typeof x[l2].y[0] && "number" === typeof x[l2].y[1] && "number" === typeof x[l2].y[2] && "number" === typeof x[l2].y[3] && "number" === typeof x[l2].y[4] && 5 === x[l2].y.length) {
                    t = a2.axisX.convertValueToPixel(g);
                    h2 = a2.axisY.convertValueToPixel(x[l2].y[0]);
                    k = a2.axisY.convertValueToPixel(x[l2].y[1]);
                    m = a2.axisY.convertValueToPixel(x[l2].y[2]);
                    p2 = a2.axisY.convertValueToPixel(x[l2].y[3]);
                    q = a2.axisY.convertValueToPixel(x[l2].y[4]);
                    var v3 = t - s / 2 << 0, C2 = t + s / 2 << 0, e = x[l2].color ? x[l2].color : y._colorSet[0], A2 = Math.round(Math.max(1, 0.15 * s)), B3 = 0 === A2 % 2 ? 0 : 0.5, M = x[l2].whiskerColor ? x[l2].whiskerColor : x[l2].color ? y.whiskerColor ? y.whiskerColor : x[l2].color : y.whiskerColor ? y.whiskerColor : e, T = "number" === typeof x[l2].whiskerThickness ? x[l2].whiskerThickness : "number" === typeof y.options.whiskerThickness ? y.whiskerThickness : A2, E = x[l2].whiskerDashType ? x[l2].whiskerDashType : y.whiskerDashType, aa = r(x[l2].whiskerLength) ? r(y.options.whiskerLength) ? s : y.whiskerLength : x[l2].whiskerLength, aa = "number" === typeof aa ? 0 >= aa ? 0 : aa >= s ? s : aa : "string" === typeof aa ? parseInt(aa) * s / 100 > s ? s : parseInt(aa) * s / 100 : s, ha = 1 === Math.round(T) % 2 ? 0.5 : 0, ma = x[l2].stemColor ? x[l2].stemColor : x[l2].color ? y.stemColor ? y.stemColor : x[l2].color : y.stemColor ? y.stemColor : e, Ba = "number" === typeof x[l2].stemThickness ? x[l2].stemThickness : "number" === typeof y.options.stemThickness ? y.stemThickness : A2, F = 1 === Math.round(Ba) % 2 ? 0.5 : 0, I2 = x[l2].stemDashType ? x[l2].stemDashType : y.stemDashType, K2 = x[l2].lineColor ? x[l2].lineColor : x[l2].color ? y.lineColor ? y.lineColor : x[l2].color : y.lineColor ? y.lineColor : e, P2 = "number" === typeof x[l2].lineThickness ? x[l2].lineThickness : "number" === typeof y.options.lineThickness ? y.lineThickness : A2, R3 = x[l2].lineDashType ? x[l2].lineDashType : y.lineDashType, L = 1 === Math.round(P2) % 2 ? 0.5 : 0, U2 = y.upperBoxColor, S2 = y.lowerBoxColor, qa = r(y.options.fillOpacity) ? 1 : y.fillOpacity, Q = y.dataPointIds[l2];
                    this._eventManager.objectMap[Q] = {
                      id: Q,
                      objectType: "dataPoint",
                      dataSeriesIndex: u2,
                      dataPointIndex: l2,
                      x1: v3,
                      y1: h2,
                      x2: C2,
                      y2: k,
                      x3: t,
                      y3: m,
                      x4: t,
                      y4: p2,
                      y5: q,
                      borderThickness: A2,
                      color: e,
                      stemThickness: Ba,
                      stemColor: ma,
                      whiskerThickness: T,
                      whiskerLength: aa,
                      whiskerColor: M,
                      lineThickness: P2,
                      lineColor: K2
                    };
                    c2.save();
                    0 < Ba && (c2.beginPath(), c2.strokeStyle = ma, c2.lineWidth = Ba, c2.setLineDash && c2.setLineDash(J(I2, Ba)), c2.moveTo(t - F, k), c2.lineTo(t - F, h2), c2.stroke(), c2.moveTo(t - F, p2), c2.lineTo(t - F, m), c2.stroke());
                    c2.restore();
                    b.lineWidth = Math.max(A2, 4);
                    c2.beginPath();
                    ba(c2, v3, Math.min(q, k), C2, Math.max(k, q), S2, 0, e, n2 ? z : false, n2 ? false : z, false, false, qa);
                    c2.beginPath();
                    ba(c2, v3, Math.min(m, q), C2, Math.max(q, m), U2, 0, e, n2 ? false : z, n2 ? z : false, false, false, qa);
                    c2.beginPath();
                    c2.lineWidth = A2;
                    c2.strokeStyle = e;
                    c2.rect(v3 - B3, Math.min(k, m) - B3, C2 - v3 + 2 * B3, Math.max(k, m) - Math.min(k, m) + 2 * B3);
                    c2.stroke();
                    c2.save();
                    0 < P2 && (c2.beginPath(), c2.globalAlpha = 1, c2.setLineDash && c2.setLineDash(J(R3, P2)), c2.strokeStyle = K2, c2.lineWidth = P2, c2.moveTo(v3, q - L), c2.lineTo(C2, q - L), c2.stroke());
                    c2.restore();
                    c2.save();
                    0 < T && (c2.beginPath(), c2.setLineDash && c2.setLineDash(J(E, T)), c2.strokeStyle = M, c2.lineWidth = T, c2.moveTo(t - aa / 2 << 0, p2 - ha), c2.lineTo(t + aa / 2 << 0, p2 - ha), c2.stroke(), c2.moveTo(t - aa / 2 << 0, h2 + ha), c2.lineTo(t + aa / 2 << 0, h2 + ha), c2.stroke());
                    c2.restore();
                    w && (e = O(Q), b.strokeStyle = e, b.lineWidth = Ba, 0 < Ba && (b.moveTo(t - B3 - F, k), b.lineTo(t - B3 - F, Math.max(h2, p2)), b.stroke(), b.moveTo(t - B3 - F, Math.min(h2, p2)), b.lineTo(t - B3 - F, m), b.stroke()), ba(b, v3, Math.max(k, m), C2, Math.min(k, m), e, 0, null, false, false, false, false), 0 < T && (b.beginPath(), b.lineWidth = T, b.moveTo(t + aa / 2, p2 - ha), b.lineTo(t - aa / 2, p2 - ha), b.stroke(), b.moveTo(t + aa / 2, h2 + ha), b.lineTo(t - aa / 2, h2 + ha), b.stroke()));
                    (x[l2].indexLabel || y.indexLabel || x[l2].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({ chartType: y.type, dataPoint: x[l2], dataSeries: y, point: { x: v3 + (C2 - v3) / 2, y: a2.axisY.reversed ? h2 : p2 }, direction: 1, bounds: { x1: v3, y1: Math.min(h2, p2), x2: C2, y2: Math.max(h2, p2) }, color: e });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(
              this._preRenderCanvas,
              0,
              0,
              this.width,
              this.height
            ), c2.clearRect(f.x1, f.y1, f.width, f.height), b.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        n.prototype.renderRangeColumn = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = 0, l2, t, h2, f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            l2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;
            var k = a2.axisX.dataInfo.minDiff;
            isFinite(k) || (k = 0.3 * Math.abs(a2.axisX.range));
            k = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a2.axisX.logarithmic ? Math.log(k) / Math.log(a2.axisX.range) : Math.abs(k) / Math.abs(a2.axisX.range)) / a2.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > l2 && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && l2 < f) && (l2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            k < f && (k = f);
            k > l2 && (k = l2);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var m = 0; m < a2.dataSeriesIndexes.length; m++) {
              var p2 = a2.dataSeriesIndexes[m], q = this.data[p2], g = q.dataPoints;
              if (0 < g.length) {
                for (var s = 5 < k && q.bevelEnabled ? true : false, f = 0; f < g.length; f++)
                  if (g[f].getTime ? h2 = g[f].x.getTime() : h2 = g[f].x, !(h2 < a2.axisX.dataInfo.viewPortMin || h2 > a2.axisX.dataInfo.viewPortMax) && !r(g[f].y) && g[f].y.length && "number" === typeof g[f].y[0] && "number" === typeof g[f].y[1]) {
                    b = a2.axisX.convertValueToPixel(h2);
                    l2 = a2.axisY.convertValueToPixel(g[f].y[0]);
                    t = a2.axisY.convertValueToPixel(g[f].y[1]);
                    var n2 = a2.axisX.reversed ? b + a2.plotType.totalDataSeries * k / 2 - (a2.previousDataSeriesCount + m) * k << 0 : b - a2.plotType.totalDataSeries * k / 2 + (a2.previousDataSeriesCount + m) * k << 0, ca = a2.axisX.reversed ? n2 - k << 0 : n2 + k << 0, b = g[f].color ? g[f].color : q._colorSet[f % q._colorSet.length];
                    if (l2 > t) {
                      var u2 = l2;
                      l2 = t;
                      t = u2;
                    }
                    u2 = q.dataPointIds[f];
                    this._eventManager.objectMap[u2] = { id: u2, objectType: "dataPoint", dataSeriesIndex: p2, dataPointIndex: f, x1: n2, y1: l2, x2: ca, y2: t };
                    ba(c2, a2.axisX.reversed ? ca : n2, l2, a2.axisX.reversed ? n2 : ca, t, b, 0, b, s, s, false, false, q.fillOpacity);
                    b = O(u2);
                    w && ba(this._eventManager.ghostCtx, a2.axisX.reversed ? ca : n2, l2, a2.axisX.reversed ? n2 : ca, t, b, 0, null, false, false, false, false);
                    if (g[f].indexLabel || q.indexLabel || g[f].indexLabelFormatter || q.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "rangeColumn", dataPoint: g[f], dataSeries: q, indexKeyword: 0, point: { x: n2 + (ca - n2) / 2, y: g[f].y[1] >= g[f].y[0] ? t : l2 }, direction: g[f].y[1] >= g[f].y[0] ? -1 : 1, bounds: { x1: n2, y1: Math.min(l2, t), x2: ca, y2: Math.max(l2, t) }, color: b }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: g[f], dataSeries: q, indexKeyword: 1, point: { x: n2 + (ca - n2) / 2, y: g[f].y[1] >= g[f].y[0] ? l2 : t }, direction: g[f].y[1] >= g[f].y[0] ? 1 : -1, bounds: { x1: n2, y1: Math.min(l2, t), x2: ca, y2: Math.max(l2, t) }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return {
              source: d2,
              dest: this.plotArea.ctx,
              animationCallback: N.fadeInAnimation,
              easingFunction: N.easing.easeInQuad,
              animationBase: 0
            };
          }
        };
        n.prototype.renderError = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2, b = a2.axisY._position ? "left" === a2.axisY._position || "right" === a2.axisY._position ? false : true : false;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = null, f = false, l2 = this.plotArea, t = 0, h2, k, m, p2, q, g, s, n2 = a2.axisX.dataInfo.minDiff;
            isFinite(n2) || (n2 = 0.3 * Math.abs(a2.axisX.range));
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(l2.x1, l2.y1, l2.width, l2.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.clip());
            for (var ca = 0, u2 = 0; u2 < this.data.length; u2++)
              !this.data[u2].type.match(/(bar|column)/ig) || !this.data[u2].visible || this.data[u2].type.match(/(stacked)/ig) && ca || ca++;
            for (var y = 0; y < a2.dataSeriesIndexes.length; y++) {
              var x = a2.dataSeriesIndexes[y], z = this.data[x], v3 = z.dataPoints, C2 = r(z._linkedSeries) ? false : z._linkedSeries.type.match(/(bar|column)/ig) && z._linkedSeries.visible ? true : false, A2 = 0;
              if (C2)
                for (e = z._linkedSeries.id, u2 = 0; u2 < e; u2++)
                  !this.data[u2].type.match(/(bar|column)/ig) || !this.data[u2].visible || this.data[u2].type.match(/(stacked)/ig) && A2 || (this.data[u2].type.match(/(range)/ig) && (f = true), A2++);
              e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
              t = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (C2 ? ca : 1))) << 0 : 0.3 * this.width;
              f && (t = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (C2 ? ca : 1))) << 0 : 0.03 * this.width);
              u2 = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * ((b ? l2.height : l2.width) * (a2.axisX.logarithmic ? Math.log(n2) / Math.log(a2.axisX.range) : Math.abs(n2) / Math.abs(a2.axisX.range)) / (C2 ? ca : 1)) << 0;
              this.dataPointMaxWidth && e > t && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, t));
              !this.dataPointMaxWidth && (this.dataPointMinWidth && t < e) && (t = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e));
              u2 < e && (u2 = e);
              u2 > t && (u2 = t);
              if (0 < v3.length)
                for (var E = z._colorSet, t = 0; t < v3.length; t++) {
                  var e = z.lineColor = z.options.color ? z.options.color : E[0], M = { color: v3[t].whiskerColor ? v3[t].whiskerColor : v3[t].color ? z.whiskerColor ? z.whiskerColor : v3[t].color : z.whiskerColor ? z.whiskerColor : e, thickness: r(v3[t].whiskerThickness) ? z.whiskerThickness : v3[t].whiskerThickness, dashType: v3[t].whiskerDashType ? v3[t].whiskerDashType : z.whiskerDashType, length: r(v3[t].whiskerLength) ? r(z.options.whiskerLength) ? u2 : z.options.whiskerLength : v3[t].whiskerLength, trimLength: r(v3[t].whiskerLength) ? r(z.options.whiskerLength) ? 50 : 0 : 0 };
                  M.length = "number" === typeof M.length ? 0 >= M.length ? 0 : M.length >= u2 ? u2 : M.length : "string" === typeof M.length ? parseInt(M.length) * u2 / 100 > u2 ? u2 : parseInt(M.length) * u2 / 100 > u2 : u2;
                  M.thickness = "number" === typeof M.thickness ? 0 > M.thickness ? 0 : Math.round(M.thickness) : 2;
                  var T = { color: v3[t].stemColor ? v3[t].stemColor : v3[t].color ? z.stemColor ? z.stemColor : v3[t].color : z.stemColor ? z.stemColor : e, thickness: v3[t].stemThickness ? v3[t].stemThickness : z.stemThickness, dashType: v3[t].stemDashType ? v3[t].stemDashType : z.stemDashType };
                  T.thickness = "number" === typeof T.thickness ? 0 > T.thickness ? 0 : Math.round(T.thickness) : 2;
                  v3[t].getTime ? s = v3[t].x.getTime() : s = v3[t].x;
                  if (!(s < a2.axisX.dataInfo.viewPortMin || s > a2.axisX.dataInfo.viewPortMax) && !r(v3[t].y) && v3[t].y.length && "number" === typeof v3[t].y[0] && "number" === typeof v3[t].y[1]) {
                    var ga = a2.axisX.convertValueToPixel(s);
                    b ? k = ga : h2 = ga;
                    ga = a2.axisY.convertValueToPixel(v3[t].y[0]);
                    b ? m = ga : q = ga;
                    ga = a2.axisY.convertValueToPixel(v3[t].y[1]);
                    b ? p2 = ga : g = ga;
                    b ? (q = a2.axisX.reversed ? k + (C2 ? ca : 1) * u2 / 2 - (C2 ? A2 - 1 : 0) * u2 << 0 : k - (C2 ? ca : 1) * u2 / 2 + (C2 ? A2 - 1 : 0) * u2 << 0, g = a2.axisX.reversed ? q - u2 << 0 : q + u2 << 0) : (m = a2.axisX.reversed ? h2 + (C2 ? ca : 1) * u2 / 2 - (C2 ? A2 - 1 : 0) * u2 << 0 : h2 - (C2 ? ca : 1) * u2 / 2 + (C2 ? A2 - 1 : 0) * u2 << 0, p2 = a2.axisX.reversed ? m - u2 << 0 : m + u2 << 0);
                    !b && q > g && (ga = q, q = g, g = ga);
                    b && m > p2 && (ga = m, m = p2, p2 = ga);
                    ga = z.dataPointIds[t];
                    this._eventManager.objectMap[ga] = {
                      id: ga,
                      objectType: "dataPoint",
                      dataSeriesIndex: x,
                      dataPointIndex: t,
                      x1: Math.min(m, p2),
                      y1: Math.min(q, g),
                      x2: Math.max(p2, m),
                      y2: Math.max(g, q),
                      isXYSwapped: b,
                      stemProperties: T,
                      whiskerProperties: M
                    };
                    B2(c2, Math.min(m, p2), Math.min(q, g), Math.max(p2, m), Math.max(g, q), e, M, T, b);
                    w && B2(this._eventManager.ghostCtx, m, q, p2, g, e, M, T, b);
                    if (v3[t].indexLabel || z.indexLabel || v3[t].indexLabelFormatter || z.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "error", dataPoint: v3[t], dataSeries: z, indexKeyword: 0, point: { x: b ? v3[t].y[1] >= v3[t].y[0] ? m : p2 : m + (p2 - m) / 2, y: b ? q + (g - q) / 2 : v3[t].y[1] >= v3[t].y[0] ? g : q }, direction: v3[t].y[1] >= v3[t].y[0] ? -1 : 1, bounds: { x1: b ? Math.min(m, p2) : m, y1: b ? q : Math.min(q, g), x2: b ? Math.max(m, p2) : p2, y2: b ? g : Math.max(q, g) }, color: e, axisSwapped: b }), this._indexLabels.push({ chartType: "error", dataPoint: v3[t], dataSeries: z, indexKeyword: 1, point: { x: b ? v3[t].y[1] >= v3[t].y[0] ? p2 : m : m + (p2 - m) / 2, y: b ? q + (g - q) / 2 : v3[t].y[1] >= v3[t].y[0] ? q : g }, direction: v3[t].y[1] >= v3[t].y[0] ? 1 : -1, bounds: { x1: b ? Math.min(m, p2) : m, y1: b ? q : Math.min(q, g), x2: b ? Math.max(m, p2) : p2, y2: b ? g : Math.max(q, g) }, color: e, axisSwapped: b });
                  }
                }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(
              a2.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        n.prototype.renderRangeBar = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = null, e = this.plotArea, f = 0, l2, t, h2, k, f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            l2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a2.plotType.totalDataSeries)) << 0;
            var m = a2.axisX.dataInfo.minDiff;
            isFinite(m) || (m = 0.3 * Math.abs(a2.axisX.range));
            m = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a2.axisX.logarithmic ? Math.log(m) / Math.log(a2.axisX.range) : Math.abs(m) / Math.abs(a2.axisX.range)) / a2.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && f > l2 && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, l2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && l2 < f) && (l2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f));
            m < f && (m = f);
            m > l2 && (m = l2);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(e.x1, e.y1, e.width, e.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
            for (var p2 = 0; p2 < a2.dataSeriesIndexes.length; p2++) {
              var q = a2.dataSeriesIndexes[p2], g = this.data[q], s = g.dataPoints;
              if (0 < s.length) {
                var n2 = 5 < m && g.bevelEnabled ? true : false;
                c2.strokeStyle = "#4572A7 ";
                for (f = 0; f < s.length; f++)
                  if (s[f].getTime ? k = s[f].x.getTime() : k = s[f].x, !(k < a2.axisX.dataInfo.viewPortMin || k > a2.axisX.dataInfo.viewPortMax) && !r(s[f].y) && s[f].y.length && "number" === typeof s[f].y[0] && "number" === typeof s[f].y[1]) {
                    l2 = a2.axisY.convertValueToPixel(s[f].y[0]);
                    t = a2.axisY.convertValueToPixel(s[f].y[1]);
                    h2 = a2.axisX.convertValueToPixel(k);
                    h2 = a2.axisX.reversed ? h2 + a2.plotType.totalDataSeries * m / 2 - (a2.previousDataSeriesCount + p2) * m << 0 : h2 - a2.plotType.totalDataSeries * m / 2 + (a2.previousDataSeriesCount + p2) * m << 0;
                    var v3 = a2.axisX.reversed ? h2 - m << 0 : h2 + m << 0;
                    l2 > t && (b = l2, l2 = t, t = b);
                    b = s[f].color ? s[f].color : g._colorSet[f % g._colorSet.length];
                    ba(c2, l2, a2.axisX.reversed ? v3 : h2, t, a2.axisX.reversed ? h2 : v3, b, 0, null, n2, false, false, false, g.fillOpacity);
                    b = g.dataPointIds[f];
                    this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: f, x1: l2, y1: h2, x2: t, y2: v3 };
                    b = O(b);
                    w && ba(this._eventManager.ghostCtx, l2, a2.axisX.reversed ? v3 : h2, t, a2.axisX.reversed ? h2 : v3, b, 0, null, false, false, false, false);
                    if (s[f].indexLabel || g.indexLabel || s[f].indexLabelFormatter || g.indexLabelFormatter)
                      this._indexLabels.push({ chartType: "rangeBar", dataPoint: s[f], dataSeries: g, indexKeyword: 0, point: { x: s[f].y[1] >= s[f].y[0] ? l2 : t, y: h2 + (v3 - h2) / 2 }, direction: s[f].y[1] >= s[f].y[0] ? -1 : 1, bounds: { x1: Math.min(
                        l2,
                        t
                      ), y1: h2, x2: Math.max(l2, t), y2: v3 }, color: b }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: s[f], dataSeries: g, indexKeyword: 1, point: { x: s[f].y[1] >= s[f].y[0] ? t : l2, y: h2 + (v3 - h2) / 2 }, direction: s[f].y[1] >= s[f].y[0] ? 1 : -1, bounds: { x1: Math.min(l2, t), y1: h2, x2: Math.max(l2, t), y2: v3 }, color: b });
                  }
              }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(
              a2.axisY.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        n.prototype.renderRangeArea = function(a2) {
          function d2() {
            if (y) {
              for (var a3 = null, c3 = h2.length - 1; 0 <= c3; c3--)
                a3 = h2[c3], b.lineTo(a3.x, a3.y2), e.lineTo(a3.x, a3.y2);
              b.closePath();
              b.globalAlpha = m.fillOpacity;
              b.fill();
              b.globalAlpha = 1;
              e.fill();
              if (0 < m.lineThickness) {
                b.beginPath();
                b.moveTo(a3.x, a3.y2);
                for (c3 = 0; c3 < h2.length; c3++)
                  a3 = h2[c3], b.lineTo(a3.x, a3.y2);
                b.moveTo(h2[0].x, h2[0].y1);
                for (c3 = 0; c3 < h2.length; c3++)
                  a3 = h2[c3], b.lineTo(a3.x, a3.y1);
                b.stroke();
              }
              b.beginPath();
              b.moveTo(s, r2);
              e.beginPath();
              e.moveTo(s, r2);
              y = { x: s, y: r2 };
              h2 = [];
              h2.push({ x: s, y1: r2, y2: n2 });
            }
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, f = [], l2 = this.plotArea;
            b.save();
            w && e.save();
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            w && (e.beginPath(), e.rect(l2.x1, l2.y1, l2.width, l2.height), e.clip());
            for (var t = 0; t < a2.dataSeriesIndexes.length; t++) {
              var h2 = [], k = a2.dataSeriesIndexes[t], m = this.data[k], p2 = m.dataPoints, f = m.id;
              this._eventManager.objectMap[f] = { objectType: "dataSeries", dataSeriesIndex: k };
              f = O(f);
              e.fillStyle = f;
              var f = [], q = true, g = 0, s, r2, n2, u2, y = null;
              if (0 < p2.length) {
                var x = m._colorSet[g % m._colorSet.length], v3 = m.lineColor = m.options.lineColor || x, A2 = v3;
                b.fillStyle = x;
                b.strokeStyle = v3;
                b.lineWidth = m.lineThickness;
                var C2 = "solid";
                if (b.setLineDash) {
                  var B3 = J(m.nullDataLineDashType, m.lineThickness), C2 = m.lineDashType, E = J(C2, m.lineThickness);
                  b.setLineDash(E);
                }
                for (var M = true; g < p2.length; g++)
                  if (u2 = p2[g].x.getTime ? p2[g].x.getTime() : p2[g].x, !(u2 < a2.axisX.dataInfo.viewPortMin || u2 > a2.axisX.dataInfo.viewPortMax && (!m.connectNullData || !M)))
                    if (null !== p2[g].y && p2[g].y.length && "number" === typeof p2[g].y[0] && "number" === typeof p2[g].y[1]) {
                      s = a2.axisX.convertValueToPixel(u2);
                      r2 = a2.axisY.convertValueToPixel(p2[g].y[0]);
                      n2 = a2.axisY.convertValueToPixel(p2[g].y[1]);
                      q || M ? (m.connectNullData && !q ? (b.setLineDash && (m.options.nullDataLineDashType || C2 === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (h2[h2.length - 1].newLineDashArray = E, C2 = m.nullDataLineDashType, b.setLineDash(B3)), b.lineTo(s, r2), w && e.lineTo(s, r2), h2.push({ x: s, y1: r2, y2: n2 })) : (b.beginPath(), b.moveTo(s, r2), y = { x: s, y: r2 }, h2 = [], h2.push({ x: s, y1: r2, y2: n2 }), w && (e.beginPath(), e.moveTo(s, r2))), M = q = false) : (b.lineTo(s, r2), h2.push({ x: s, y1: r2, y2: n2 }), w && e.lineTo(s, r2), 0 == g % 250 && d2());
                      u2 = m.dataPointIds[g];
                      this._eventManager.objectMap[u2] = { id: u2, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: g, x1: s, y1: r2, y2: n2 };
                      g < p2.length - 1 && (A2 !== (p2[g].lineColor || v3) || C2 !== (p2[g].lineDashType || m.lineDashType)) && (d2(), A2 = p2[g].lineColor || v3, h2[h2.length - 1].newStrokeStyle = A2, b.strokeStyle = A2, b.setLineDash && (p2[g].lineDashType ? (C2 = p2[g].lineDashType, h2[h2.length - 1].newLineDashArray = J(C2, m.lineThickness), b.setLineDash(h2[h2.length - 1].newLineDashArray)) : (C2 = m.lineDashType, h2[h2.length - 1].newLineDashArray = E, b.setLineDash(E))));
                      if (0 !== p2[g].markerSize && (0 < p2[g].markerSize || 0 < m.markerSize)) {
                        var T = m.getMarkerProperties(g, s, n2, b);
                        f.push(T);
                        var ga = O(u2);
                        w && f.push({ x: s, y: n2, ctx: e, type: T.type, size: T.size, color: ga, borderColor: ga, borderThickness: T.borderThickness });
                        T = m.getMarkerProperties(g, s, r2, b);
                        f.push(T);
                        ga = O(u2);
                        w && f.push({ x: s, y: r2, ctx: e, type: T.type, size: T.size, color: ga, borderColor: ga, borderThickness: T.borderThickness });
                      }
                      if (p2[g].indexLabel || m.indexLabel || p2[g].indexLabelFormatter || m.indexLabelFormatter)
                        this._indexLabels.push({
                          chartType: "rangeArea",
                          dataPoint: p2[g],
                          dataSeries: m,
                          indexKeyword: 0,
                          point: { x: s, y: r2 },
                          direction: p2[g].y[0] > p2[g].y[1] === a2.axisY.reversed ? -1 : 1,
                          color: x
                        }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: p2[g], dataSeries: m, indexKeyword: 1, point: { x: s, y: n2 }, direction: p2[g].y[0] > p2[g].y[1] === a2.axisY.reversed ? 1 : -1, color: x });
                    } else
                      M || q || d2(), M = true;
                d2();
                $.drawMarkers(f);
              }
            }
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && b.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderRangeSplineArea = function(a2) {
          function d2(a3, c3) {
            var d3 = v2(n2, 2);
            if (0 < d3.length) {
              if (0 < k.lineThickness) {
                b.strokeStyle = c3;
                b.setLineDash && b.setLineDash(a3);
                b.beginPath();
                b.moveTo(d3[0].x, d3[0].y);
                for (var f2 = 0; f2 < d3.length - 3; f2 += 3) {
                  if (d3[f2].newStrokeStyle || d3[f2].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(d3[f2].x, d3[f2].y), d3[f2].newStrokeStyle && (b.strokeStyle = d3[f2].newStrokeStyle), d3[f2].newLineDashArray && b.setLineDash(d3[f2].newLineDashArray);
                  b.bezierCurveTo(d3[f2 + 1].x, d3[f2 + 1].y, d3[f2 + 2].x, d3[f2 + 2].y, d3[f2 + 3].x, d3[f2 + 3].y);
                }
              }
              b.beginPath();
              b.moveTo(d3[0].x, d3[0].y);
              w && (e.beginPath(), e.moveTo(d3[0].x, d3[0].y));
              for (f2 = 0; f2 < d3.length - 3; f2 += 3)
                b.bezierCurveTo(d3[f2 + 1].x, d3[f2 + 1].y, d3[f2 + 2].x, d3[f2 + 2].y, d3[f2 + 3].x, d3[f2 + 3].y), w && e.bezierCurveTo(d3[f2 + 1].x, d3[f2 + 1].y, d3[f2 + 2].x, d3[f2 + 2].y, d3[f2 + 3].x, d3[f2 + 3].y);
              d3 = v2(ca, 2);
              b.lineTo(ca[ca.length - 1].x, ca[ca.length - 1].y);
              for (f2 = d3.length - 1; 2 < f2; f2 -= 3)
                b.bezierCurveTo(d3[f2 - 1].x, d3[f2 - 1].y, d3[f2 - 2].x, d3[f2 - 2].y, d3[f2 - 3].x, d3[f2 - 3].y), w && e.bezierCurveTo(d3[f2 - 1].x, d3[f2 - 1].y, d3[f2 - 2].x, d3[f2 - 2].y, d3[f2 - 3].x, d3[f2 - 3].y);
              b.closePath();
              b.globalAlpha = k.fillOpacity;
              b.fill();
              w && (e.closePath(), e.fill());
              b.globalAlpha = 1;
              if (0 < k.lineThickness) {
                b.strokeStyle = c3;
                b.setLineDash && b.setLineDash(a3);
                b.beginPath();
                b.moveTo(d3[0].x, d3[0].y);
                for (var g2 = f2 = 0; f2 < d3.length - 3; f2 += 3, g2++) {
                  if (n2[g2].newStrokeStyle || n2[g2].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(d3[f2].x, d3[f2].y), n2[g2].newStrokeStyle && (b.strokeStyle = n2[g2].newStrokeStyle), n2[g2].newLineDashArray && b.setLineDash(n2[g2].newLineDashArray);
                  b.bezierCurveTo(d3[f2 + 1].x, d3[f2 + 1].y, d3[f2 + 2].x, d3[f2 + 2].y, d3[f2 + 3].x, d3[f2 + 3].y);
                }
                d3 = v2(n2, 2);
                b.moveTo(d3[0].x, d3[0].y);
                for (g2 = f2 = 0; f2 < d3.length - 3; f2 += 3, g2++) {
                  if (n2[g2].newStrokeStyle || n2[g2].newLineDashArray)
                    b.stroke(), b.beginPath(), b.moveTo(
                      d3[f2].x,
                      d3[f2].y
                    ), n2[g2].newStrokeStyle && (b.strokeStyle = n2[g2].newStrokeStyle), n2[g2].newLineDashArray && b.setLineDash(n2[g2].newLineDashArray);
                  b.bezierCurveTo(d3[f2 + 1].x, d3[f2 + 1].y, d3[f2 + 2].x, d3[f2 + 2].y, d3[f2 + 3].x, d3[f2 + 3].y);
                }
                b.stroke();
              }
              b.beginPath();
            }
          }
          var c2 = a2.targetCanvasCtx || this.plotArea.ctx, b = w ? this._preRenderCtx : c2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var e = this._eventManager.ghostCtx, f = [], l2 = this.plotArea;
            b.save();
            w && e.save();
            b.beginPath();
            b.rect(l2.x1, l2.y1, l2.width, l2.height);
            b.clip();
            w && (e.beginPath(), e.rect(
              l2.x1,
              l2.y1,
              l2.width,
              l2.height
            ), e.clip());
            for (var h2 = 0; h2 < a2.dataSeriesIndexes.length; h2++) {
              var r2 = a2.dataSeriesIndexes[h2], k = this.data[r2], m = k.dataPoints, f = k.id;
              this._eventManager.objectMap[f] = { objectType: "dataSeries", dataSeriesIndex: r2 };
              f = O(f);
              e.fillStyle = f;
              var f = [], p2 = 0, q, g, s, n2 = [], ca = [];
              if (0 < m.length) {
                var u2 = k._colorSet[p2 % k._colorSet.length], y = k.lineColor = k.options.lineColor || u2, x = y;
                b.fillStyle = u2;
                b.lineWidth = k.lineThickness;
                var z = "solid", A2;
                if (b.setLineDash) {
                  var C2 = J(k.nullDataLineDashType, k.lineThickness), z = k.lineDashType;
                  A2 = J(
                    z,
                    k.lineThickness
                  );
                }
                for (g = false; p2 < m.length; p2++)
                  if (q = m[p2].x.getTime ? m[p2].x.getTime() : m[p2].x, !(q < a2.axisX.dataInfo.viewPortMin || q > a2.axisX.dataInfo.viewPortMax && (!k.connectNullData || !g)))
                    if (null !== m[p2].y && m[p2].y.length && "number" === typeof m[p2].y[0] && "number" === typeof m[p2].y[1]) {
                      q = a2.axisX.convertValueToPixel(q);
                      g = a2.axisY.convertValueToPixel(m[p2].y[0]);
                      s = a2.axisY.convertValueToPixel(m[p2].y[1]);
                      var B3 = k.dataPointIds[p2];
                      this._eventManager.objectMap[B3] = {
                        id: B3,
                        objectType: "dataPoint",
                        dataSeriesIndex: r2,
                        dataPointIndex: p2,
                        x1: q,
                        y1: g,
                        y2: s
                      };
                      n2[n2.length] = { x: q, y: g };
                      ca[ca.length] = { x: q, y: s };
                      p2 < m.length - 1 && (x !== (m[p2].lineColor || y) || z !== (m[p2].lineDashType || k.lineDashType)) && (x = m[p2].lineColor || y, n2[n2.length - 1].newStrokeStyle = x, b.setLineDash && (m[p2].lineDashType ? (z = m[p2].lineDashType, n2[n2.length - 1].newLineDashArray = J(z, k.lineThickness)) : (z = k.lineDashType, n2[n2.length - 1].newLineDashArray = A2)));
                      if (0 !== m[p2].markerSize && (0 < m[p2].markerSize || 0 < k.markerSize)) {
                        var I2 = k.getMarkerProperties(p2, q, g, b);
                        f.push(I2);
                        var M = O(B3);
                        w && f.push({
                          x: q,
                          y: g,
                          ctx: e,
                          type: I2.type,
                          size: I2.size,
                          color: M,
                          borderColor: M,
                          borderThickness: I2.borderThickness
                        });
                        I2 = k.getMarkerProperties(p2, q, s, b);
                        f.push(I2);
                        M = O(B3);
                        w && f.push({ x: q, y: s, ctx: e, type: I2.type, size: I2.size, color: M, borderColor: M, borderThickness: I2.borderThickness });
                      }
                      if (m[p2].indexLabel || k.indexLabel || m[p2].indexLabelFormatter || k.indexLabelFormatter)
                        this._indexLabels.push({ chartType: "rangeSplineArea", dataPoint: m[p2], dataSeries: k, indexKeyword: 0, point: { x: q, y: g }, direction: m[p2].y[0] <= m[p2].y[1] ? -1 : 1, color: u2 }), this._indexLabels.push({
                          chartType: "rangeSplineArea",
                          dataPoint: m[p2],
                          dataSeries: k,
                          indexKeyword: 1,
                          point: { x: q, y: s },
                          direction: m[p2].y[0] <= m[p2].y[1] ? 1 : -1,
                          color: u2
                        });
                      g = false;
                    } else
                      0 < p2 && !g && (k.connectNullData ? b.setLineDash && (0 < n2.length && (k.options.nullDataLineDashType || !m[p2 - 1].lineDashType)) && (n2[n2.length - 1].newLineDashArray = C2, z = k.nullDataLineDashType) : (d2(A2, y), n2 = [], ca = [])), g = true;
                d2(A2, y);
                $.drawMarkers(f);
              }
            }
            w && (c2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && b.drawImage(
              a2.axisX.maskCanvas,
              0,
              0,
              this.width,
              this.height
            ), a2.axisY.maskCanvas && b.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(l2.x1, l2.y1, l2.width, l2.height), this._eventManager.ghostCtx.restore());
            b.restore();
            return { source: c2, dest: this.plotArea.ctx, animationCallback: N.xClipAnimation, easingFunction: N.easing.linear, animationBase: 0 };
          }
        };
        n.prototype.renderWaterfall = function(a2) {
          var d2 = a2.targetCanvasCtx || this.plotArea.ctx, c2 = w ? this._preRenderCtx : d2;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var b = this._eventManager.ghostCtx, e = null, f = this.plotArea, l2 = 0, h2, r2, k, m, p2 = a2.axisY.convertValueToPixel(a2.axisY.logarithmic ? a2.axisY.viewportMinimum : 0), l2 = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
            r2 = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a2.plotType.totalDataSeries)) << 0;
            var q = a2.axisX.dataInfo.minDiff;
            isFinite(q) || (q = 0.3 * Math.abs(a2.axisX.range));
            q = this.options.dataPointWidth ? this.dataPointWidth : 0.6 * (f.width * (a2.axisX.logarithmic ? Math.log(q) / Math.log(a2.axisX.range) : Math.abs(q) / Math.abs(a2.axisX.range)) / a2.plotType.totalDataSeries) << 0;
            this.dataPointMaxWidth && l2 > r2 && (l2 = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, r2));
            !this.dataPointMaxWidth && (this.dataPointMinWidth && r2 < l2) && (r2 = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, l2));
            q < l2 && (q = l2);
            q > r2 && (q = r2);
            c2.save();
            w && this._eventManager.ghostCtx.save();
            c2.beginPath();
            c2.rect(f.x1, f.y1, f.width, f.height);
            c2.clip();
            w && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip());
            for (var g = 0; g < a2.dataSeriesIndexes.length; g++) {
              var s = a2.dataSeriesIndexes[g], n2 = this.data[s], v3 = n2.dataPoints, e = n2._colorSet[0];
              n2.risingColor = n2.options.risingColor ? n2.options.risingColor : e;
              n2.fallingColor = n2.options.fallingColor ? n2.options.fallingColor : "#e40a0a";
              var u2 = "number" === typeof n2.options.lineThickness ? Math.round(n2.lineThickness) : 1, y = 1 === Math.round(u2) % 2 ? -0.5 : 0;
              if (0 < v3.length)
                for (var x = 5 < q && n2.bevelEnabled ? true : false, z = false, A2 = null, C2 = null, l2 = 0; l2 < v3.length; l2++)
                  if (v3[l2].getTime ? m = v3[l2].x.getTime() : m = v3[l2].x, "number" !== typeof v3[l2].y) {
                    if (0 < l2 && !z && n2.connectNullData)
                      var B3 = n2.options.nullDataLineDashType || !v3[l2 - 1].lineDashType ? n2.nullDataLineDashType : v3[l2 - 1].lineDashType;
                    z = true;
                  } else {
                    h2 = a2.axisX.convertValueToPixel(m);
                    r2 = 0 === n2.dataPointEOs[l2].cumulativeSum ? p2 : a2.axisY.convertValueToPixel(n2.dataPointEOs[l2].cumulativeSum);
                    k = 0 === n2.dataPointEOs[l2].cumulativeSumYStartValue ? p2 : a2.axisY.convertValueToPixel(n2.dataPointEOs[l2].cumulativeSumYStartValue);
                    h2 = a2.axisX.reversed ? h2 + a2.plotType.totalDataSeries * q / 2 - (a2.previousDataSeriesCount + g) * q << 0 : h2 - a2.plotType.totalDataSeries * q / 2 + (a2.previousDataSeriesCount + g) * q << 0;
                    var E = a2.axisX.reversed ? h2 - q << 0 : h2 + q << 0;
                    r2 > k && (e = r2, r2 = k, k = e);
                    a2.axisY.reversed && (e = r2, r2 = k, k = e);
                    e = n2.dataPointIds[l2];
                    this._eventManager.objectMap[e] = { id: e, objectType: "dataPoint", dataSeriesIndex: s, dataPointIndex: l2, x1: h2, y1: r2, x2: E, y2: k };
                    var M = v3[l2].color ? v3[l2].color : 0 < v3[l2].y ? n2.risingColor : n2.fallingColor;
                    ba(c2, a2.axisX.reversed ? E : h2, a2.axisY.reversed ? k : r2, a2.axisX.reversed ? h2 : E, a2.axisY.reversed ? r2 : k, M, 0, M, x, x, false, false, n2.fillOpacity);
                    e = O(e);
                    w && ba(this._eventManager.ghostCtx, a2.axisX.reversed ? E : h2, r2, a2.axisX.reversed ? h2 : E, k, e, 0, null, false, false, false, false);
                    var T, M = h2;
                    T = "undefined" !== typeof v3[l2].isIntermediateSum && true === v3[l2].isIntermediateSum || "undefined" !== typeof v3[l2].isCumulativeSum && true === v3[l2].isCumulativeSum ? 0 < v3[l2].y ? r2 : k : 0 < v3[l2].y ? k : r2;
                    0 < l2 && A2 && (!z || n2.connectNullData) && (z && c2.setLineDash && c2.setLineDash(J(B3, u2)), c2.beginPath(), c2.moveTo(A2, C2 - y), c2.lineTo(M, T - y), 0 < u2 && c2.stroke(), w && (b.beginPath(), b.moveTo(A2, C2 - y), b.lineTo(M, T - y), 0 < u2 && b.stroke()));
                    z = false;
                    A2 = E;
                    C2 = 0 < v3[l2].y ? r2 : k;
                    M = v3[l2].lineDashType ? v3[l2].lineDashType : n2.options.lineDashType ? n2.options.lineDashType : "shortDash";
                    c2.strokeStyle = v3[l2].lineColor ? v3[l2].lineColor : n2.options.lineColor ? n2.options.lineColor : "#9e9e9e";
                    c2.lineWidth = u2;
                    c2.setLineDash && (M = J(M, u2), c2.setLineDash(M));
                    (v3[l2].indexLabel || n2.indexLabel || v3[l2].indexLabelFormatter || n2.indexLabelFormatter) && this._indexLabels.push({ chartType: "waterfall", dataPoint: v3[l2], dataSeries: n2, point: { x: h2 + (E - h2) / 2, y: 0 <= v3[l2].y ? r2 : k }, direction: 0 > v3[l2].y === a2.axisY.reversed ? 1 : -1, bounds: { x1: h2, y1: Math.min(r2, k), x2: E, y2: Math.max(r2, k) }, color: e });
                  }
            }
            w && (d2.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.globalCompositeOperation = "source-atop", a2.axisX.maskCanvas && c2.drawImage(a2.axisX.maskCanvas, 0, 0, this.width, this.height), a2.axisY.maskCanvas && c2.drawImage(a2.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c2.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
            c2.restore();
            return { source: d2, dest: this.plotArea.ctx, animationCallback: N.fadeInAnimation, easingFunction: N.easing.easeInQuad, animationBase: 0 };
          }
        };
        var W2 = function(a2, d2, c2, b, e, f, l2, h2, r2) {
          if (!(0 > c2)) {
            "undefined" === typeof h2 && (h2 = 1);
            if (!w) {
              var k = Number((l2 % (2 * Math.PI)).toFixed(8));
              Number((f % (2 * Math.PI)).toFixed(8)) === k && (l2 -= 1e-4);
            }
            a2.save();
            a2.globalAlpha = h2;
            "pie" === e ? (a2.beginPath(), a2.moveTo(d2.x, d2.y), a2.arc(d2.x, d2.y, c2, f, l2, false), a2.fillStyle = b, a2.strokeStyle = "white", a2.lineWidth = 2, a2.closePath(), a2.fill()) : "doughnut" === e && (a2.beginPath(), a2.arc(d2.x, d2.y, c2, f, l2, false), 0 <= r2 && a2.arc(d2.x, d2.y, r2 * c2, l2, f, true), a2.closePath(), a2.fillStyle = b, a2.strokeStyle = "white", a2.lineWidth = 2, a2.fill());
            a2.globalAlpha = 1;
            a2.restore();
          }
        };
        n.prototype.renderPie = function(a2) {
          function d2() {
            if (k && m) {
              for (var a3 = 0, b2 = 0, c3 = 0, d3 = 0, e2 = 0; e2 < m.length; e2++) {
                var f2 = m[e2], l3 = k.dataPointIds[e2];
                g[e2].id = l3;
                g[e2].objectType = "dataPoint";
                g[e2].dataPointIndex = e2;
                g[e2].dataSeriesIndex = 0;
                var h3 = g[e2], p3 = { percent: null, total: null }, t = null, p3 = n2.getPercentAndTotal(k, f2);
                if (k.indexLabelFormatter || f2.indexLabelFormatter)
                  t = { chart: n2.options, dataSeries: k, dataPoint: f2, total: p3.total, percent: p3.percent };
                p3 = f2.indexLabelFormatter ? f2.indexLabelFormatter(t) : f2.indexLabel ? n2.replaceKeywordsWithValue(f2.indexLabel, f2, k, e2) : k.indexLabelFormatter ? k.indexLabelFormatter(t) : k.indexLabel ? n2.replaceKeywordsWithValue(k.indexLabel, f2, k, e2) : f2.label ? f2.label : "";
                n2._eventManager.objectMap[l3] = h3;
                h3.center = {
                  x: x.x,
                  y: x.y
                };
                h3.y = f2.y;
                h3.radius = C2;
                h3.percentInnerRadius = E;
                h3.indexLabelText = p3;
                h3.indexLabelPlacement = k.indexLabelPlacement;
                h3.indexLabelLineColor = f2.indexLabelLineColor ? f2.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : f2.color ? f2.color : k._colorSet[e2 % k._colorSet.length];
                h3.indexLabelLineThickness = r(f2.indexLabelLineThickness) ? k.indexLabelLineThickness : f2.indexLabelLineThickness;
                h3.indexLabelLineDashType = f2.indexLabelLineDashType ? f2.indexLabelLineDashType : k.indexLabelLineDashType;
                h3.indexLabelFontColor = f2.indexLabelFontColor ? f2.indexLabelFontColor : k.indexLabelFontColor;
                h3.indexLabelFontStyle = f2.indexLabelFontStyle ? f2.indexLabelFontStyle : k.indexLabelFontStyle;
                h3.indexLabelFontWeight = f2.indexLabelFontWeight ? f2.indexLabelFontWeight : k.indexLabelFontWeight;
                h3.indexLabelFontSize = r(f2.indexLabelFontSize) ? k.indexLabelFontSize : f2.indexLabelFontSize;
                h3.indexLabelFontFamily = f2.indexLabelFontFamily ? f2.indexLabelFontFamily : k.indexLabelFontFamily;
                h3.indexLabelBackgroundColor = f2.indexLabelBackgroundColor ? f2.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;
                h3.indexLabelMaxWidth = f2.indexLabelMaxWidth ? f2.indexLabelMaxWidth : k.indexLabelMaxWidth ? k.indexLabelMaxWidth : 0.33 * q.width;
                h3.indexLabelWrap = "undefined" !== typeof f2.indexLabelWrap ? f2.indexLabelWrap : k.indexLabelWrap;
                h3.indexLabelTextAlign = f2.indexLabelTextAlign ? f2.indexLabelTextAlign : k.indexLabelTextAlign ? k.indexLabelTextAlign : "left";
                h3.startAngle = 0 === e2 ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : g[e2 - 1].endAngle;
                h3.startAngle = (h3.startAngle + 2 * Math.PI) % (2 * Math.PI);
                h3.endAngle = h3.startAngle + 2 * Math.PI / z * Math.abs(f2.y);
                f2 = (h3.endAngle + h3.startAngle) / 2;
                f2 = (f2 + 2 * Math.PI) % (2 * Math.PI);
                h3.midAngle = f2;
                if (h3.midAngle > Math.PI / 2 - u2 && h3.midAngle < Math.PI / 2 + u2) {
                  if (0 === a3 || g[c3].midAngle > h3.midAngle)
                    c3 = e2;
                  a3++;
                } else if (h3.midAngle > 3 * Math.PI / 2 - u2 && h3.midAngle < 3 * Math.PI / 2 + u2) {
                  if (0 === b2 || g[d3].midAngle > h3.midAngle)
                    d3 = e2;
                  b2++;
                }
                h3.hemisphere = f2 > Math.PI / 2 && f2 <= 3 * Math.PI / 2 ? "left" : "right";
                h3.indexLabelTextBlock = new ka(n2.plotArea.ctx, {
                  fontSize: h3.indexLabelFontSize,
                  fontFamily: h3.indexLabelFontFamily,
                  fontColor: h3.indexLabelFontColor,
                  fontStyle: h3.indexLabelFontStyle,
                  fontWeight: h3.indexLabelFontWeight,
                  textAlign: h3.indexLabelTextAlign,
                  backgroundColor: h3.indexLabelBackgroundColor,
                  maxWidth: h3.indexLabelMaxWidth,
                  maxHeight: h3.indexLabelWrap ? 5 * h3.indexLabelFontSize : 1.5 * h3.indexLabelFontSize,
                  text: h3.indexLabelText,
                  padding: 0,
                  textBaseline: "top"
                });
                h3.indexLabelTextBlock.measureText();
              }
              l3 = f2 = 0;
              p3 = false;
              for (e2 = 0; e2 < m.length; e2++)
                h3 = g[(c3 + e2) % m.length], 1 < a3 && (h3.midAngle > Math.PI / 2 - u2 && h3.midAngle < Math.PI / 2 + u2) && (f2 <= a3 / 2 && !p3 ? (h3.hemisphere = "right", f2++) : (h3.hemisphere = "left", p3 = true));
              p3 = false;
              for (e2 = 0; e2 < m.length; e2++)
                h3 = g[(d3 + e2) % m.length], 1 < b2 && (h3.midAngle > 3 * Math.PI / 2 - u2 && h3.midAngle < 3 * Math.PI / 2 + u2) && (l3 <= b2 / 2 && !p3 ? (h3.hemisphere = "left", l3++) : (h3.hemisphere = "right", p3 = true));
            }
          }
          function c2(a3) {
            var b2 = n2.plotArea.ctx;
            b2.clearRect(q.x1, q.y1, q.width, q.height);
            b2.fillStyle = n2.backgroundColor;
            b2.fillRect(q.x1, q.y1, q.width, q.height);
            for (b2 = 0; b2 < m.length; b2++) {
              var c3 = g[b2].startAngle, d3 = g[b2].endAngle;
              if (d3 > c3) {
                var e2 = 0.07 * C2 * Math.cos(g[b2].midAngle), f2 = 0.07 * C2 * Math.sin(g[b2].midAngle), l3 = false;
                if (m[b2].exploded) {
                  if (1e-9 < Math.abs(g[b2].center.x - (x.x + e2)) || 1e-9 < Math.abs(g[b2].center.y - (x.y + f2)))
                    g[b2].center.x = x.x + e2 * a3, g[b2].center.y = x.y + f2 * a3, l3 = true;
                } else if (0 < Math.abs(g[b2].center.x - x.x) || 0 < Math.abs(g[b2].center.y - x.y))
                  g[b2].center.x = x.x + e2 * (1 - a3), g[b2].center.y = x.y + f2 * (1 - a3), l3 = true;
                l3 && (e2 = {}, e2.dataSeries = k, e2.dataPoint = k.dataPoints[b2], e2.index = b2, n2.toolTip.highlightObjects([e2]));
                W2(n2.plotArea.ctx, g[b2].center, g[b2].radius, m[b2].color ? m[b2].color : k._colorSet[b2 % k._colorSet.length], k.type, c3, d3, k.fillOpacity, g[b2].percentInnerRadius);
              }
            }
            a3 = n2.plotArea.ctx;
            a3.save();
            a3.fillStyle = "black";
            a3.strokeStyle = "grey";
            a3.textBaseline = "middle";
            a3.lineJoin = "round";
            for (b2 = b2 = 0; b2 < m.length; b2++)
              c3 = g[b2], c3.indexLabelText && (c3.indexLabelTextBlock.y -= c3.indexLabelTextBlock.height / 2, d3 = 0, d3 = "left" === c3.hemisphere ? "inside" !== k.indexLabelPlacement ? -(c3.indexLabelTextBlock.width + p2) : -c3.indexLabelTextBlock.width / 2 : "inside" !== k.indexLabelPlacement ? p2 : -c3.indexLabelTextBlock.width / 2, c3.indexLabelTextBlock.x += d3, c3.indexLabelTextBlock.render(true), c3.indexLabelTextBlock.x -= d3, c3.indexLabelTextBlock.y += c3.indexLabelTextBlock.height / 2, "inside" !== c3.indexLabelPlacement && 0 < c3.indexLabelLineThickness && (d3 = c3.center.x + C2 * Math.cos(c3.midAngle), e2 = c3.center.y + C2 * Math.sin(c3.midAngle), a3.strokeStyle = c3.indexLabelLineColor, a3.lineWidth = c3.indexLabelLineThickness, a3.setLineDash && a3.setLineDash(J(c3.indexLabelLineDashType, c3.indexLabelLineThickness)), a3.beginPath(), a3.moveTo(d3, e2), a3.lineTo(c3.indexLabelTextBlock.x, c3.indexLabelTextBlock.y), a3.lineTo(c3.indexLabelTextBlock.x + ("left" === c3.hemisphere ? -p2 : p2), c3.indexLabelTextBlock.y), a3.stroke()), a3.lineJoin = "miter");
            a3.save();
          }
          function b(a3, b2) {
            var c3 = 0, c3 = a3.indexLabelTextBlock.y - a3.indexLabelTextBlock.height / 2, d3 = a3.indexLabelTextBlock.y + a3.indexLabelTextBlock.height / 2, e2 = b2.indexLabelTextBlock.y - b2.indexLabelTextBlock.height / 2, f2 = b2.indexLabelTextBlock.y + b2.indexLabelTextBlock.height / 2;
            return c3 = b2.indexLabelTextBlock.y > a3.indexLabelTextBlock.y ? e2 - d3 : c3 - f2;
          }
          function e(a3) {
            for (var c3 = null, d3 = 1; d3 < m.length; d3++)
              if (c3 = (a3 + d3 + g.length) % g.length, g[c3].hemisphere !== g[a3].hemisphere) {
                c3 = null;
                break;
              } else if (g[c3].indexLabelText && c3 !== a3 && (0 > b(g[c3], g[a3]) || ("right" === g[a3].hemisphere ? g[c3].indexLabelTextBlock.y >= g[a3].indexLabelTextBlock.y : g[c3].indexLabelTextBlock.y <= g[a3].indexLabelTextBlock.y)))
                break;
              else
                c3 = null;
            return c3;
          }
          function f(a3, c3, d3) {
            d3 = (d3 || 0) + 1;
            if (1e3 < d3)
              return 0;
            c3 = c3 || 0;
            var l3 = 0, k2 = x.y - 1 * w2, h3 = x.y + 1 * w2;
            if (0 <= a3 && a3 < m.length) {
              var p3 = g[a3];
              if (0 > c3 && p3.indexLabelTextBlock.y < k2 || 0 < c3 && p3.indexLabelTextBlock.y > h3)
                return 0;
              var q2 = 0, t = 0, t = q2 = q2 = 0;
              0 > c3 ? p3.indexLabelTextBlock.y - p3.indexLabelTextBlock.height / 2 > k2 && p3.indexLabelTextBlock.y - p3.indexLabelTextBlock.height / 2 + c3 < k2 && (c3 = -(k2 - (p3.indexLabelTextBlock.y - p3.indexLabelTextBlock.height / 2 + c3))) : p3.indexLabelTextBlock.y + p3.indexLabelTextBlock.height / 2 < k2 && p3.indexLabelTextBlock.y + p3.indexLabelTextBlock.height / 2 + c3 > h3 && (c3 = p3.indexLabelTextBlock.y + p3.indexLabelTextBlock.height / 2 + c3 - h3);
              c3 = p3.indexLabelTextBlock.y + c3;
              k2 = 0;
              k2 = "right" === p3.hemisphere ? x.x + Math.sqrt(Math.pow(w2, 2) - Math.pow(c3 - x.y, 2)) : x.x - Math.sqrt(Math.pow(w2, 2) - Math.pow(c3 - x.y, 2));
              t = x.x + C2 * Math.cos(p3.midAngle);
              q2 = x.y + C2 * Math.sin(p3.midAngle);
              q2 = Math.sqrt(Math.pow(k2 - t, 2) + Math.pow(c3 - q2, 2));
              t = Math.acos(C2 / w2);
              q2 = Math.acos((w2 * w2 + C2 * C2 - q2 * q2) / (2 * C2 * w2));
              c3 = q2 < t ? c3 - p3.indexLabelTextBlock.y : 0;
              k2 = null;
              for (h3 = 1; h3 < m.length; h3++)
                if (k2 = (a3 - h3 + g.length) % g.length, g[k2].hemisphere !== g[a3].hemisphere) {
                  k2 = null;
                  break;
                } else if (g[k2].indexLabelText && g[k2].hemisphere === g[a3].hemisphere && k2 !== a3 && (0 > b(g[k2], g[a3]) || ("right" === g[a3].hemisphere ? g[k2].indexLabelTextBlock.y <= g[a3].indexLabelTextBlock.y : g[k2].indexLabelTextBlock.y >= g[a3].indexLabelTextBlock.y)))
                  break;
                else
                  k2 = null;
              t = k2;
              q2 = e(a3);
              h3 = k2 = 0;
              0 > c3 ? (h3 = "right" === p3.hemisphere ? t : q2, l3 = c3, null !== h3 && (t = -c3, c3 = p3.indexLabelTextBlock.y - p3.indexLabelTextBlock.height / 2 - (g[h3].indexLabelTextBlock.y + g[h3].indexLabelTextBlock.height / 2), c3 - t < s && (k2 = -t, h3 = f(h3, k2, d3 + 1), +h3.toFixed(y) > +k2.toFixed(y) && (l3 = c3 > s ? -(c3 - s) : -(t - (h3 - k2)))))) : 0 < c3 && (h3 = "right" === p3.hemisphere ? q2 : t, l3 = c3, null !== h3 && (t = c3, c3 = g[h3].indexLabelTextBlock.y - g[h3].indexLabelTextBlock.height / 2 - (p3.indexLabelTextBlock.y + p3.indexLabelTextBlock.height / 2), c3 - t < s && (k2 = t, h3 = f(h3, k2, d3 + 1), +h3.toFixed(y) < +k2.toFixed(y) && (l3 = c3 > s ? c3 - s : t - (k2 - h3)))));
              l3 && (d3 = p3.indexLabelTextBlock.y + l3, c3 = 0, c3 = "right" === p3.hemisphere ? x.x + Math.sqrt(Math.pow(w2, 2) - Math.pow(d3 - x.y, 2)) : x.x - Math.sqrt(Math.pow(w2, 2) - Math.pow(d3 - x.y, 2)), p3.midAngle > Math.PI / 2 - u2 && p3.midAngle < Math.PI / 2 + u2 ? (k2 = (a3 - 1 + g.length) % g.length, k2 = g[k2], a3 = g[(a3 + 1 + g.length) % g.length], "left" === p3.hemisphere && "right" === k2.hemisphere && c3 > k2.indexLabelTextBlock.x ? c3 = k2.indexLabelTextBlock.x - 15 : "right" === p3.hemisphere && ("left" === a3.hemisphere && c3 < a3.indexLabelTextBlock.x) && (c3 = a3.indexLabelTextBlock.x + 15)) : p3.midAngle > 3 * Math.PI / 2 - u2 && p3.midAngle < 3 * Math.PI / 2 + u2 && (k2 = (a3 - 1 + g.length) % g.length, k2 = g[k2], a3 = g[(a3 + 1 + g.length) % g.length], "right" === p3.hemisphere && "left" === k2.hemisphere && c3 < k2.indexLabelTextBlock.x ? c3 = k2.indexLabelTextBlock.x + 15 : "left" === p3.hemisphere && ("right" === a3.hemisphere && c3 > a3.indexLabelTextBlock.x) && (c3 = a3.indexLabelTextBlock.x - 15)), p3.indexLabelTextBlock.y = d3, p3.indexLabelTextBlock.x = c3, p3.indexLabelAngle = Math.atan2(p3.indexLabelTextBlock.y - x.y, p3.indexLabelTextBlock.x - x.x));
            }
            return l3;
          }
          function l2() {
            var a3 = n2.plotArea.ctx;
            a3.fillStyle = "grey";
            a3.strokeStyle = "grey";
            a3.font = "16px Arial";
            a3.textBaseline = "middle";
            for (var c3 = a3 = 0, d3 = 0, l3 = true, c3 = 0; 10 > c3 && (1 > c3 || 0 < d3); c3++) {
              if (k.radius || !k.radius && "undefined" !== typeof k.innerRadius && null !== k.innerRadius && C2 - d3 <= B3)
                l3 = false;
              l3 && (C2 -= d3);
              d3 = 0;
              if ("inside" !== k.indexLabelPlacement) {
                w2 = C2 * v3;
                for (a3 = 0; a3 < m.length; a3++) {
                  var h3 = g[a3];
                  h3.indexLabelTextBlock.x = x.x + w2 * Math.cos(h3.midAngle);
                  h3.indexLabelTextBlock.y = x.y + w2 * Math.sin(h3.midAngle);
                  h3.indexLabelAngle = h3.midAngle;
                  h3.radius = C2;
                  h3.percentInnerRadius = E;
                }
                for (var t, r2, a3 = 0; a3 < m.length; a3++) {
                  var h3 = g[a3], u3 = e(a3);
                  if (null !== u3) {
                    t = g[a3];
                    r2 = g[u3];
                    var z2 = 0, z2 = b(t, r2) - s;
                    if (0 > z2) {
                      for (var A3 = r2 = 0, G = 0; G < m.length; G++)
                        G !== a3 && g[G].hemisphere === h3.hemisphere && (g[G].indexLabelTextBlock.y < h3.indexLabelTextBlock.y ? r2++ : A3++);
                      r2 = z2 / (r2 + A3 || 1) * A3;
                      var A3 = -1 * (z2 - r2), J2 = G = 0;
                      "right" === h3.hemisphere ? (G = f(a3, r2), A3 = -1 * (z2 - G), J2 = f(u3, A3), +J2.toFixed(y) < +A3.toFixed(y) && +G.toFixed(y) <= +r2.toFixed(y) && f(a3, -(A3 - J2))) : (G = f(u3, r2), A3 = -1 * (z2 - G), J2 = f(a3, A3), +J2.toFixed(y) < +A3.toFixed(y) && +G.toFixed(y) <= +r2.toFixed(y) && f(u3, -(A3 - J2)));
                    }
                  }
                }
              } else
                for (a3 = 0; a3 < m.length; a3++)
                  h3 = g[a3], w2 = "pie" === k.type ? 0.7 * C2 : 0.85 * C2, u3 = x.x + w2 * Math.cos(h3.midAngle), r2 = x.y + w2 * Math.sin(h3.midAngle), h3.indexLabelTextBlock.x = u3, h3.indexLabelTextBlock.y = r2;
              for (a3 = 0; a3 < m.length; a3++)
                if (h3 = g[a3], u3 = h3.indexLabelTextBlock.measureText(), 0 !== u3.height && 0 !== u3.width)
                  u3 = u3 = 0, "right" === h3.hemisphere ? (u3 = q.x2 - (h3.indexLabelTextBlock.x + h3.indexLabelTextBlock.width + p2), u3 *= -1) : u3 = q.x1 - (h3.indexLabelTextBlock.x - h3.indexLabelTextBlock.width - p2), 0 < u3 && (!l3 && h3.indexLabelText && (r2 = "right" === h3.hemisphere ? q.x2 - h3.indexLabelTextBlock.x : h3.indexLabelTextBlock.x - q.x1, 0.3 * h3.indexLabelTextBlock.maxWidth > r2 ? h3.indexLabelText = "" : h3.indexLabelTextBlock.maxWidth = 0.85 * r2, 0.3 * h3.indexLabelTextBlock.maxWidth < r2 && (h3.indexLabelTextBlock.x -= "right" === h3.hemisphere ? 2 : -2)), Math.abs(h3.indexLabelTextBlock.y - h3.indexLabelTextBlock.height / 2 - x.y) < C2 || Math.abs(h3.indexLabelTextBlock.y + h3.indexLabelTextBlock.height / 2 - x.y) < C2) && (u3 /= Math.abs(Math.cos(h3.indexLabelAngle)), 9 < u3 && (u3 *= 0.3), u3 > d3 && (d3 = u3)), u3 = u3 = 0, 0 < h3.indexLabelAngle && h3.indexLabelAngle < Math.PI ? (u3 = q.y2 - (h3.indexLabelTextBlock.y + h3.indexLabelTextBlock.height / 2 + 5), u3 *= -1) : u3 = q.y1 - (h3.indexLabelTextBlock.y - h3.indexLabelTextBlock.height / 2 - 5), 0 < u3 && (!l3 && h3.indexLabelText && (r2 = 0 < h3.indexLabelAngle && h3.indexLabelAngle < Math.PI ? -1 : 1, 0 === f(a3, u3 * r2) && f(a3, 2 * r2)), Math.abs(h3.indexLabelTextBlock.x - x.x) < C2 && (u3 /= Math.abs(Math.sin(h3.indexLabelAngle)), 9 < u3 && (u3 *= 0.3), u3 > d3 && (d3 = u3)));
              var L = function(a4, b2, c4) {
                for (var d4 = [], e2 = 0; d4.push(g[b2]), b2 !== c4; b2 = (b2 + 1 + m.length) % m.length)
                  ;
                d4.sort(function(a5, b3) {
                  return a5.y - b3.y;
                });
                for (b2 = 0; b2 < d4.length; b2++)
                  if (c4 = d4[b2], e2 < 0.7 * a4)
                    e2 += c4.indexLabelTextBlock.height, c4.indexLabelTextBlock.text = "", c4.indexLabelText = "", c4.indexLabelTextBlock.measureText();
                  else
                    break;
              };
              (function() {
                for (var a4 = -1, c4 = -1, d4 = 0, f2 = false, k2 = 0; k2 < m.length; k2++)
                  if (f2 = false, t = g[k2], t.indexLabelText) {
                    var l4 = e(k2);
                    if (null !== l4) {
                      var h4 = g[l4];
                      z2 = 0;
                      z2 = b(t, h4);
                      var q2;
                      if (q2 = 0 > z2) {
                        q2 = t.indexLabelTextBlock.x;
                        var n3 = t.indexLabelTextBlock.y - t.indexLabelTextBlock.height / 2, r3 = t.indexLabelTextBlock.y + t.indexLabelTextBlock.height / 2, s2 = h4.indexLabelTextBlock.y - h4.indexLabelTextBlock.height / 2, u4 = h4.indexLabelTextBlock.x + h4.indexLabelTextBlock.width, D = h4.indexLabelTextBlock.y + h4.indexLabelTextBlock.height / 2;
                        q2 = t.indexLabelTextBlock.x + t.indexLabelTextBlock.width < h4.indexLabelTextBlock.x - p2 || q2 > u4 + p2 || n3 > D + p2 || r3 < s2 - p2 ? false : true;
                      }
                      q2 ? (0 > a4 && (a4 = k2), l4 !== a4 && (c4 = l4, d4 += -z2), 0 === k2 % Math.max(m.length / 10, 3) && (f2 = true)) : f2 = true;
                      f2 && (0 < d4 && 0 <= a4 && 0 <= c4) && (L(d4, a4, c4), c4 = a4 = -1, d4 = 0);
                    }
                  }
                0 < d4 && L(d4, a4, c4);
              })();
            }
          }
          function h2() {
            n2.plotArea.layoutManager.reset();
            n2.title && (n2.title.dockInsidePlotArea || "center" === n2.title.horizontalAlign && "center" === n2.title.verticalAlign) && n2.title.render();
            if (n2.subtitles)
              for (var a3 = 0; a3 < n2.subtitles.length; a3++) {
                var b2 = n2.subtitles[a3];
                (b2.dockInsidePlotArea || "center" === b2.horizontalAlign && "center" === b2.verticalAlign) && b2.render();
              }
            n2.legend && (n2.legend.dockInsidePlotArea || "center" === n2.legend.horizontalAlign && "center" === n2.legend.verticalAlign) && (n2.legend.setLayout(), n2.legend.render());
          }
          var n2 = this;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            var k = this.data[a2.dataSeriesIndexes[0]], m = k.dataPoints, p2 = 10, q = this.plotArea, g = k.dataPointEOs, s = 2, w2, v3 = 1.3, u2 = 20 / 180 * Math.PI, y = 6, x = { x: (q.x2 + q.x1) / 2, y: (q.y2 + q.y1) / 2 }, z = 0;
            a2 = false;
            for (var A2 = 0; A2 < m.length; A2++)
              z += Math.abs(m[A2].y), !a2 && ("undefined" !== typeof m[A2].indexLabel && null !== m[A2].indexLabel && 0 < m[A2].indexLabel.toString().length) && (a2 = true), !a2 && ("undefined" !== typeof m[A2].label && null !== m[A2].label && 0 < m[A2].label.toString().length) && (a2 = true);
            if (0 !== z) {
              a2 = a2 || "undefined" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;
              var C2 = "inside" !== k.indexLabelPlacement && a2 ? 0.75 * Math.min(q.width, q.height) / 2 : 0.92 * Math.min(q.width, q.height) / 2;
              k.radius && (C2 = Ta(k.radius, C2));
              var B3 = "undefined" !== typeof k.innerRadius && null !== k.innerRadius ? Ta(k.innerRadius, C2) : 0.7 * C2;
              k.radius = C2;
              "doughnut" === k.type && (k.innerRadius = B3);
              var E = Math.min(B3 / C2, (C2 - 1) / C2);
              this.pieDoughnutClickHandler = function(a3) {
                n2.isAnimating || !r(a3.dataSeries.explodeOnClick) && !a3.dataSeries.explodeOnClick || (a3 = a3.dataPoint, a3.exploded = a3.exploded ? false : true, 1 < this.dataPoints.length && n2._animator.animate(0, 500, function(a4) {
                  c2(a4);
                  h2();
                  n2.dispatchEvent("dataAnimationIterationEnd", { chart: n2 });
                  n2.dispatchEvent("dataAnimationEnd", { chart: n2 });
                }));
              };
              d2();
              l2();
              l2();
              l2();
              l2();
              this.disableToolTip = true;
              this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function(a3) {
                var b2 = n2.plotArea.ctx;
                b2.clearRect(q.x1, q.y1, q.width, q.height);
                b2.fillStyle = n2.backgroundColor;
                b2.fillRect(q.x1, q.y1, q.width, q.height);
                for (var b2 = g[0].startAngle + 2 * Math.PI * a3, c3 = 0; c3 < m.length; c3++) {
                  var d3 = 0 === c3 ? g[c3].startAngle : e2, e2 = d3 + (g[c3].endAngle - g[c3].startAngle), f2 = false;
                  e2 > b2 && (e2 = b2, f2 = true);
                  var l3 = m[c3].color ? m[c3].color : k._colorSet[c3 % k._colorSet.length];
                  e2 > d3 && W2(n2.plotArea.ctx, g[c3].center, g[c3].radius, l3, k.type, d3, e2, k.fillOpacity, g[c3].percentInnerRadius);
                  if (f2)
                    break;
                }
                h2();
                n2.dispatchEvent(
                  "dataAnimationIterationEnd",
                  { chart: n2 }
                );
                1 <= a3 && n2.dispatchEvent("dataAnimationEnd", { chart: n2 });
              }, function() {
                n2.disableToolTip = false;
                n2._animator.animate(0, n2.animatedRender ? 500 : 0, function(a3) {
                  c2(a3);
                  h2();
                  n2.dispatchEvent("dataAnimationIterationEnd", { chart: n2 });
                });
                n2.dispatchEvent("dataAnimationEnd", { chart: n2 });
              });
            }
          }
        };
        var oa2 = function(a2, d2, c2, b) {
          "undefined" === typeof c2 && (c2 = 1);
          0 >= Math.round(d2.y4 - d2.y1) || (a2.save(), a2.globalAlpha = c2, a2.beginPath(), a2.moveTo(Math.round(d2.x1), Math.round(d2.y1)), a2.lineTo(Math.round(d2.x2), Math.round(d2.y2)), a2.lineTo(
            Math.round(d2.x3),
            Math.round(d2.y3)
          ), a2.lineTo(Math.round(d2.x4), Math.round(d2.y4)), "undefined" !== d2.x5 && (a2.lineTo(Math.round(d2.x5), Math.round(d2.y5)), a2.lineTo(Math.round(d2.x6), Math.round(d2.y6))), a2.closePath(), a2.fillStyle = b ? b : d2.color, a2.fill(), a2.globalAplha = 1, a2.restore());
        };
        n.prototype.renderFunnel = function(a2) {
          function d2() {
            for (var a3 = 0, b2 = [], c3 = 0; c3 < y.length; c3++) {
              if ("undefined" === typeof y[c3].y)
                return -1;
              y[c3].y = "number" === typeof y[c3].y ? y[c3].y : 0;
              a3 += Math.abs(y[c3].y);
            }
            if (0 === a3)
              return -1;
            for (c3 = b2[0] = 0; c3 < y.length; c3++)
              b2.push(Math.abs(y[c3].y) * E / a3);
            return b2;
          }
          function c2() {
            var a3 = X2, b2 = Z3, c3 = L, d3 = $2, e2, f2;
            e2 = P2;
            f2 = R3 - O2;
            d3 = Math.abs((f2 - e2) * (b2 - a3 + (d3 - c3)) / 2);
            c3 = $2 - L;
            e2 = f2 - e2;
            f2 = c3 * (f2 - R3);
            f2 = Math.abs(f2);
            f2 = d3 + f2;
            for (var d3 = [], g2 = 0, k2 = 0; k2 < y.length; k2++) {
              if ("undefined" === typeof y[k2].y)
                return -1;
              y[k2].y = "number" === typeof y[k2].y ? y[k2].y : 0;
              g2 += Math.abs(y[k2].y);
            }
            if (0 === g2)
              return -1;
            for (var l3 = d3[0] = 0, h3 = 0, m2, p3, b2 = b2 - a3, l3 = false, k2 = 0; k2 < y.length; k2++)
              a3 = Math.abs(y[k2].y) * f2 / g2, l3 ? m2 = 0 == Number(c3.toFixed(3)) ? 0 : a3 / c3 : (p3 = ba2 * ba2 * b2 * b2 - 4 * Math.abs(ba2) * a3, 0 > p3 ? (p3 = c3, l3 = (b2 + p3) * (e2 - h3) / 2, a3 -= l3, m2 = e2 - h3, h3 += e2 - h3, m2 += 0 == p3 ? 0 : a3 / p3, h3 += a3 / p3, l3 = true) : (m2 = (Math.abs(ba2) * b2 - Math.sqrt(p3)) / 2, p3 = b2 - 2 * m2 / Math.abs(ba2), h3 += m2, h3 > e2 && (h3 -= m2, p3 = c3, l3 = (b2 + p3) * (e2 - h3) / 2, a3 -= l3, m2 = e2 - h3, h3 += e2 - h3, m2 += a3 / p3, h3 += a3 / p3, l3 = true), b2 = p3)), d3.push(m2);
            return d3;
          }
          function b() {
            if (u2 && y) {
              for (var a3, b2, c3, d3, e2, f2, k2, l3, h3, m2, p3, q2, t, n3, s2, D = [], x2 = [], v4 = { percent: null, total: null }, z2 = null, C3 = 0; C3 < y.length; C3++)
                s2 = Q[C3], s2 = "undefined" !== typeof s2.x5 ? (s2.y2 + s2.y4) / 2 : (s2.y2 + s2.y3) / 2, s2 = g(s2).x2 + 1, D[C3] = K2 - s2 - S2;
              s2 = 0.5 * S2;
              for (var C3 = 0, B4 = y.length - 1; C3 < y.length || 0 <= B4; C3++, B4--) {
                b2 = u2.reversed ? y[B4] : y[C3];
                a3 = b2.color ? b2.color : u2.reversed ? u2._colorSet[(y.length - 1 - C3) % u2._colorSet.length] : u2._colorSet[C3 % u2._colorSet.length];
                c3 = b2.indexLabelPlacement || u2.indexLabelPlacement || "outside";
                n3 = b2.indexLabelTextAlign || u2.indexLabelTextAlign || "left";
                d3 = b2.indexLabelBackgroundColor || u2.indexLabelBackgroundColor || (w ? "transparent" : null);
                e2 = b2.indexLabelFontColor || u2.indexLabelFontColor || "#979797";
                f2 = r(b2.indexLabelFontSize) ? u2.indexLabelFontSize : b2.indexLabelFontSize;
                k2 = b2.indexLabelFontStyle || u2.indexLabelFontStyle || "normal";
                l3 = b2.indexLabelFontFamily || u2.indexLabelFontFamily || "arial";
                h3 = b2.indexLabelFontWeight || u2.indexLabelFontWeight || "normal";
                a3 = b2.indexLabelLineColor || u2.options.indexLabelLineColor || a3;
                m2 = "number" === typeof b2.indexLabelLineThickness ? b2.indexLabelLineThickness : "number" === typeof u2.indexLabelLineThickness ? u2.indexLabelLineThickness : 2;
                p3 = b2.indexLabelLineDashType || u2.indexLabelLineDashType || "solid";
                q2 = "undefined" !== typeof b2.indexLabelWrap ? b2.indexLabelWrap : "undefined" !== typeof u2.indexLabelWrap ? u2.indexLabelWrap : true;
                t = u2.dataPointIds[C3];
                A2._eventManager.objectMap[t] = {
                  id: t,
                  objectType: "dataPoint",
                  dataPointIndex: C3,
                  dataSeriesIndex: 0,
                  funnelSection: Q[u2.reversed ? y.length - 1 - C3 : C3]
                };
                "inside" === u2.indexLabelPlacement && (D[C3] = C3 !== da3 ? u2.reversed ? Q[C3].x2 - Q[C3].x1 : Q[C3].x3 - Q[C3].x4 : Q[C3].x3 - Q[C3].x6, 20 > D[C3] && (D[C3] = C3 !== da3 ? u2.reversed ? Q[C3].x3 - Q[C3].x4 : Q[C3].x2 - Q[C3].x1 : Q[C3].x2 - Q[C3].x1, D[C3] /= 2));
                t = b2.indexLabelMaxWidth ? b2.indexLabelMaxWidth : u2.options.indexLabelMaxWidth ? u2.indexLabelMaxWidth : D[C3];
                if (t > D[C3] || 0 > t)
                  t = D[C3];
                x2[C3] = "inside" === u2.indexLabelPlacement ? Q[C3].height : false;
                v4 = A2.getPercentAndTotal(u2, b2);
                if (u2.indexLabelFormatter || b2.indexLabelFormatter)
                  z2 = { chart: A2.options, dataSeries: u2, dataPoint: b2, total: v4.total, percent: v4.percent };
                b2 = b2.indexLabelFormatter ? b2.indexLabelFormatter(z2) : b2.indexLabel ? A2.replaceKeywordsWithValue(b2.indexLabel, b2, u2, C3) : u2.indexLabelFormatter ? u2.indexLabelFormatter(z2) : u2.indexLabel ? A2.replaceKeywordsWithValue(u2.indexLabel, b2, u2, C3) : b2.label ? b2.label : "";
                0 >= m2 && (m2 = 0);
                1e3 > t && 1e3 - t < s2 && (t += 1e3 - t);
                U2.roundRect || Da(U2);
                c3 = new ka(U2, { fontSize: f2, fontFamily: l3, fontColor: e2, fontStyle: k2, fontWeight: h3, horizontalAlign: c3, textAlign: n3, backgroundColor: d3, maxWidth: t, maxHeight: false === x2[C3] ? q2 ? 4.28571429 * f2 : 1.5 * f2 : x2[C3], text: b2, padding: ea3 });
                c3.measureText();
                H.push({ textBlock: c3, id: u2.reversed ? B4 : C3, isDirty: false, lineColor: a3, lineThickness: m2, lineDashType: p3, height: c3.height < c3.maxHeight ? c3.height : c3.maxHeight, width: c3.width < c3.maxWidth ? c3.width : c3.maxWidth });
              }
            }
          }
          function e() {
            var a3, b2, c3, d3, e2, f2 = [];
            e2 = false;
            c3 = 0;
            for (var g2, k2 = K2 - Z3 - S2 / 2, k2 = u2.options.indexLabelMaxWidth ? u2.indexLabelMaxWidth > k2 ? k2 : u2.indexLabelMaxWidth : k2, l3 = H.length - 1; 0 <= l3; l3--) {
              g2 = y[H[l3].id];
              c3 = H[l3];
              d3 = c3.textBlock;
              b2 = (a3 = q(l3) < Q.length ? H[q(l3)] : null) ? a3.textBlock : null;
              c3 = c3.height;
              a3 && d3.y + c3 + ea3 > b2.y && (e2 = true);
              c3 = g2.indexLabelMaxWidth || k2;
              if (c3 > k2 || 0 > c3)
                c3 = k2;
              f2.push(c3);
            }
            if (e2)
              for (l3 = H.length - 1; 0 <= l3; l3--)
                a3 = Q[l3], H[l3].textBlock.maxWidth = f2[f2.length - (l3 + 1)], H[l3].textBlock.measureText(), H[l3].textBlock.x = K2 - k2, c3 = H[l3].textBlock.height < H[l3].textBlock.maxHeight ? H[l3].textBlock.height : H[l3].textBlock.maxHeight, e2 = H[l3].textBlock.width < H[l3].textBlock.maxWidth ? H[l3].textBlock.width : H[l3].textBlock.maxWidth, H[l3].height = c3, H[l3].width = e2, c3 = "undefined" !== typeof a3.x5 ? (a3.y2 + a3.y4) / 2 : (a3.y2 + a3.y3) / 2, H[l3].textBlock.y = c3 - H[l3].height / 2, u2.reversed ? (H[l3].textBlock.y + H[l3].height > V3 + z && (H[l3].textBlock.y = V3 + z - H[l3].height), H[l3].textBlock.y < qa - z && (H[l3].textBlock.y = qa - z)) : (H[l3].textBlock.y < V3 - z && (H[l3].textBlock.y = V3 - z), H[l3].textBlock.y + H[l3].height > qa + z && (H[l3].textBlock.y = qa + z - H[l3].height));
          }
          function f() {
            var a3, b2, c3, d3;
            if ("inside" !== u2.indexLabelPlacement)
              for (var e2 = 0; e2 < Q.length; e2++)
                0 == H[e2].textBlock.text.length ? H[e2].isDirty = true : (a3 = Q[e2], c3 = "undefined" !== typeof a3.x5 ? (a3.y2 + a3.y4) / 2 : (a3.y2 + a3.y3) / 2, b2 = u2.reversed ? "undefined" !== typeof a3.x5 ? c3 > Ca ? g(c3).x2 + 1 : (a3.x2 + a3.x3) / 2 + 1 : (a3.x2 + a3.x3) / 2 + 1 : "undefined" !== typeof a3.x5 ? c3 < Ca ? g(c3).x2 + 1 : (a3.x4 + a3.x3) / 2 + 1 : (a3.x2 + a3.x3) / 2 + 1, H[e2].textBlock.x = b2 + S2, H[e2].textBlock.y = c3 - H[e2].height / 2, u2.reversed ? (H[e2].textBlock.y + H[e2].height > V3 + z && (H[e2].textBlock.y = V3 + z - H[e2].height), H[e2].textBlock.y < qa - z && (H[e2].textBlock.y = qa - z)) : (H[e2].textBlock.y < V3 - z && (H[e2].textBlock.y = V3 - z), H[e2].textBlock.y + H[e2].height > qa + z && (H[e2].textBlock.y = qa + z - H[e2].height)));
            else
              for (e2 = 0; e2 < Q.length; e2++)
                0 == H[e2].textBlock.text.length ? H[e2].isDirty = true : (a3 = Q[e2], b2 = a3.height, c3 = H[e2].height, d3 = H[e2].width, b2 >= c3 ? (b2 = e2 != da3 ? (a3.x4 + a3.x3) / 2 - d3 / 2 : (a3.x5 + a3.x4) / 2 - d3 / 2, c3 = e2 != da3 ? (a3.y1 + a3.y3) / 2 - c3 / 2 : (a3.y1 + a3.y4) / 2 - c3 / 2, H[e2].textBlock.x = b2, H[e2].textBlock.y = c3) : H[e2].isDirty = true);
          }
          function l2() {
            function a3(b3, c4) {
              var d4;
              if (0 > b3 || b3 >= H.length)
                return 0;
              var e3, f3 = H[b3].textBlock;
              if (0 > c4) {
                c4 *= -1;
                e3 = p2(b3);
                d4 = h2(e3, b3);
                if (d4 >= c4)
                  return f3.y -= c4, c4;
                if (0 == b3)
                  return 0 < d4 && (f3.y -= d4), d4;
                d4 += a3(e3, -(c4 - d4));
                0 < d4 && (f3.y -= d4);
                return d4;
              }
              e3 = q(b3);
              d4 = h2(b3, e3);
              if (d4 >= c4)
                return f3.y += c4, c4;
              if (b3 == Q.length - 1)
                return 0 < d4 && (f3.y += d4), d4;
              d4 += a3(e3, c4 - d4);
              0 < d4 && (f3.y += d4);
              return d4;
            }
            function b2() {
              var a4, d4, e3, f3, g3 = 0, k3;
              f3 = (R3 - P2 + 2 * z) / m2;
              k3 = m2;
              for (var l4, h3 = 1; h3 < k3; h3++) {
                e3 = h3 * f3;
                for (var t = H.length - 1; 0 <= t; t--)
                  !H[t].isDirty && (H[t].textBlock.y < e3 && H[t].textBlock.y + H[t].height > e3) && (l4 = q(t), !(l4 >= H.length - 1) && H[t].textBlock.y + H[t].height + ea3 > H[l4].textBlock.y && (H[t].textBlock.y = H[t].textBlock.y + H[t].height - e3 > e3 - H[t].textBlock.y ? e3 + 1 : e3 - H[t].height - 1));
              }
              for (l4 = Q.length - 1; 0 < l4; l4--)
                if (!H[l4].isDirty) {
                  e3 = p2(l4);
                  if (0 > e3 && (e3 = 0, H[e3].isDirty))
                    break;
                  if (H[l4].textBlock.y < H[e3].textBlock.y + H[e3].height) {
                    d4 = d4 || l4;
                    f3 = l4;
                    for (k3 = 0; H[f3].textBlock.y < H[e3].textBlock.y + H[e3].height + ea3; ) {
                      a4 = a4 || H[f3].textBlock.y + H[f3].height;
                      k3 += H[f3].height;
                      k3 += ea3;
                      f3 = e3;
                      if (0 >= f3) {
                        f3 = 0;
                        k3 += H[f3].height;
                        break;
                      }
                      e3 = p2(f3);
                      if (0 > e3) {
                        f3 = 0;
                        k3 += H[f3].height;
                        break;
                      }
                    }
                    if (f3 != l4) {
                      g3 = H[f3].textBlock.y;
                      a4 -= g3;
                      a4 = k3 - a4;
                      g3 = c3(a4, d4, f3);
                      break;
                    }
                  }
                }
              return g3;
            }
            function c3(a4, b3, d4) {
              var e3 = [], f3 = 0, g3 = 0;
              for (a4 = Math.abs(a4); d4 <= b3; d4++)
                e3.push(Q[d4]);
              e3.sort(function(a5, b4) {
                return a5.height - b4.height;
              });
              for (d4 = 0; d4 < e3.length; d4++)
                if (b3 = e3[d4], f3 < a4)
                  g3++, f3 += H[b3.id].height + ea3, H[b3.id].textBlock.text = "", H[b3.id].indexLabelText = "", H[b3.id].isDirty = true, H[b3.id].textBlock.measureText();
                else
                  break;
              return g3;
            }
            for (var d3, e2, f2, g2, k2, l3, m2 = 1, n3 = 0; n3 < 2 * m2; n3++) {
              for (var s2 = H.length - 1; 0 <= s2 && !(0 <= p2(s2) && p2(s2), f2 = H[s2], g2 = f2.textBlock, l3 = (k2 = q(s2) < Q.length ? H[q(s2)] : null) ? k2.textBlock : null, d3 = +f2.height.toFixed(6), e2 = +g2.y.toFixed(6), !f2.isDirty && (k2 && e2 + d3 + ea3 > +l3.y.toFixed(6)) && (d3 = g2.y + d3 + ea3 - l3.y, e2 = a3(s2, -d3), e2 < d3 && (0 < e2 && (d3 -= e2), e2 = a3(q(s2), d3), e2 != d3))); s2--)
                ;
              b2();
            }
          }
          function h2(a3, b2) {
            return (b2 < Q.length ? H[b2].textBlock.y : u2.reversed ? V3 + z : qa + z) - (0 > a3 ? u2.reversed ? qa - z : V3 - z : H[a3].textBlock.y + H[a3].height + ea3);
          }
          function n2(a3, b2, c3) {
            var d3, e2, g2, l3 = [], h3 = z, p3 = [];
            -1 !== b2 && (0 <= W3.indexOf(b2) ? (e2 = W3.indexOf(b2), W3.splice(e2, 1)) : (W3.push(b2), W3 = W3.sort(function(a4, b3) {
              return a4 - b3;
            })));
            if (0 === W3.length)
              l3 = ia2;
            else {
              e2 = z * (1 != W3.length || 0 != W3[0] && W3[0] != Q.length - 1 ? 2 : 1) / k();
              for (var q2 = 0; q2 < Q.length; q2++) {
                if (1 == W3.length && 0 == W3[0]) {
                  if (0 === q2) {
                    l3.push(ia2[q2]);
                    d3 = h3;
                    continue;
                  }
                } else
                  0 === q2 && (d3 = -1 * h3);
                l3.push(ia2[q2] + d3);
                if (0 <= W3.indexOf(q2) || q2 < Q.length && 0 <= W3.indexOf(q2 + 1))
                  d3 += e2;
              }
            }
            g2 = function() {
              for (var a4 = [], b3 = 0; b3 < Q.length; b3++)
                a4.push(l3[b3] - Q[b3].y1);
              return a4;
            }();
            var t = {
              startTime: new Date().getTime(),
              duration: c3 || 500,
              easingFunction: function(a4, b3, c4, d4) {
                return N.easing.easeOutQuart(a4, b3, c4, d4);
              },
              changeSection: function(a4) {
                for (var b3, c4, d4 = 0; d4 < Q.length; d4++)
                  b3 = g2[d4], c4 = Q[d4], b3 *= a4, "undefined" === typeof p3[d4] && (p3[d4] = 0), 0 > p3 && (p3 *= -1), c4.y1 += b3 - p3[d4], c4.y2 += b3 - p3[d4], c4.y3 += b3 - p3[d4], c4.y4 += b3 - p3[d4], c4.y5 && (c4.y5 += b3 - p3[d4], c4.y6 += b3 - p3[d4]), p3[d4] = b3;
              }
            };
            a3._animator.animate(0, c3, function(c4) {
              var d4 = a3.plotArea.ctx || a3.ctx;
              ja3 = true;
              d4.clearRect(x.x1, x.y1, x.x2 - x.x1, x.y2 - x.y1);
              d4.fillStyle = a3.backgroundColor;
              d4.fillRect(x.x1, x.y1, x.width, x.height);
              t.changeSection(
                c4,
                b2
              );
              var e3 = {};
              e3.dataSeries = u2;
              e3.dataPoint = u2.reversed ? u2.dataPoints[y.length - 1 - b2] : u2.dataPoints[b2];
              e3.index = u2.reversed ? y.length - 1 - b2 : b2;
              a3.toolTip.highlightObjects([e3]);
              for (e3 = 0; e3 < Q.length; e3++)
                oa2(d4, Q[e3], u2.fillOpacity);
              v3(d4);
              M && ("inside" !== u2.indexLabelPlacement ? m(d4) : f(), s(d4));
              1 <= c4 && (ja3 = false);
            }, null, N.easing.easeOutQuart);
          }
          function k() {
            for (var a3 = 0, b2 = 0; b2 < Q.length - 1; b2++)
              (0 <= W3.indexOf(b2) || 0 <= W3.indexOf(b2 + 1)) && a3++;
            return a3;
          }
          function m(a3) {
            for (var b2, c3, d3, e2, f2 = 0; f2 < Q.length; f2++)
              e2 = 1 === H[f2].lineThickness % 2 ? 0.5 : 0, c3 = ((Q[f2].y2 + Q[f2].y4) / 2 << 0) + e2, b2 = g(c3).x2 - 1, d3 = H[f2].textBlock.x, e2 = (H[f2].textBlock.y + H[f2].height / 2 << 0) + e2, H[f2].isDirty || 0 == H[f2].lineThickness || (a3.strokeStyle = H[f2].lineColor, a3.lineWidth = H[f2].lineThickness, a3.setLineDash && a3.setLineDash(J(H[f2].lineDashType, H[f2].lineThickness)), a3.beginPath(), a3.moveTo(b2, c3), a3.lineTo(d3, e2), a3.stroke());
          }
          function p2(a3) {
            for (a3 -= 1; -1 <= a3 && -1 != a3 && H[a3].isDirty; a3--)
              ;
            return a3;
          }
          function q(a3) {
            for (a3 += 1; a3 <= Q.length && a3 != Q.length && H[a3].isDirty; a3++)
              ;
            return a3;
          }
          function g(a3) {
            for (var b2, c3 = 0; c3 < y.length; c3++)
              if (Q[c3].y1 < a3 && Q[c3].y4 > a3) {
                b2 = Q[c3];
                break;
              }
            return b2 ? (a3 = b2.y6 ? a3 > b2.y6 ? b2.x3 + (b2.x4 - b2.x3) / (b2.y4 - b2.y3) * (a3 - b2.y3) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a3 - b2.y2) : b2.x2 + (b2.x3 - b2.x2) / (b2.y3 - b2.y2) * (a3 - b2.y2), { x1: a3, x2: a3 }) : -1;
          }
          function s(a3) {
            for (var b2 = 0; b2 < Q.length; b2++)
              H[b2].isDirty || (a3 && (H[b2].textBlock.ctx = a3), H[b2].textBlock.render(true));
          }
          function v3(a3) {
            A2.plotArea.layoutManager.reset();
            a3.roundRect || Da(a3);
            A2.title && (A2.title.dockInsidePlotArea || "center" === A2.title.horizontalAlign && "center" === A2.title.verticalAlign) && (A2.title.ctx = a3, A2.title.render());
            if (A2.subtitles)
              for (var b2 = 0; b2 < A2.subtitles.length; b2++) {
                var c3 = A2.subtitles[b2];
                if (c3.dockInsidePlotArea || "center" === c3.horizontalAlign && "center" === c3.verticalAlign)
                  A2.subtitles.ctx = a3, c3.render();
              }
            A2.legend && (A2.legend.dockInsidePlotArea || "center" === A2.legend.horizontalAlign && "center" === A2.legend.verticalAlign) && (A2.legend.ctx = a3, A2.legend.setLayout(), A2.legend.render());
            ta.fNg && ta.fNg(A2);
          }
          var A2 = this;
          if (!(0 >= a2.dataSeriesIndexes.length)) {
            for (var u2 = this.data[a2.dataSeriesIndexes[0]], y = u2.dataPoints, x = this.plotArea, z = 0.025 * x.width, B3 = 0.01 * x.width, C2 = 0, E = x.height - 2 * z, I2 = Math.min(x.width - 2 * B3, 2.8 * x.height), M = false, T = 0; T < y.length; T++)
              if (!M && ("undefined" !== typeof y[T].indexLabel && null !== y[T].indexLabel && 0 < y[T].indexLabel.toString().length) && (M = true), !M && ("undefined" !== typeof y[T].label && null !== y[T].label && 0 < y[T].label.toString().length) && (M = true), !M && "function" === typeof u2.indexLabelFormatter || "function" === typeof y[T].indexLabelFormatter)
                M = true;
            M = M || "undefined" !== typeof u2.indexLabel && null !== u2.indexLabel && 0 < u2.indexLabel.toString().length;
            "inside" !== u2.indexLabelPlacement && M || (B3 = (x.width - 0.75 * I2) / 2);
            var T = x.x1 + B3, K2 = x.x2 - B3, P2 = x.y1 + z, R3 = x.y2 - z, U2 = a2.targetCanvasCtx || this.plotArea.ctx || this.ctx;
            if (0 != u2.length && (u2.dataPoints && u2.visible) && 0 !== y.length) {
              var O2, F;
              a2 = 75 * I2 / 100;
              var S2 = 30 * (K2 - a2) / 100;
              "funnel" === u2.type ? (O2 = r(u2.options.neckHeight) ? 0.35 * E : u2.neckHeight, F = r(u2.options.neckWidth) ? 0.25 * a2 : u2.neckWidth, "string" === typeof O2 && O2.match(/%$/) ? (O2 = parseInt(O2), O2 = O2 * E / 100) : O2 = parseInt(O2), "string" === typeof F && F.match(/%$/) ? (F = parseInt(F), F = F * a2 / 100) : F = parseInt(F), O2 > E ? O2 = E : 0 >= O2 && (O2 = 0), F > a2 ? F = a2 - 0.5 : 0 >= F && (F = 0)) : "pyramid" === u2.type && (F = O2 = 0, u2.reversed = u2.reversed ? false : true);
              var B3 = T + a2 / 2, X2 = T, Z3 = T + a2, V3 = u2.reversed ? R3 : P2, L = B3 - F / 2, $2 = B3 + F / 2, Ca = u2.reversed ? P2 + O2 : R3 - O2, qa = u2.reversed ? P2 : R3;
              a2 = [];
              var B3 = [], Q = [], I2 = [], Y3 = P2, da3, ba2 = (Ca - V3) / (L - X2), fa2 = -ba2, T = "area" === (u2.valueRepresents ? u2.valueRepresents : "height") ? c2() : d2();
              if (-1 !== T) {
                if (u2.reversed)
                  for (I2.push(Y3), F = T.length - 1; 0 < F; F--)
                    Y3 += T[F], I2.push(Y3);
                else
                  for (F = 0; F < T.length; F++)
                    Y3 += T[F], I2.push(Y3);
                if (u2.reversed)
                  for (F = 0; F < T.length; F++)
                    I2[F] < Ca ? (a2.push(L), B3.push($2), da3 = F) : (a2.push((I2[F] - V3 + ba2 * X2) / ba2), B3.push((I2[F] - V3 + fa2 * Z3) / fa2));
                else
                  for (F = 0; F < T.length; F++)
                    I2[F] < Ca ? (a2.push((I2[F] - V3 + ba2 * X2) / ba2), B3.push((I2[F] - V3 + fa2 * Z3) / fa2), da3 = F) : (a2.push(L), B3.push($2));
                for (F = 0; F < T.length - 1; F++)
                  Y3 = u2.reversed ? y[y.length - 1 - F].color ? y[y.length - 1 - F].color : u2._colorSet[(y.length - 1 - F) % u2._colorSet.length] : y[F].color ? y[F].color : u2._colorSet[F % u2._colorSet.length], F === da3 ? Q.push({ x1: a2[F], y1: I2[F], x2: B3[F], y2: I2[F], x3: $2, y3: Ca, x4: B3[F + 1], y4: I2[F + 1], x5: a2[F + 1], y5: I2[F + 1], x6: L, y6: Ca, id: F, height: I2[F + 1] - I2[F], color: Y3 }) : Q.push({
                    x1: a2[F],
                    y1: I2[F],
                    x2: B3[F],
                    y2: I2[F],
                    x3: B3[F + 1],
                    y3: I2[F + 1],
                    x4: a2[F + 1],
                    y4: I2[F + 1],
                    id: F,
                    height: I2[F + 1] - I2[F],
                    color: Y3
                  });
                var ea3 = 2, H = [], ja3 = false, W3 = [], ia2 = [], T = false;
                a2 = a2 = 0;
                Ea(W3);
                for (F = 0; F < y.length; F++)
                  y[F].exploded && (T = true, u2.reversed ? W3.push(y.length - 1 - F) : W3.push(F));
                U2.clearRect(x.x1, x.y1, x.width, x.height);
                U2.fillStyle = A2.backgroundColor;
                U2.fillRect(x.x1, x.y1, x.width, x.height);
                if (M && u2.visible && (b(), f(), e(), "inside" !== u2.indexLabelPlacement)) {
                  l2();
                  for (F = 0; F < y.length; F++)
                    H[F].isDirty || (a2 = H[F].textBlock.x + H[F].width, a2 = (K2 - a2) / 2, 0 == F && (C2 = a2), C2 > a2 && (C2 = a2));
                  for (F = 0; F < Q.length; F++)
                    Q[F].x1 += C2, Q[F].x2 += C2, Q[F].x3 += C2, Q[F].x4 += C2, Q[F].x5 && (Q[F].x5 += C2, Q[F].x6 += C2), H[F].textBlock.x += C2;
                }
                for (F = 0; F < Q.length; F++)
                  C2 = Q[F], oa2(U2, C2, u2.fillOpacity), ia2.push(C2.y1);
                v3(U2);
                M && u2.visible && ("inside" === u2.indexLabelPlacement || A2.animationEnabled || m(U2), A2.animationEnabled || s());
                if (!M)
                  for (F = 0; F < y.length; F++)
                    C2 = u2.dataPointIds[F], a2 = { id: C2, objectType: "dataPoint", dataPointIndex: F, dataSeriesIndex: 0, funnelSection: Q[u2.reversed ? y.length - 1 - F : F] }, A2._eventManager.objectMap[C2] = a2;
                !A2.animationEnabled && T ? n2(
                  A2,
                  -1,
                  0
                ) : A2.animationEnabled && !A2.animatedRender && n2(A2, -1, 0);
                this.funnelPyramidClickHandler = function(a3) {
                  var b2 = -1;
                  if (!ja3 && !A2.isAnimating && (r(a3.dataSeries.explodeOnClick) || a3.dataSeries.explodeOnClick) && (b2 = u2.reversed ? y.length - 1 - a3.dataPointIndex : a3.dataPointIndex, 0 <= b2)) {
                    a3 = b2;
                    if ("funnel" === u2.type || "pyramid" === u2.type)
                      u2.reversed ? y[y.length - 1 - a3].exploded = y[y.length - 1 - a3].exploded ? false : true : y[a3].exploded = y[a3].exploded ? false : true;
                    n2(A2, b2, 500);
                  }
                };
                return { source: U2, dest: this.plotArea.ctx, animationCallback: function(a3, b2) {
                  N.fadeInAnimation(
                    a3,
                    b2
                  );
                  1 <= a3 && (n2(A2, -1, 500), v3(A2.plotArea.ctx || A2.ctx));
                }, easingFunction: N.easing.easeInQuad, animationBase: 0 };
              }
            }
          }
        };
        n.prototype.requestAnimFrame = function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a2) {
            window.setTimeout(a2, 1e3 / 60);
          };
        }();
        n.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
        n.prototype.set = function(a2, d2, c2) {
          c2 = "undefined" === typeof c2 ? true : c2;
          "options" === a2 ? (this.options = d2, c2 && this.render()) : n.base.set.call(this, a2, d2, c2);
        };
        n.prototype.exportChart = function(a2) {
          a2 = "undefined" === typeof a2 ? {} : a2;
          var d2 = a2.format ? a2.format : "png", c2 = a2.fileName ? a2.fileName : this.exportFileName;
          if (a2.toDataURL)
            return this.canvas.toDataURL("image/" + d2);
          var b = this.canvas;
          if (b && d2 && c2) {
            c2 = c2 + "." + d2;
            a2 = "image/" + d2;
            var b = b.toDataURL(a2), e = false, f = document.createElement("a");
            f.download = c2;
            f.href = b;
            if ("undefined" !== typeof Blob && new Blob()) {
              for (var l2 = b.replace(/^data:[a-z\/]*;base64,/, ""), l2 = atob(l2), h2 = new ArrayBuffer(l2.length), h2 = new Uint8Array(h2), n2 = 0; n2 < l2.length; n2++)
                h2[n2] = l2.charCodeAt(n2);
              d2 = new Blob([h2.buffer], { type: "image/" + d2 });
              try {
                window.navigator.msSaveBlob(d2, c2), e = true;
              } catch (k) {
                f.dataset.downloadurl = [a2, f.download, f.href].join(":"), f.href = window.URL.createObjectURL(d2);
              }
            }
            if (!e)
              try {
                event = document.createEvent("MouseEvents"), event.initMouseEvent(
                  "click",
                  true,
                  false,
                  window,
                  0,
                  0,
                  0,
                  0,
                  0,
                  false,
                  false,
                  false,
                  false,
                  0,
                  null
                ), f.dispatchEvent ? f.dispatchEvent(event) : f.fireEvent && f.fireEvent("onclick");
              } catch (m) {
                d2 = window.open(), d2.document.write("<img src='" + b + "'></img><div>Please right click on the image and save it to your device</div>"), d2.document.close();
              }
          }
        };
        n.prototype.print = function() {
          var a2 = this.exportChart({ toDataURL: true }), d2 = document.createElement("iframe");
          d2.setAttribute("class", "canvasjs-chart-print-frame");
          S(d2, {
            position: "absolute",
            width: "100%",
            border: "0px",
            margin: "0px 0px 0px 0px",
            padding: "0px 0px 0px 0px"
          });
          d2.style.height = this.height + "px";
          this._canvasJSContainer.appendChild(d2);
          var c2 = this, b = d2.contentWindow || d2.contentDocument.document || d2.contentDocument;
          b.document.open();
          b.document.write('<!DOCTYPE HTML>\n<html><body><img src="' + a2 + '"/><body/></html>');
          b.document.body && b.document.body.style && (b.document.body.style.margin = "0px 0px 0px 0px", b.document.body.style.padding = "0px 0px 0px 0px");
          b.document.close();
          setTimeout(function() {
            b.focus();
            b.print();
            setTimeout(
              function() {
                c2._canvasJSContainer.removeChild(d2);
              },
              1e3
            );
          }, 500);
        };
        n.prototype.getPercentAndTotal = function(a2, d2) {
          var c2 = null, b = null, e = c2 = null;
          if (0 <= a2.type.indexOf("stacked"))
            b = 0, c2 = d2.x.getTime ? d2.x.getTime() : d2.x, c2 in a2.plotUnit.yTotals && (b = a2.plotUnit.yTotals[c2], c2 = a2.plotUnit.yAbsTotals[c2], e = isNaN(d2.y) ? 0 : 0 === c2 ? 0 : 100 * (d2.y / c2));
          else if ("pie" === a2.type || "doughnut" === a2.type || "funnel" === a2.type || "pyramid" === a2.type) {
            for (c2 = b = 0; c2 < a2.dataPoints.length; c2++)
              isNaN(a2.dataPoints[c2].y) || (b += a2.dataPoints[c2].y);
            e = isNaN(d2.y) ? 0 : 100 * (d2.y / b);
          }
          return { percent: e, total: b };
        };
        n.prototype.replaceKeywordsWithValue = function(a2, d2, c2, b, e) {
          var f = this;
          e = "undefined" === typeof e ? 0 : e;
          if ((0 <= c2.type.indexOf("stacked") || "pie" === c2.type || "doughnut" === c2.type || "funnel" === c2.type || "pyramid" === c2.type) && (0 <= a2.indexOf("#percent") || 0 <= a2.indexOf("#total"))) {
            var l2 = "#percent", h2 = "#total", n2 = this.getPercentAndTotal(c2, d2), h2 = isNaN(n2.total) ? h2 : n2.total, l2 = isNaN(n2.percent) ? l2 : n2.percent;
            do {
              n2 = "";
              if (c2.percentFormatString)
                n2 = c2.percentFormatString;
              else {
                var n2 = "#,##0.", k = Math.max(Math.ceil(Math.log(1 / Math.abs(l2)) / Math.LN10), 2);
                if (isNaN(k) || !isFinite(k))
                  k = 2;
                for (var m = 0; m < k; m++)
                  n2 += "#";
                c2.percentFormatString = n2;
              }
              a2 = a2.replace("#percent", fa(l2, n2, f._cultureInfo));
              a2 = a2.replace("#total", fa(h2, c2.yValueFormatString ? c2.yValueFormatString : "#,##0.########", f._cultureInfo));
            } while (0 <= a2.indexOf("#percent") || 0 <= a2.indexOf("#total"));
          }
          return a2.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function(a3) {
            if ('"' === a3[0] && '"' === a3[a3.length - 1] || "'" === a3[0] && "'" === a3[a3.length - 1])
              return a3.slice(1, a3.length - 1);
            a3 = Ha(a3.slice(1, a3.length - 1));
            a3 = a3.replace("#index", e);
            var l3 = null;
            try {
              var g = a3.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
              g && 0 < g.length && (l3 = Ha(g[2]), a3 = Ha(g[1]));
            } catch (k2) {
            }
            g = null;
            if ("color" === a3)
              return "waterfall" === c2.type ? d2.color ? d2.color : 0 < d2.y ? c2.risingColor : c2.fallingColor : "error" === c2.type ? c2.color ? c2.color : c2._colorSet[l3 % c2._colorSet.length] : d2.color ? d2.color : c2.color ? c2.color : c2._colorSet[b % c2._colorSet.length];
            if (d2.hasOwnProperty(a3))
              g = d2;
            else if (c2.hasOwnProperty(a3))
              g = c2;
            else
              return "";
            g = g[a3];
            null !== l3 && (g = g[l3]);
            return "x" === a3 ? (c2.axisX && "dateTime" === c2.axisX.valueType || "dateTime" === c2.xValueType || d2.x && d2.x.getTime) && !c2.axisX.logarithmic ? Aa(g, d2.xValueFormatString ? d2.xValueFormatString : c2.xValueFormatString ? c2.xValueFormatString : c2.xValueFormatString = f.axisX && f.axisX.autoValueFormatString ? f.axisX.autoValueFormatString : "DD MMM YY", f._cultureInfo) : fa(g, d2.xValueFormatString ? d2.xValueFormatString : c2.xValueFormatString ? c2.xValueFormatString : c2.xValueFormatString = "#,##0.########", f._cultureInfo) : "y" === a3 ? fa(g, d2.yValueFormatString ? d2.yValueFormatString : c2.yValueFormatString ? c2.yValueFormatString : c2.yValueFormatString = "#,##0.########", f._cultureInfo) : "z" === a3 ? fa(g, d2.zValueFormatString ? d2.zValueFormatString : c2.zValueFormatString ? c2.zValueFormatString : c2.zValueFormatString = "#,##0.########", f._cultureInfo) : g;
          });
        };
        na(R2, X);
        R2.prototype.setLayout = function() {
          var a2 = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, d2 = a2.layoutManager.getFreeSpace(), c2 = null, b = 0, e = 0, f = 0, l2 = 0, h2 = this.markerMargin = this.chart.options.legend && !r(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;
          this.height = 0;
          var n2 = [], k = [];
          if ("top" === this.verticalAlign || "bottom" === this.verticalAlign)
            this.orientation = "horizontal", c2 = this.verticalAlign, f = this.maxWidth = null !== this.maxWidth ? this.maxWidth : d2.width, l2 = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * d2.height;
          else if ("center" === this.verticalAlign) {
            this.orientation = "vertical";
            if ("left" === this.horizontalAlign || "center" === this.horizontalAlign || "right" === this.horizontalAlign)
              c2 = this.horizontalAlign;
            f = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * d2.width;
            l2 = this.maxHeight = null !== this.maxHeight ? this.maxHeight : d2.height;
          }
          this.errorMarkerColor = [];
          for (var m = 0; m < this.dataSeries.length; m++) {
            var p2 = this.dataSeries[m];
            if (p2.dataPoints && p2.dataPoints.length)
              if ("pie" !== p2.type && "doughnut" !== p2.type && "funnel" !== p2.type && "pyramid" !== p2.type) {
                var q = p2.legendMarkerType = p2.legendMarkerType ? p2.legendMarkerType : "line" !== p2.type && "stepLine" !== p2.type && "spline" !== p2.type && "scatter" !== p2.type && "bubble" !== p2.type || !p2.markerType ? "error" === p2.type && p2._linkedSeries ? p2._linkedSeries.legendMarkerType ? p2._linkedSeries.legendMarkerType : U.getDefaultLegendMarker(p2._linkedSeries.type) : U.getDefaultLegendMarker(p2.type) : p2.markerType, g = p2.legendText ? p2.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: p2, dataPoint: null }) : p2.name, s = p2.legendMarkerColor = p2.legendMarkerColor ? p2.legendMarkerColor : p2.markerColor ? p2.markerColor : "error" === p2.type ? r(p2.whiskerColor) ? p2._colorSet[0] : p2.whiskerColor : p2._colorSet[0], w2 = p2.markerSize || "line" !== p2.type && "stepLine" !== p2.type && "spline" !== p2.type ? 0.75 * this.lineHeight : 0, v3 = p2.legendMarkerBorderColor ? p2.legendMarkerBorderColor : p2.markerBorderColor, u2 = p2.legendMarkerBorderThickness ? p2.legendMarkerBorderThickness : p2.markerBorderThickness ? Math.max(1, Math.round(0.2 * w2)) : 0;
                "error" === p2.type && this.errorMarkerColor.push(s);
                g = this.chart.replaceKeywordsWithValue(g, p2.dataPoints[0], p2, m);
                q = { markerType: q, markerColor: s, text: g, textBlock: null, chartType: p2.type, markerSize: w2, lineColor: p2._colorSet[0], dataSeriesIndex: p2.index, dataPointIndex: null, markerBorderColor: v3, markerBorderThickness: u2 };
                n2.push(q);
              } else
                for (var y = 0; y < p2.dataPoints.length; y++) {
                  var x = p2.dataPoints[y], q = x.legendMarkerType ? x.legendMarkerType : p2.legendMarkerType ? p2.legendMarkerType : U.getDefaultLegendMarker(p2.type), g = x.legendText ? x.legendText : p2.legendText ? p2.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this.options, dataSeries: p2, dataPoint: x }) : x.name ? x.name : "DataPoint: " + (y + 1), s = x.legendMarkerColor ? x.legendMarkerColor : p2.legendMarkerColor ? p2.legendMarkerColor : x.color ? x.color : p2.color ? p2.color : p2._colorSet[y % p2._colorSet.length], w2 = 0.75 * this.lineHeight, v3 = x.legendMarkerBorderColor ? x.legendMarkerBorderColor : p2.legendMarkerBorderColor ? p2.legendMarkerBorderColor : x.markerBorderColor ? x.markerBorderColor : p2.markerBorderColor, u2 = x.legendMarkerBorderThickness ? x.legendMarkerBorderThickness : p2.legendMarkerBorderThickness ? p2.legendMarkerBorderThickness : x.markerBorderThickness || p2.markerBorderThickness ? Math.max(1, Math.round(0.2 * w2)) : 0, g = this.chart.replaceKeywordsWithValue(g, x, p2, y), q = {
                    markerType: q,
                    markerColor: s,
                    text: g,
                    textBlock: null,
                    chartType: p2.type,
                    markerSize: w2,
                    dataSeriesIndex: m,
                    dataPointIndex: y,
                    markerBorderColor: v3,
                    markerBorderThickness: u2
                  };
                  (x.showInLegend || p2.showInLegend && false !== x.showInLegend) && n2.push(q);
                }
          }
          true === this.reversed && n2.reverse();
          if (0 < n2.length) {
            p2 = null;
            s = g = x = y = 0;
            x = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, f) : this.itemMaxWidth = Math.min(this.itemWidth, f) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, f) : this.itemMaxWidth = f;
            w2 = 0 === w2 ? 0.75 * this.lineHeight : w2;
            x -= w2 + h2;
            for (m = 0; m < n2.length; m++) {
              q = n2[m];
              v3 = x;
              if ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType)
                v3 -= 2 * 0.1 * this.lineHeight;
              if (!(0 >= l2 || "undefined" === typeof l2 || 0 >= v3 || "undefined" === typeof v3)) {
                if ("horizontal" === this.orientation) {
                  q.textBlock = new ka(this.ctx, { x: 0, y: 0, maxWidth: v3, maxHeight: this.itemWrap ? l2 : this.lineHeight, angle: 0, text: q.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" });
                  q.textBlock.measureText();
                  null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (w2 + h2 + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)));
                  if (!p2 || p2.width + Math.round(q.textBlock.width + w2 + h2 + (0 === p2.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0)) > f)
                    p2 = { items: [], width: 0 }, k.push(p2), this.height += g, g = 0;
                  g = Math.max(g, q.textBlock.height);
                } else
                  q.textBlock = new ka(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: x,
                    maxHeight: true === this.itemWrap ? l2 : 1.5 * this.fontSize,
                    angle: 0,
                    text: q.text,
                    horizontalAlign: "left",
                    fontSize: this.fontSize,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight,
                    fontColor: this.fontColor,
                    fontStyle: this.fontStyle,
                    textBaseline: "middle"
                  }), q.textBlock.measureText(), null !== this.itemWidth && (q.textBlock.width = this.itemWidth - (w2 + h2 + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < l2 - this.lineHeight ? (p2 = { items: [], width: 0 }, k.push(p2)) : (p2 = k[y], y = (y + 1) % k.length), this.height += q.textBlock.height;
                q.textBlock.x = p2.width;
                q.textBlock.y = 0;
                p2.width += Math.round(q.textBlock.width + w2 + h2 + (0 === p2.width ? 0 : this.horizontalSpacing) + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0));
                p2.items.push(q);
                this.width = Math.max(p2.width, this.width);
                s = q.textBlock.width + (w2 + h2 + ("line" === q.chartType || "spline" === q.chartType || "stepLine" === q.chartType ? 2 * 0.1 * this.lineHeight : 0));
              }
            }
            this.itemWidth = s;
            this.height = false === this.itemWrap ? k.length * this.lineHeight : this.height + g;
            this.height = Math.min(l2, this.height);
            this.width = Math.min(f, this.width);
          }
          "top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d2.x1 : "right" === this.horizontalAlign ? d2.x2 - this.width : d2.x1 + d2.width / 2 - this.width / 2, b = d2.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? d2.x1 : "right" === this.horizontalAlign ? d2.x2 - this.width : d2.x1 + d2.width / 2 - this.width / 2, b = d2.y1 + d2.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? d2.x1 : "right" === this.horizontalAlign ? d2.x2 - this.width : d2.x1 + d2.width / 2 - this.width / 2, b = d2.y2 - this.height);
          this.items = n2;
          for (m = 0; m < this.items.length; m++)
            q = n2[m], q.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[q.id] = { id: q.id, objectType: "legendItem", legendItemIndex: m, dataSeriesIndex: q.dataSeriesIndex, dataPointIndex: q.dataPointIndex };
          this.markerSize = w2;
          this.rows = k;
          0 < n2.length && a2.layoutManager.registerSpace(c2, { width: this.width + 2 + 2, height: this.height + 5 + 5 });
          this.bounds = { x1: e, y1: b, x2: e + this.width, y2: b + this.height };
        };
        R2.prototype.render = function() {
          var a2 = this.bounds.x1, d2 = this.bounds.y1, c2 = this.markerMargin, b = this.maxWidth, e = this.maxHeight, f = this.markerSize, l2 = this.rows;
          (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a2, d2, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
          for (var h2 = 0, n2 = 0; n2 < l2.length; n2++) {
            for (var k = l2[n2], m = 0, p2 = 0; p2 < k.items.length; p2++) {
              var q = k.items[p2], g = q.textBlock.x + a2 + (0 === p2 ? 0.2 * f : this.horizontalSpacing), s = d2 + h2, r2 = g;
              this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(a2, d2, b, Math.max(e - e % this.lineHeight, 0));
              this.ctx.clip();
              if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType)
                this.ctx.strokeStyle = q.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(g - 0.1 * this.lineHeight, s + this.lineHeight / 2), this.ctx.lineTo(g + 0.85 * this.lineHeight, s + this.lineHeight / 2), this.ctx.stroke(), r2 -= 0.1 * this.lineHeight;
              if ("error" === q.chartType) {
                this.ctx.strokeStyle = this.errorMarkerColor[0];
                this.ctx.lineWidth = f / 8;
                this.ctx.beginPath();
                var w2 = g - 0.08 * this.lineHeight + 0.1 * this.lineHeight, u2 = s + 0.15 * this.lineHeight, v3 = 0.7 * this.lineHeight, x = v3 + 0.02 * this.lineHeight;
                this.ctx.moveTo(w2, u2);
                this.ctx.lineTo(w2 + v3, u2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(w2 + v3 / 2, u2);
                this.ctx.lineTo(w2 + v3 / 2, u2 + x);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(w2, u2 + x);
                this.ctx.lineTo(w2 + v3, u2 + x);
                this.ctx.stroke();
                this.errorMarkerColor.shift();
              }
              $.drawMarker(g + f / 2, s + this.lineHeight / 2, this.ctx, q.markerType, "error" === q.chartType || "line" === q.chartType || "spline" === q.chartType ? q.markerSize / 2 : q.markerSize, q.markerColor, q.markerBorderColor, q.markerBorderThickness);
              q.textBlock.x = g + c2 + f;
              if ("line" === q.chartType || "stepLine" === q.chartType || "spline" === q.chartType)
                q.textBlock.x += 0.1 * this.lineHeight;
              q.textBlock.y = Math.round(s + this.lineHeight / 2);
              q.textBlock.render(true);
              this.ctx.restore();
              m = 0 < p2 ? Math.max(m, q.textBlock.height) : q.textBlock.height;
              this.chart.data[q.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
              g = O(q.id);
              this.ghostCtx.fillStyle = g;
              this.ghostCtx.beginPath();
              this.ghostCtx.fillRect(r2, q.textBlock.y - this.lineHeight / 2, q.textBlock.x + q.textBlock.width - r2, q.textBlock.height);
              q.x1 = this.chart._eventManager.objectMap[q.id].x1 = r2;
              q.y1 = this.chart._eventManager.objectMap[q.id].y1 = q.textBlock.y - this.lineHeight / 2;
              q.x2 = this.chart._eventManager.objectMap[q.id].x2 = q.textBlock.x + q.textBlock.width;
              q.y2 = this.chart._eventManager.objectMap[q.id].y2 = q.textBlock.y + q.textBlock.height - this.lineHeight / 2;
            }
            h2 += m;
          }
        };
        na(U, X);
        U.prototype.getDefaultAxisPlacement = function() {
          var a2 = this.type;
          if ("column" === a2 || "line" === a2 || "stepLine" === a2 || "spline" === a2 || "area" === a2 || "stepArea" === a2 || "splineArea" === a2 || "stackedColumn" === a2 || "stackedLine" === a2 || "bubble" === a2 || "scatter" === a2 || "stackedArea" === a2 || "stackedColumn100" === a2 || "stackedLine100" === a2 || "stackedArea100" === a2 || "candlestick" === a2 || "ohlc" === a2 || "rangeColumn" === a2 || "rangeArea" === a2 || "rangeSplineArea" === a2 || "boxAndWhisker" === a2 || "waterfall" === a2)
            return "normal";
          if ("bar" === a2 || "stackedBar" === a2 || "stackedBar100" === a2 || "rangeBar" === a2)
            return "xySwapped";
          if ("pie" === a2 || "doughnut" === a2 || "funnel" === a2 || "pyramid" === a2)
            return "none";
          "error" !== a2 && window.console.log("Unknown Chart Type: " + a2);
          return null;
        };
        U.getDefaultLegendMarker = function(a2) {
          if ("column" === a2 || "stackedColumn" === a2 || "stackedLine" === a2 || "bar" === a2 || "stackedBar" === a2 || "stackedBar100" === a2 || "bubble" === a2 || "scatter" === a2 || "stackedColumn100" === a2 || "stackedLine100" === a2 || "stepArea" === a2 || "candlestick" === a2 || "ohlc" === a2 || "rangeColumn" === a2 || "rangeBar" === a2 || "rangeArea" === a2 || "rangeSplineArea" === a2 || "boxAndWhisker" === a2 || "waterfall" === a2)
            return "square";
          if ("line" === a2 || "stepLine" === a2 || "spline" === a2 || "pie" === a2 || "doughnut" === a2)
            return "circle";
          if ("area" === a2 || "splineArea" === a2 || "stackedArea" === a2 || "stackedArea100" === a2 || "funnel" === a2 || "pyramid" === a2)
            return "triangle";
          if ("error" === a2)
            return "none";
          window.console.log("Unknown Chart Type: " + a2);
          return null;
        };
        U.prototype.getDataPointAtX = function(a2, d2) {
          if (!this.dataPoints || 0 === this.dataPoints.length)
            return null;
          var c2 = { dataPoint: null, distance: Infinity, index: NaN }, b = null, e = 0, f = 0, l2 = 1, h2 = Infinity, n2 = 0, k = 0, m = 0;
          "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (m = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), m = 1 < m ? Math.min(Math.max((this.dataPoints.length - 1) / m * Math.log(a2 / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (m = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, m = 0 < m ? Math.min(Math.max((this.dataPoints.length - 1) / m * (a2 - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
          for (; ; ) {
            f = 0 < l2 ? m + e : m - e;
            if (0 <= f && f < this.dataPoints.length) {
              var b = this.dataPoints[f], p2 = this.axisX.logarithmic ? b.x > a2 ? b.x / a2 : a2 / b.x : Math.abs(b.x - a2);
              p2 < c2.distance && (c2.dataPoint = b, c2.distance = p2, c2.index = f);
              b = p2;
              b <= h2 ? h2 = b : 0 < l2 ? n2++ : k++;
              if (1e3 < n2 && 1e3 < k)
                break;
            } else if (0 > m - e && m + e >= this.dataPoints.length)
              break;
            -1 === l2 ? (e++, l2 = 1) : l2 = -1;
          }
          return d2 || (c2.dataPoint.x.getTime ? c2.dataPoint.x.getTime() : c2.dataPoint.x) !== (a2.getTime ? a2.getTime() : a2) ? d2 && null !== c2.dataPoint ? c2 : null : c2;
        };
        U.prototype.getDataPointAtXY = function(a2, d2, c2) {
          if (!this.dataPoints || 0 === this.dataPoints.length || a2 < this.chart.plotArea.x1 || a2 > this.chart.plotArea.x2 || d2 < this.chart.plotArea.y1 || d2 > this.chart.plotArea.y2)
            return null;
          c2 = c2 || false;
          var b = [], e = 0, f = 0, l2 = 1, h2 = false, n2 = Infinity, k = 0, m = 0, p2 = 0;
          if ("none" !== this.chart.plotInfo.axisPlacement)
            if (p2 = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({ x: a2, y: d2 }), this.axisX.logarithmic)
              var q = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), p2 = 1 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * Math.log(p2 / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
            else
              q = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p2 = 0 < q ? Math.min(Math.max((this.dataPoints.length - 1) / q * (p2 - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
          for (; ; ) {
            f = 0 < l2 ? p2 + e : p2 - e;
            if (0 <= f && f < this.dataPoints.length) {
              var q = this.chart._eventManager.objectMap[this.dataPointIds[f]], g = this.dataPoints[f], s = null;
              if (q) {
                switch (this.type) {
                  case "column":
                  case "stackedColumn":
                  case "stackedColumn100":
                  case "bar":
                  case "stackedBar":
                  case "stackedBar100":
                  case "rangeColumn":
                  case "rangeBar":
                  case "waterfall":
                  case "error":
                    a2 >= q.x1 && (a2 <= q.x2 && d2 >= q.y1 && d2 <= q.y2) && (b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a2), Math.abs(q.x2 - a2), Math.abs(q.y1 - d2), Math.abs(q.y2 - d2)) }), h2 = true);
                    break;
                  case "line":
                  case "stepLine":
                  case "spline":
                  case "area":
                  case "stepArea":
                  case "stackedArea":
                  case "stackedArea100":
                  case "splineArea":
                  case "scatter":
                    var r2 = la("markerSize", g, this) || 4, w2 = c2 ? 20 : r2, s = Math.sqrt(Math.pow(q.x1 - a2, 2) + Math.pow(q.y1 - d2, 2));
                    s <= w2 && b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: s });
                    q = Math.abs(q.x1 - a2);
                    q <= n2 ? n2 = q : 0 < l2 ? k++ : m++;
                    s <= r2 / 2 && (h2 = true);
                    break;
                  case "rangeArea":
                  case "rangeSplineArea":
                    r2 = la("markerSize", g, this) || 4;
                    w2 = c2 ? 20 : r2;
                    s = Math.min(Math.sqrt(Math.pow(q.x1 - a2, 2) + Math.pow(q.y1 - d2, 2)), Math.sqrt(Math.pow(q.x1 - a2, 2) + Math.pow(q.y2 - d2, 2)));
                    s <= w2 && b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: s });
                    q = Math.abs(q.x1 - a2);
                    q <= n2 ? n2 = q : 0 < l2 ? k++ : m++;
                    s <= r2 / 2 && (h2 = true);
                    break;
                  case "bubble":
                    r2 = q.size;
                    s = Math.sqrt(Math.pow(q.x1 - a2, 2) + Math.pow(q.y1 - d2, 2));
                    s <= r2 / 2 && (b.push({
                      dataPoint: g,
                      dataPointIndex: f,
                      dataSeries: this,
                      distance: s
                    }), h2 = true);
                    break;
                  case "pie":
                  case "doughnut":
                    r2 = q.center;
                    w2 = "doughnut" === this.type ? q.percentInnerRadius * q.radius : 0;
                    s = Math.sqrt(Math.pow(r2.x - a2, 2) + Math.pow(r2.y - d2, 2));
                    s < q.radius && s > w2 && (s = Math.atan2(d2 - r2.y, a2 - r2.x), 0 > s && (s += 2 * Math.PI), s = Number(((180 * (s / Math.PI) % 360 + 360) % 360).toFixed(12)), r2 = Number(((180 * (q.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), w2 = Number(((180 * (q.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === w2 && 1 < q.endAngle && (w2 = 360), r2 >= w2 && 0 !== g.y && (w2 += 360, s < r2 && (s += 360)), s > r2 && s < w2 && (b.push({
                      dataPoint: g,
                      dataPointIndex: f,
                      dataSeries: this,
                      distance: 0
                    }), h2 = true));
                    break;
                  case "funnel":
                  case "pyramid":
                    s = q.funnelSection;
                    d2 > s.y1 && d2 < s.y4 && (s.y6 ? d2 > s.y6 ? (f = s.x6 + (s.x5 - s.x6) / (s.y5 - s.y6) * (d2 - s.y6), s = s.x3 + (s.x4 - s.x3) / (s.y4 - s.y3) * (d2 - s.y3)) : (f = s.x1 + (s.x6 - s.x1) / (s.y6 - s.y1) * (d2 - s.y1), s = s.x2 + (s.x3 - s.x2) / (s.y3 - s.y2) * (d2 - s.y2)) : (f = s.x1 + (s.x4 - s.x1) / (s.y4 - s.y1) * (d2 - s.y1), s = s.x2 + (s.x3 - s.x2) / (s.y3 - s.y2) * (d2 - s.y2)), a2 > f && a2 < s && (b.push({ dataPoint: g, dataPointIndex: q.dataPointIndex, dataSeries: this, distance: 0 }), h2 = true));
                    break;
                  case "boxAndWhisker":
                    if (a2 >= q.x1 - q.borderThickness / 2 && a2 <= q.x2 + q.borderThickness / 2 && d2 >= q.y4 - q.borderThickness / 2 && d2 <= q.y1 + q.borderThickness / 2 || Math.abs(q.x2 - a2 + q.x1 - a2) < q.borderThickness && d2 >= q.y1 && d2 <= q.y4)
                      b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a2), Math.abs(q.x2 - a2), Math.abs(q.y2 - d2), Math.abs(q.y3 - d2)) }), h2 = true;
                    break;
                  case "candlestick":
                    if (a2 >= q.x1 - q.borderThickness / 2 && a2 <= q.x2 + q.borderThickness / 2 && d2 >= q.y2 - q.borderThickness / 2 && d2 <= q.y3 + q.borderThickness / 2 || Math.abs(q.x2 - a2 + q.x1 - a2) < q.borderThickness && d2 >= q.y1 && d2 <= q.y4)
                      b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(q.x1 - a2), Math.abs(q.x2 - a2), Math.abs(q.y2 - d2), Math.abs(q.y3 - d2)) }), h2 = true;
                    break;
                  case "ohlc":
                    if (Math.abs(q.x2 - a2 + q.x1 - a2) < q.borderThickness && d2 >= q.y2 && d2 <= q.y3 || a2 >= q.x1 && a2 <= (q.x2 + q.x1) / 2 && d2 >= q.y1 - q.borderThickness / 2 && d2 <= q.y1 + q.borderThickness / 2 || a2 >= (q.x1 + q.x2) / 2 && a2 <= q.x2 && d2 >= q.y4 - q.borderThickness / 2 && d2 <= q.y4 + q.borderThickness / 2)
                      b.push({ dataPoint: g, dataPointIndex: f, dataSeries: this, distance: Math.min(
                        Math.abs(q.x1 - a2),
                        Math.abs(q.x2 - a2),
                        Math.abs(q.y2 - d2),
                        Math.abs(q.y3 - d2)
                      ) }), h2 = true;
                }
                if (h2 || 1e3 < k && 1e3 < m)
                  break;
              }
            } else if (0 > p2 - e && p2 + e >= this.dataPoints.length)
              break;
            -1 === l2 ? (e++, l2 = 1) : l2 = -1;
          }
          a2 = null;
          for (d2 = 0; d2 < b.length; d2++)
            a2 ? b[d2].distance <= a2.distance && (a2 = b[d2]) : a2 = b[d2];
          return a2;
        };
        U.prototype.getMarkerProperties = function(a2, d2, c2, b) {
          var e = this.dataPoints, f = e[a2].markerColor ? e[a2].markerColor : this.markerColor ? this.markerColor : e[a2].color ? e[a2].color : this.color ? this.color : this._colorSet[a2 % this._colorSet.length], l2 = e[a2].markerBorderColor ? e[a2].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, h2 = r(e[a2].markerBorderThickness) ? this.markerBorderThickness ? this.markerBorderThickness : null : e[a2].markerBorderThickness, n2 = e[a2].markerType ? e[a2].markerType : this.markerType;
          a2 = r(e[a2].markerSize) ? this.markerSize : e[a2].markerSize;
          return { x: d2, y: c2, ctx: b, type: n2, size: a2, color: f, borderColor: l2, borderThickness: h2 };
        };
        na(A, X);
        A.prototype.createExtraLabelsForLog = function(a2) {
          a2 = (a2 || 0) + 1;
          if (!(5 < a2)) {
            var d2 = this.logLabelValues[0] || this.intervalStartPosition;
            if (Math.log(this.range) / Math.log(d2 / this.viewportMinimum) < this.noTicks - 1) {
              for (var c2 = A.getNiceNumber((d2 - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), true), b = Math.ceil(this.viewportMinimum / c2) * c2; b < d2; b += c2)
                b < this.viewportMinimum || this.logLabelValues.push(b);
              this.logLabelValues.sort(Ra);
              this.createExtraLabelsForLog(a2);
            }
          }
        };
        A.prototype.createLabels = function() {
          var a2, d2, c2 = 0, b = 0, e, f = 0, l2 = 0, b = 0, b = this.interval, h2 = 0, n2, k = 0.6 * this.chart.height, m;
          a2 = false;
          var p2 = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], q = p2.length ? r(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
          if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
            e = this.viewportMaximum;
            if (this.labels) {
              a2 = Math.ceil(b);
              for (var b = Math.ceil(this.intervalStartPosition), g = false, c2 = b; c2 < this.viewportMaximum; c2 += a2)
                if (this.labels[c2])
                  g = true;
                else {
                  g = false;
                  break;
                }
              g && (this.interval = a2, this.intervalStartPosition = b);
            }
            if (this.logarithmic && !this.equidistantInterval)
              for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), b = 0, g = q; b < this.logLabelValues.length; b++)
                if (c2 = this.logLabelValues[b], c2 < this.viewportMinimum)
                  b++;
                else {
                  for (; g < p2.length && c2 > p2[g].endValue; g++)
                    ;
                  a2 = g < p2.length && c2 >= p2[g].startValue && c2 <= p2[g].endValue;
                  m = c2;
                  a2 || (a2 = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : fa(m, this.valueFormatString, this.chart._cultureInfo), a2 = new ka(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: f,
                    maxHeight: l2,
                    angle: this.labelAngle,
                    text: this.prefix + a2 + this.suffix,
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    cornerRadius: this.labelCornerRadius,
                    textAlign: this.labelTextAlign,
                    fontSize: this.labelFontSize,
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle,
                    textBaseline: "middle",
                    borderThickness: 0
                  }), this._labels.push({ position: m, textBlock: a2, effectiveHeight: null }));
                }
            g = q;
            for (c2 = this.intervalStartPosition; c2 <= e; c2 = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? c2 * Math.pow(this.logarithmBase, this.interval) : c2 + this.interval : (this.logarithmic && this.equidistantInterval ? c2 * Math.pow(this.logarithmBase, this.interval) : c2 + this.interval).toFixed(12))) {
              for (; g < p2.length && c2 > p2[g].endValue; g++)
                ;
              a2 = g < p2.length && c2 >= p2[g].startValue && c2 <= p2[g].endValue;
              m = c2;
              a2 || (a2 = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.options, value: m, label: this.labels[m] ? this.labels[m] : null }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : fa(m, this.valueFormatString, this.chart._cultureInfo), a2 = new ka(this.ctx, { x: 0, y: 0, maxWidth: f, maxHeight: l2, angle: this.labelAngle, text: this.prefix + a2 + this.suffix, textAlign: this.labelTextAlign, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({ position: m, textBlock: a2, effectiveHeight: null }));
            }
          } else
            for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = Xa(new Date(this.viewportMaximum), this.interval, this.intervalType), g = q, c2 = this.intervalStartPosition; c2 < e; Xa(c2, b, this.intervalType)) {
              for (a2 = c2.getTime(); g < p2.length && a2 > p2[g].endValue; g++)
                ;
              m = a2;
              a2 = g < p2.length && a2 >= p2[g].startValue && a2 <= p2[g].endValue;
              a2 || (a2 = this.labelFormatter ? this.labelFormatter({
                chart: this.chart,
                axis: this.options,
                value: new Date(m),
                label: this.labels[m] ? this.labels[m] : null
              }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : Aa(m, this.valueFormatString, this.chart._cultureInfo), a2 = new ka(this.ctx, {
                x: 0,
                y: 0,
                maxWidth: f,
                backgroundColor: this.labelBackgroundColor,
                borderColor: this.labelBorderColor,
                borderThickness: this.labelBorderThickness,
                cornerRadius: this.labelCornerRadius,
                maxHeight: l2,
                angle: this.labelAngle,
                text: this.prefix + a2 + this.suffix,
                textAlign: this.labelTextAlign,
                fontSize: this.labelFontSize,
                fontFamily: this.labelFontFamily,
                fontWeight: this.labelFontWeight,
                fontColor: this.labelFontColor,
                fontStyle: this.labelFontStyle,
                textBaseline: "middle"
              }), this._labels.push({ position: m, textBlock: a2, effectiveHeight: null, breaksLabelType: void 0 }));
            }
          if ("bottom" === this._position || "top" === this._position)
            h2 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * I[this.intervalType + "Duration"] * this.interval, f = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (l2 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);
          else if ("left" === this._position || "right" === this._position)
            h2 = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * I[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (f = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), l2 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
          for (b = 0; b < this._labels.length; b++) {
            a2 = this._labels[b].textBlock;
            a2.maxWidth = f;
            a2.maxHeight = l2;
            var s = a2.measureText();
            n2 = s.height;
          }
          e = [];
          q = p2 = 0;
          if (this.labelAutoFit || this.options.labelAutoFit) {
            if (r(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
              if (f = 0.9 * h2 >> 0, q = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = f;
                this.sessionVariables.labelMaxHeight = l2;
                this.sessionVariables.labelAngle = this.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (c2 = 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a2 = this._labels[c2].textBlock;
                    for (var v3, g = a2.text.split(" "), b = 0; b < g.length; b++)
                      m = g[b], this.ctx.font = a2.fontStyle + " " + a2.fontWeight + " " + a2.fontSize + "px " + a2.fontFamily, m = this.ctx.measureText(m), m.width > q && (v3 = c2, q = m.width);
                  }
                c2 = 0;
                for (c2 = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a2 = this._labels[c2].textBlock;
                    s = a2.measureText();
                    for (g = c2 + 1; g < this._labels.length; g++)
                      if (!this._labels[g].breaksLabelType) {
                        d2 = this._labels[g].textBlock;
                        d2 = d2.measureText();
                        break;
                      }
                    e.push(a2.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    b = f * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (l2 - a2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    if (r(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)
                      if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? l2 : Math.min((b - f * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), m = (k - (n2 + a2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !r(this.options.labelWrap))
                        this.labelWrap ? r(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, q), m), this.sessionVariables.labelWrap = this.labelWrap, d2 && s.width + d2.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > f ? -25 : this.sessionVariables.labelAngle) : r(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelMaxWidth = f, d2 && s.width + d2.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > f ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelWrap = this.labelWrap);
                      else {
                        if (r(this.options.labelWrap)) {
                          if (!r(this.options.labelMaxWidth))
                            this.options.labelMaxWidth < f ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = l2);
                          else if (!r(d2)) {
                            if (b = s.width + d2.width >> 0, g = this.labelFontSize, q < f)
                              b - 2 * f > p2 && (p2 = b - 2 * f, b >= 2 * f && b < 2.2 * f ? (this.sessionVariables.labelMaxWidth = f, r(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 2.2 * f && b < 2.8 * f ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = g) : b >= 2.8 * f && b < 3.2 * f ? (this.sessionVariables.labelMaxWidth = Math.max(f, q), this.sessionVariables.labelWrap = true, r(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : b >= 3.2 * f && b < 3.6 * f ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = this.labelFontSize) : b > 3.6 * f && b < 5 * f ? (r(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m) : b > 5 * f && (this.sessionVariables.labelWrap = true, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelFontSize = g, this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelAngle = this.labelAngle));
                            else if (v3 === c2 && (0 === v3 && q + this._labels[v3 + 1].textBlock.measureText().width - 2 * f > p2 || v3 === this._labels.length - 1 && q + this._labels[v3 - 1].textBlock.measureText().width - 2 * f > p2 || 0 < v3 && v3 < this._labels.length - 1 && q + this._labels[v3 + 1].textBlock.measureText().width - 2 * f > p2 && q + this._labels[v3 - 1].textBlock.measureText().width - 2 * f > p2))
                              p2 = 0 === v3 ? q + this._labels[v3 + 1].textBlock.measureText().width - 2 * f : q + this._labels[v3 - 1].textBlock.measureText().width - 2 * f, this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m;
                            else if (0 === p2)
                              for (this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? g : this.options.labelFontSize, this.sessionVariables.labelWrap = true, b = 0; b < this._labels.length; b++)
                                a2 = this._labels[b].textBlock, a2.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, q), m), s = a2.measureText(), b < this._labels.length - 1 && (g = b + 1, d2 = this._labels[g].textBlock, d2.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(f, q), m), d2 = d2.measureText(), s.width + d2.width >> 0 > 2 * f && (this.sessionVariables.labelAngle = -25));
                          }
                        }
                      }
                    else
                      (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? l2 : Math.min((b - f * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), m = 0 != this.labelAngle ? (k - (n2 + a2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : f, this.sessionVariables.labelMaxHeight = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, r(this.options.labelWrap)) ? r(this.options.labelWrap) && (this.labelWrap && !r(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelMaxHeight = l2) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = b < 0.9 * h2 ? 0.9 * h2 : b, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) : (r(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = l2);
                  }
                for (b = 0; b < this._labels.length; b++)
                  a2 = this._labels[b].textBlock, a2.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a2.fontSize = this.sessionVariables.labelFontSize, a2.angle = this.labelAngle = this.sessionVariables.labelAngle, a2.wrap = this.labelWrap = this.sessionVariables.labelWrap, a2.maxHeight = this.sessionVariables.labelMaxHeight, a2.measureText();
              } else
                for (c2 = 0; c2 < this._labels.length; c2++)
                  a2 = this._labels[c2].textBlock, a2.maxWidth = this.labelMaxWidth = r(this.options.labelMaxWidth) ? r(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = f : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a2.fontSize = this.labelFontSize = r(this.options.labelFontSize) ? r(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a2.angle = this.labelAngle = r(this.options.labelAngle) ? r(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a2.wrap = this.labelWrap = r(this.options.labelWrap) ? r(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a2.maxHeight = r(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = l2 : this.sessionVariables.labelMaxHeight, a2.measureText();
            else if ("left" === this._position || "right" === this._position)
              if (f = r(this.options.labelMaxWidth) ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, l2 = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                this.sessionVariables.labelFontSize = this.labelFontSize;
                this.sessionVariables.labelMaxWidth = f;
                this.sessionVariables.labelMaxHeight = l2;
                this.sessionVariables.labelAngle = r(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                this.sessionVariables.labelWrap = this.labelWrap;
                for (c2 = 0; c2 < this._labels.length; c2++)
                  if (!this._labels[c2].breaksLabelType) {
                    a2 = this._labels[c2].textBlock;
                    s = a2.measureText();
                    for (g = c2 + 1; g < this._labels.length; g++)
                      if (!this._labels[g].breaksLabelType) {
                        d2 = this._labels[g].textBlock;
                        d2 = d2.measureText();
                        break;
                      }
                    e.push(a2.height);
                    this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
                    b = f * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (l2 - a2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                    Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                    r(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? r(this.options.labelWrap) ? r(this.options.labelWrap) && (r(this.options.labelMaxWidth) ? r(d2) || (h2 = s.height + d2.height >> 0, h2 - 2 * l2 > q && (q = h2 - 2 * l2, h2 >= 2 * l2 && h2 < 2.4 * l2 ? (r(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a2.measureText()), this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : h2 >= 2.4 * l2 && h2 < 2.8 * l2 ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = true) : h2 >= 2.8 * l2 && h2 < 3.2 * l2 ? (this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelWrap = true, r(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = r(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : h2 >= 3.2 * l2 && h2 < 3.6 * l2 ? (this.sessionVariables.labelMaxHeight = b, this.sessionVariables.labelWrap = true, this.sessionVariables.labelFontSize = this.labelFontSize) : h2 > 3.6 * l2 && h2 < 10 * l2 ? (r(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelAngle = r(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : h2 > 10 * l2 && h2 < 50 * l2 && (r(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a2.measureText()), this.sessionVariables.labelFontSize = r(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelMaxWidth = f, this.sessionVariables.labelAngle = r(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = l2, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : f, this.sessionVariables.labelMaxHeight = l2) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? f : Math.min(
                      (b - l2 * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)),
                      l2
                    ), r(this.options.labelWrap)) ? r(this.options.labelWrap) && (this.labelWrap && !r(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : f, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? l2 : b, r(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? l2 : b, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = f) : (this.sessionVariables.labelMaxHeight = l2, r(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap);
                  }
                for (b = 0; b < this._labels.length; b++)
                  a2 = this._labels[b].textBlock, a2.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a2.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a2.angle = this.labelAngle = this.sessionVariables.labelAngle, a2.wrap = this.labelWrap = this.sessionVariables.labelWrap, a2.maxHeight = this.sessionVariables.labelMaxHeight, a2.measureText();
              } else
                for (c2 = 0; c2 < this._labels.length; c2++)
                  a2 = this._labels[c2].textBlock, a2.maxWidth = this.labelMaxWidth = r(this.options.labelMaxWidth) ? r(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = f : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a2.fontSize = this.labelFontSize = r(this.options.labelFontSize) ? r(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, a2.angle = this.labelAngle = r(this.options.labelAngle) ? r(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, a2.wrap = this.labelWrap = r(this.options.labelWrap) ? r(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, a2.maxHeight = r(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = l2 : this.sessionVariables.labelMaxHeight, a2.measureText();
          }
          for (c2 = 0; c2 < this.stripLines.length; c2++) {
            var f = this.stripLines[c2], A2;
            if ("outside" === f.labelPlacement) {
              l2 = this.sessionVariables.labelMaxWidth;
              if ("bottom" === this._position || "top" === this._position)
                r(f.options.labelWrap) && !r(this.sessionVariables.stripLineLabelMaxHeight) ? A2 = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = A2 = f.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
              if ("left" === this._position || "right" === this._position)
                r(f.options.labelWrap) && !r(this.sessionVariables.stripLineLabelMaxHeight) ? A2 = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = A2 = f.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;
              r(f.labelBackgroundColor) && (f.labelBackgroundColor = "#EEEEEE");
            } else
              l2 = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, A2 = r(f.options.labelWrap) || f.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, r(f.labelBackgroundColor) && (r(f.startValue) && 0 !== f.startValue ? f.labelBackgroundColor = w ? "transparent" : null : f.labelBackgroundColor = "#EEEEEE");
            a2 = new ka(this.ctx, {
              x: 0,
              y: 0,
              backgroundColor: f.labelBackgroundColor,
              borderColor: f.labelBorderColor,
              borderThickness: f.labelBorderThickness,
              cornerRadius: f.labelCornerRadius,
              maxWidth: f.options.labelMaxWidth ? f.options.labelMaxWidth : l2,
              maxHeight: A2,
              angle: this.labelAngle,
              text: f.labelFormatter ? f.labelFormatter({ chart: this.chart, axis: this, stripLine: f }) : f.label,
              textAlign: this.labelTextAlign,
              fontSize: "outside" === f.labelPlacement ? f.options.labelFontSize ? f.labelFontSize : this.labelFontSize : f.labelFontSize,
              fontFamily: "outside" === f.labelPlacement ? f.options.labelFontFamily ? f.labelFontFamily : this.labelFontFamily : f.labelFontFamily,
              fontWeight: "outside" === f.labelPlacement ? f.options.labelFontWeight ? f.labelFontWeight : this.labelFontWeight : f.labelFontWeight,
              fontColor: f.labelFontColor || f.color,
              fontStyle: "outside" === f.labelPlacement ? f.options.labelFontStyle ? f.labelFontStyle : this.fontWeight : f.labelFontStyle,
              textBaseline: "middle"
            });
            this._stripLineLabels.push({ position: f.value, textBlock: a2, effectiveHeight: null, stripLine: f });
          }
        };
        A.prototype.createLabelsAndCalculateWidth = function() {
          var a2 = 0, d2 = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var c2 = this.chart.isNavigator ? 0 : 5;
          if ("left" === this._position || "right" === this._position) {
            this.createLabels();
            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index)
              for (d2 = 0; d2 < this._labels.length; d2++) {
                var b = this._labels[d2].textBlock, e = b.measureText(), f = 0, f = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                a2 < f && (a2 = f);
                this._labels[d2].effectiveWidth = f;
              }
            for (d2 = 0; d2 < this._stripLineLabels.length; d2++)
              "outside" === this._stripLineLabels[d2].stripLine.labelPlacement && (this._stripLineLabels[d2].stripLine.value >= this.viewportMinimum && this._stripLineLabels[d2].stripLine.value <= this.viewportMaximum) && (b = this._stripLineLabels[d2].textBlock, e = b.measureText(), f = 0 === this.labelAngle ? e.width : e.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a2 < f && (a2 = f), this._stripLineLabels[d2].effectiveWidth = f);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a2 + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + c2;
        };
        A.prototype.createLabelsAndCalculateHeight = function() {
          var a2 = 0;
          this._labels = [];
          this._stripLineLabels = [];
          var d2, c2 = 0, b = this.chart.isNavigator ? 0 : 5;
          if ("bottom" === this._position || "top" === this._position) {
            this.createLabels();
            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index)
              for (c2 = 0; c2 < this._labels.length; c2++) {
                d2 = this._labels[c2].textBlock;
                var e = d2.measureText(), f = 0, f = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                a2 < f && (a2 = f);
                this._labels[c2].effectiveHeight = f;
              }
            for (c2 = 0; c2 < this._stripLineLabels.length; c2++)
              "outside" === this._stripLineLabels[c2].stripLine.labelPlacement && (this._stripLineLabels[c2].stripLine.value >= this.viewportMinimum && this._stripLineLabels[c2].stripLine.value <= this.viewportMaximum) && (d2 = this._stripLineLabels[c2].textBlock, e = d2.measureText(), f = 0 === this.labelAngle ? e.height : e.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (e.height - d2.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a2 < f && (a2 = f), this._stripLineLabels[c2].effectiveHeight = f);
          }
          return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a2 + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + b;
        };
        A.setLayout = function(a2, d2, c2, b, e, f) {
          var l2, h2, n2, k, m = a2[0] ? a2[0].chart : d2[0].chart, p2 = m.isNavigator ? 0 : 10, q = m._axes;
          if (a2 && 0 < a2.length)
            for (var g = 0; g < a2.length; g++)
              a2[g] && a2[g].calculateAxisParameters();
          if (d2 && 0 < d2.length)
            for (g = 0; g < d2.length; g++)
              d2[g].calculateAxisParameters();
          if (c2 && 0 < c2.length)
            for (g = 0; g < c2.length; g++)
              c2[g].calculateAxisParameters();
          if (b && 0 < b.length)
            for (g = 0; g < b.length; g++)
              b[g].calculateAxisParameters();
          for (g = 0; g < q.length; g++)
            if (q[g] && q[g].scaleBreaks && q[g].scaleBreaks._appliedBreaks.length)
              for (var s = q[g].scaleBreaks._appliedBreaks, w2 = 0; w2 < s.length && !(s[w2].startValue > q[g].viewportMaximum); w2++)
                s[w2].endValue < q[g].viewportMinimum || (r(q[g].scaleBreaks.firstBreakIndex) && (q[g].scaleBreaks.firstBreakIndex = w2), s[w2].startValue >= q[g].viewPortMinimum && (q[g].scaleBreaks.lastBreakIndex = w2));
          for (var v3 = w2 = 0, u2 = 0, y = 0, x = 0, z = 0, A2 = 0, C2, B3, E = h2 = 0, I2, J2, K2, s = I2 = J2 = K2 = false, g = 0; g < q.length; g++)
            q[g] && q[g].title && (q[g]._titleTextBlock = new ka(q[g].ctx, {
              text: q[g].title,
              horizontalAlign: "center",
              fontSize: q[g].titleFontSize,
              fontFamily: q[g].titleFontFamily,
              fontWeight: q[g].titleFontWeight,
              fontColor: q[g].titleFontColor,
              fontStyle: q[g].titleFontStyle,
              borderColor: q[g].titleBorderColor,
              borderThickness: q[g].titleBorderThickness,
              backgroundColor: q[g].titleBackgroundColor,
              cornerRadius: q[g].titleCornerRadius,
              textBaseline: "top"
            }));
          for (g = 0; g < q.length; g++)
            if (q[g].title)
              switch (q[g]._position) {
                case "left":
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || f.height;
                  q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * f.width : 1.5 * q[g].titleFontSize;
                  q[g]._titleTextBlock.angle = -90;
                  break;
                case "right":
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || f.height;
                  q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * f.width : 1.5 * q[g].titleFontSize;
                  q[g]._titleTextBlock.angle = 90;
                  break;
                default:
                  q[g]._titleTextBlock.maxWidth = q[g].titleMaxWidth || f.width, q[g]._titleTextBlock.maxHeight = q[g].titleWrap ? 0.8 * f.height : 1.5 * q[g].titleFontSize, q[g]._titleTextBlock.angle = 0;
              }
          if ("normal" === e) {
            for (var y = [], x = [], z = [], A2 = [], N2 = [], P2 = [], O2 = [], R3 = []; 4 > w2; ) {
              var F = 0, U2 = 0, S2 = 0, V3 = 0, X2 = e = 0, L = 0, Z3 = 0, W3 = 0, Y3 = 0, Q = 0, $2 = 0;
              if (c2 && 0 < c2.length)
                for (z = [], g = Q = 0; g < c2.length; g++)
                  z.push(Math.ceil(c2[g] ? c2[g].createLabelsAndCalculateWidth() : 0)), Q += z[g], L += c2[g] && !m.isNavigator ? c2[g].margin : 0;
              else
                z.push(Math.ceil(c2[0] ? c2[0].createLabelsAndCalculateWidth() : 0));
              O2.push(z);
              if (b && 0 < b.length)
                for (A2 = [], g = $2 = 0; g < b.length; g++)
                  A2.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateWidth() : 0)), $2 += A2[g], Z3 += b[g] ? b[g].margin : 0;
              else
                A2.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
              R3.push(A2);
              l2 = Math.round(f.x1 + Q + L);
              n2 = Math.round(f.x2 - $2 - Z3 > m.width - p2 ? m.width - p2 : f.x2 - $2 - Z3);
              if (a2 && 0 < a2.length)
                for (y = [], g = W3 = 0; g < a2.length; g++)
                  a2[g] && (a2[g].lineCoordinates = {}), a2[g].lineCoordinates.width = Math.abs(n2 - l2), a2[g].title && (a2[g]._titleTextBlock.maxWidth = 0 < a2[g].titleMaxWidth && a2[g].titleMaxWidth < a2[g].lineCoordinates.width ? a2[g].titleMaxWidth : a2[g].lineCoordinates.width), y.push(Math.ceil(a2[g] ? a2[g].createLabelsAndCalculateHeight() : 0)), W3 += y[g], e += a2[g] && !m.isNavigator ? a2[g].margin : 0;
              else
                y.push(Math.ceil(a2[0] ? a2[0].createLabelsAndCalculateHeight() : 0));
              N2.push(y);
              if (d2 && 0 < d2.length)
                for (x = [], g = Y3 = 0; g < d2.length; g++)
                  d2[g] && (d2[g].lineCoordinates = {}), d2[g].lineCoordinates.width = Math.abs(n2 - l2), d2[g].title && (d2[g]._titleTextBlock.maxWidth = 0 < d2[g].titleMaxWidth && d2[g].titleMaxWidth < d2[g].lineCoordinates.width ? d2[g].titleMaxWidth : d2[g].lineCoordinates.width), x.push(Math.ceil(d2[g] ? d2[g].createLabelsAndCalculateHeight() : 0)), Y3 += x[g], X2 += d2[g] && !m.isNavigator ? d2[g].margin : 0;
              else
                x.push(Math.ceil(d2[0] ? d2[0].createLabelsAndCalculateHeight() : 0));
              P2.push(x);
              if (a2 && 0 < a2.length)
                for (g = 0; g < a2.length; g++)
                  a2[g] && (a2[g].lineCoordinates.x1 = l2, n2 = Math.round(f.x2 - $2 - Z3 > m.width - p2 ? m.width - p2 : f.x2 - $2 - Z3), a2[g]._labels && 1 < a2[g]._labels.length && (h2 = k = 0, k = a2[g]._labels[1], h2 = "dateTime" === a2[g].valueType ? a2[g]._labels[a2[g]._labels.length - 2] : a2[g]._labels[a2[g]._labels.length - 1], v3 = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u2 = h2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h2.textBlock.angle)) + (h2.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h2.textBlock.angle))), !a2[g] || (!a2[g].labelAutoFit || r(C2) || r(B3) || m.isNavigator || m.stockChart) || (h2 = 0, 0 < a2[g].labelAngle ? B3 + u2 > n2 && (h2 += 0 < a2[g].labelAngle ? B3 + u2 - n2 - $2 : 0) : 0 > a2[g].labelAngle ? C2 - v3 < l2 && C2 - v3 < a2[g].viewportMinimum && (E = l2 - (L + a2[g].tickLength + z + C2 - v3 + a2[g].labelFontSize / 2)) : 0 === a2[g].labelAngle && (B3 + u2 > n2 && (h2 = B3 + u2 / 2 - n2 - $2), C2 - v3 < l2 && C2 - v3 < a2[g].viewportMinimum && (E = l2 - L - a2[g].tickLength - z - C2 + v3 / 2)), a2[g].viewportMaximum === a2[g].maximum && a2[g].viewportMinimum === a2[g].minimum && 0 < a2[g].labelAngle && 0 < h2 ? n2 -= h2 : a2[g].viewportMaximum === a2[g].maximum && a2[g].viewportMinimum === a2[g].minimum && 0 > a2[g].labelAngle && 0 < E ? l2 += E : a2[g].viewportMaximum === a2[g].maximum && a2[g].viewportMinimum === a2[g].minimum && 0 === a2[g].labelAngle && (0 < E && (l2 += E), 0 < h2 && (n2 -= h2))), m.panEnabled ? W3 = r(m.sessionVariables.axisX.height) ? m.sessionVariables.axisX.height = W3 : m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = W3, h2 = Math.round(f.y2 - W3 - e + F), k = Math.round(f.y2), a2[g].lineCoordinates.x2 = n2, a2[g].lineCoordinates.width = n2 - l2, a2[g].lineCoordinates.y1 = h2, a2[g].lineCoordinates.y2 = h2 + a2[g].lineThickness / 2, "inside" === a2[g].labelPlacement && 0 < g && (a2[g].lineCoordinates.y1 = a2[g].lineCoordinates.y1 + y[g] - (a2[g]._titleTextBlock ? a2[g]._titleTextBlock.height : 0) - a2[g].tickLength - a2[g].margin - 5, a2[g].lineCoordinates.y2 = a2[g].lineCoordinates.y1 + a2[g].lineThickness / 2), "inside" === a2[g].tickPlacement && 0 < g && (a2[g].lineCoordinates.y1 += a2[g].tickLength, a2[g].lineCoordinates.y2 = a2[g].lineCoordinates.y1 + a2[g].lineThickness / 2), a2[g].bounds = { x1: l2, y1: h2, x2: n2, y2: k - (W3 + e - y[g] - F), width: n2 - l2 }, a2[g].bounds.height = a2[g].bounds.y2 - a2[g].bounds.y1), F += y[g] + a2[g].margin;
              if (d2 && 0 < d2.length)
                for (g = 0; g < d2.length; g++)
                  d2[g].lineCoordinates.x1 = Math.round(f.x1 + Q + L), d2[g].lineCoordinates.x2 = Math.round(f.x2 - $2 - Z3 > m.width - p2 ? m.width - p2 : f.x2 - $2 - Z3), d2[g].lineCoordinates.width = Math.abs(n2 - l2), d2[g]._labels && 1 < d2[g]._labels.length && (k = d2[g]._labels[1], h2 = "dateTime" === d2[g].valueType ? d2[g]._labels[d2[g]._labels.length - 2] : d2[g]._labels[d2[g]._labels.length - 1], v3 = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u2 = h2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h2.textBlock.angle)) + (h2.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h2.textBlock.angle))), m.panEnabled ? Y3 = r(m.sessionVariables.axisX2.height) ? m.sessionVariables.axisX2.height = Y3 : m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = Y3, h2 = Math.round(f.y1), k = d2[g].lineCoordinates.y1 = h2 + Y3 + X2 - U2, d2[g].lineCoordinates.y2 = h2, "inside" === d2[g].labelPlacement && 0 < g && (d2[g].lineCoordinates.y1 -= x[g] - d2[g].tickLength - (d2[g]._titleTextBlock ? d2[g]._titleTextBlock.height : 0)), "inside" === d2[g].tickPlacement && 0 < g && (d2[g].lineCoordinates.y1 -= d2[g].tickLength), d2[g].bounds = { x1: l2, y1: h2 + (Y3 + X2 - x[g] - U2), x2: n2, y2: k, width: n2 - l2 }, d2[g].bounds.height = d2[g].bounds.y2 - d2[g].bounds.y1, U2 += x[g] + d2[g].margin;
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  L = m.isNavigator ? 0 : 10, c2[g] && (l2 = Math.round(a2[0] ? a2[0].lineCoordinates.x1 : d2[0].lineCoordinates.x1), L = c2[g]._labels && 0 < c2[g]._labels.length ? c2[g]._labels[c2[g]._labels.length - 1].textBlock.height / 2 : p2, h2 = Math.round(f.y1 + Y3 + X2 < Math.max(L, p2) ? Math.max(L, p2) : f.y1 + Y3 + X2), n2 = Math.round(a2[0] ? a2[0].lineCoordinates.x1 : d2[0].lineCoordinates.x1), L = 0 < a2.length ? 0 : c2[g]._labels && 0 < c2[g]._labels.length ? c2[g]._labels[0].textBlock.height / 2 : p2, k = Math.round(f.y2 - W3 - e - L), c2[g].lineCoordinates = { x1: l2 - S2, y1: h2, x2: n2 - S2, y2: k, height: Math.abs(k - h2) }, "inside" === c2[g].labelPlacement && 0 < g && (c2[g].lineCoordinates.x1 = c2[g].lineCoordinates.x1 - (z[g] - (c2[g]._titleTextBlock ? c2[g]._titleTextBlock.height : 0)) + c2[g].tickLength, c2[g].lineCoordinates.x2 = c2[g].lineCoordinates.x1 + c2[g].lineThickness / 2), "inside" === c2[g].tickPlacement && 0 < g && (c2[g].lineCoordinates.x1 -= c2[g].tickLength, c2[g].lineCoordinates.x2 = c2[g].lineCoordinates.x1 + c2[g].lineThickness / 2), c2[g].bounds = { x1: l2 - (z[g] + S2), y1: h2, x2: n2 - S2, y2: k, height: k - h2 }, c2[g].bounds.width = c2[g].bounds.x2 - c2[g].bounds.x1, c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.height ? c2[g].titleMaxWidth : c2[g].lineCoordinates.height), S2 += z[g] + c2[g].margin);
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g] && (l2 = Math.round(a2[0] ? a2[0].lineCoordinates.x2 : d2[0].lineCoordinates.x2), n2 = Math.round(l2), L = b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[b[g]._labels.length - 1].textBlock.height / 2 : 0, h2 = Math.round(f.y1 + Y3 + X2 < Math.max(L, p2) ? Math.max(L, p2) : f.y1 + Y3 + X2), L = 0 < a2.length ? 0 : b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[0].textBlock.height / 2 : 0, k = Math.round(f.y2 - (W3 + e + L)), b[g].lineCoordinates = { x1: l2 + V3, y1: h2, x2: l2 + V3, y2: k, height: Math.abs(k - h2) }, "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.x1 = b[g].lineCoordinates.x1 + (A2[g] - (b[g]._titleTextBlock ? b[g]._titleTextBlock.height : 0)) - b[g].tickLength - 2, b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.x1 += b[g].tickLength, b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), b[g].bounds = { x1: l2 + V3, y1: h2, x2: n2 + (A2[g] + V3), y2: k, height: k - h2 }, b[g].bounds.width = b[g].bounds.x2 - b[g].bounds.x1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.height ? b[g].titleMaxWidth : b[g].lineCoordinates.height), V3 += A2[g] + b[g].margin);
              if (a2 && 0 < a2.length)
                for (g = 0; g < a2.length; g++)
                  a2[g] && (a2[g].calculateValueToPixelConversionParameters(), a2[g].calculateBreaksSizeInValues(), a2[g]._labels && 1 < a2[g]._labels.length && (C2 = (a2[g].logarithmic ? Math.log(a2[g]._labels[1].position / a2[g].viewportMinimum) / a2[g].conversionParameters.lnLogarithmBase : a2[g]._labels[1].position - a2[g].viewportMinimum) * Math.abs(a2[g].conversionParameters.pixelPerUnit) + a2[g].lineCoordinates.x1, l2 = a2[g]._labels[a2[g]._labels.length - ("dateTime" === a2[g].valueType ? 2 : 1)].position, l2 = a2[g].getApparentDifference(a2[g].viewportMinimum, l2), B3 = a2[g].logarithmic ? (1 < l2 ? Math.log(l2) / a2[g].conversionParameters.lnLogarithmBase * Math.abs(a2[g].conversionParameters.pixelPerUnit) : 0) + a2[g].lineCoordinates.x1 : (0 < l2 ? l2 * Math.abs(a2[g].conversionParameters.pixelPerUnit) : 0) + a2[g].lineCoordinates.x1));
              if (d2 && 0 < d2.length)
                for (g = 0; g < d2.length; g++)
                  d2[g].calculateValueToPixelConversionParameters(), d2[g].calculateBreaksSizeInValues(), d2[g]._labels && 1 < d2[g]._labels.length && (C2 = (d2[g].logarithmic ? Math.log(d2[g]._labels[1].position / d2[g].viewportMinimum) / d2[g].conversionParameters.lnLogarithmBase : d2[g]._labels[1].position - d2[g].viewportMinimum) * Math.abs(d2[g].conversionParameters.pixelPerUnit) + d2[g].lineCoordinates.x1, l2 = d2[g]._labels[d2[g]._labels.length - ("dateTime" === d2[g].valueType ? 2 : 1)].position, l2 = d2[g].getApparentDifference(d2[g].viewportMinimum, l2), B3 = d2[g].logarithmic ? (1 < l2 ? Math.log(l2) / d2[g].conversionParameters.lnLogarithmBase * Math.abs(d2[g].conversionParameters.pixelPerUnit) : 0) + d2[g].lineCoordinates.x1 : (0 < l2 ? l2 * Math.abs(d2[g].conversionParameters.pixelPerUnit) : 0) + d2[g].lineCoordinates.x1);
              for (g = 0; g < q.length; g++)
                "axisY" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());
              if (0 < w2) {
                if (a2 && 0 < a2.length)
                  for (g = 0; g < a2.length; g++)
                    s = N2[w2 - 1][g] === N2[w2][g] ? true : false;
                else
                  s = true;
                if (d2 && 0 < d2.length)
                  for (g = 0; g < d2.length; g++)
                    I2 = P2[w2 - 1][g] === P2[w2][g] ? true : false;
                else
                  I2 = true;
                if (c2 && 0 < c2.length)
                  for (g = 0; g < c2.length; g++)
                    J2 = O2[w2 - 1][g] === O2[w2][g] ? true : false;
                else
                  J2 = true;
                if (b && 0 < b.length)
                  for (g = 0; g < b.length; g++)
                    K2 = R3[w2 - 1][g] === R3[w2][g] ? true : false;
                else
                  K2 = true;
              }
              if (s && I2 && J2 && K2)
                break;
              w2++;
            }
            if (a2 && 0 < a2.length)
              for (g = 0; g < a2.length; g++)
                a2[g].calculateStripLinesThicknessInValues(), a2[g].calculateBreaksInPixels();
            if (d2 && 0 < d2.length)
              for (g = 0; g < d2.length; g++)
                d2[g].calculateStripLinesThicknessInValues(), d2[g].calculateBreaksInPixels();
            if (c2 && 0 < c2.length)
              for (g = 0; g < c2.length; g++)
                c2[g].calculateStripLinesThicknessInValues(), c2[g].calculateBreaksInPixels();
            if (b && 0 < b.length)
              for (g = 0; g < b.length; g++)
                b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();
          } else {
            p2 = [];
            C2 = [];
            E = [];
            v3 = [];
            B3 = [];
            u2 = [];
            N2 = [];
            for (P2 = []; 4 > w2; ) {
              W3 = V3 = S2 = Z3 = L = X2 = e = R3 = O2 = F = Y3 = 0;
              if (a2 && 0 < a2.length)
                for (E = [], g = V3 = 0; g < a2.length; g++)
                  E.push(Math.ceil(a2[g] ? a2[g].createLabelsAndCalculateWidth() : 0)), V3 += E[g], e += a2[g] && !m.isNavigator ? a2[g].margin : 0;
              else
                E.push(Math.ceil(a2[0] ? a2[0].createLabelsAndCalculateWidth() : 0));
              N2.push(E);
              if (d2 && 0 < d2.length)
                for (v3 = [], g = W3 = 0; g < d2.length; g++)
                  v3.push(Math.ceil(d2[g] ? d2[g].createLabelsAndCalculateWidth() : 0)), W3 += v3[g], X2 += d2[g] ? d2[g].margin : 0;
              else
                v3.push(Math.ceil(d2[0] ? d2[0].createLabelsAndCalculateWidth() : 0));
              P2.push(v3);
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  c2[g].lineCoordinates = {}, l2 = Math.round(f.x1 + V3 + e), n2 = Math.round(f.x2 - W3 - X2 > m.width - 10 ? m.width - 10 : f.x2 - W3 - X2), c2[g].labelAutoFit && !r(y) && (0 < !a2.length && (l2 = 0 > c2[g].labelAngle ? Math.max(l2, y) : 0 === c2[g].labelAngle ? Math.max(l2, y / 2) : l2), 0 < !d2.length && (n2 = 0 < c2[g].labelAngle ? n2 - x / 2 : 0 === c2[g].labelAngle ? n2 - x / 2 : n2)), c2[g].lineCoordinates.x1 = l2, c2[g].lineCoordinates.x2 = n2, c2[g].lineCoordinates.width = Math.abs(n2 - l2), c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.width ? c2[g].titleMaxWidth : c2[g].lineCoordinates.width);
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g].lineCoordinates = {}, l2 = Math.round(f.x1 + V3 + e), n2 = Math.round(f.x2 - W3 - X2 > b[g].chart.width - 10 ? b[g].chart.width - 10 : f.x2 - W3 - X2), b[g] && b[g].labelAutoFit && !r(z) && (0 < !a2.length && (l2 = 0 < b[g].labelAngle ? Math.max(l2, z) : 0 === b[g].labelAngle ? Math.max(l2, z / 2) : l2), 0 < !d2.length && (n2 -= A2 / 2)), b[g].lineCoordinates.x1 = l2, b[g].lineCoordinates.x2 = n2, b[g].lineCoordinates.width = Math.abs(n2 - l2), b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width);
              if (c2 && 0 < c2.length)
                for (p2 = [], g = S2 = 0; g < c2.length; g++)
                  p2.push(Math.ceil(c2[g] ? c2[g].createLabelsAndCalculateHeight() : 0)), S2 += p2[g] + c2[g].margin, L += c2[g].margin;
              else
                p2.push(Math.ceil(c2[0] ? c2[0].createLabelsAndCalculateHeight() : 0));
              B3.push(p2);
              if (b && 0 < b.length)
                for (C2 = [], g = 0; g < b.length; g++)
                  C2.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateHeight() : 0)), Z3 += b[g].margin;
              else
                C2.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
              u2.push(C2);
              if (c2 && 0 < c2.length)
                for (g = 0; g < c2.length; g++)
                  0 < c2[g]._labels.length && (k = c2[g]._labels[0], h2 = c2[g]._labels[c2[g]._labels.length - 1], y = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), x = h2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h2.textBlock.angle)) + (h2.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h2.textBlock.angle)));
              if (b && 0 < b.length)
                for (g = 0; g < b.length; g++)
                  b[g] && 0 < b[g]._labels.length && (k = b[g]._labels[0], h2 = b[g]._labels[b[g]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), A2 = h2.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h2.textBlock.angle)) + (h2.textBlock.height - h2.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h2.textBlock.angle)));
              if (m.panEnabled)
                for (g = 0; g < c2.length; g++)
                  p2[g] = r(m.sessionVariables.axisY.height) ? m.sessionVariables.axisY.height = p2[g] : m.sessionVariables.axisY.height;
              else
                for (g = 0; g < c2.length; g++)
                  m.sessionVariables.axisY.height = p2[g];
              if (c2 && 0 < c2.length)
                for (g = c2.length - 1; 0 <= g; g--)
                  h2 = Math.round(f.y2), k = Math.round(f.y2 > c2[g].chart.height ? c2[g].chart.height : f.y2), c2[g].lineCoordinates.y1 = h2 - (p2[g] + c2[g].margin + Y3), c2[g].lineCoordinates.y2 = h2 - (p2[g] + c2[g].margin + Y3), "inside" === c2[g].labelPlacement && 0 < g && (c2[g].lineCoordinates.y1 = c2[g].lineCoordinates.y1 + p2[g] - (c2[g]._titleTextBlock ? c2[g]._titleTextBlock.height : 0) - c2[g].tickLength - 5, c2[g].lineCoordinates.y2 = c2[g].lineCoordinates.y1 + c2[g].lineThickness / 2), "inside" === c2[g].tickPlacement && 0 < g && (c2[g].lineCoordinates.y1 += c2[g].tickLength, c2[g].lineCoordinates.y2 = c2[g].lineCoordinates.y1 + c2[g].lineThickness / 2), c2[g].bounds = { x1: l2, y1: h2 - (p2[g] + Y3 + c2[g].margin), x2: n2, y2: k - (Y3 + c2[g].margin), width: n2 - l2, height: p2[g] }, c2[g].title && (c2[g]._titleTextBlock.maxWidth = 0 < c2[g].titleMaxWidth && c2[g].titleMaxWidth < c2[g].lineCoordinates.width ? c2[g].titleMaxWidth : c2[g].lineCoordinates.width), Y3 += p2[g] + c2[g].margin;
              if (b && 0 < b.length)
                for (g = b.length - 1; 0 <= g; g--)
                  b[g] && (h2 = Math.round(f.y1), k = Math.round(f.y1 + (C2[g] + b[g].margin + F)), b[g].lineCoordinates.y1 = k, b[g].lineCoordinates.y2 = k, "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.y1 = k - C2[g] + (b[g]._titleTextBlock ? b[g]._titleTextBlock.height : 0) + b[g].tickLength, b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.y1 -= b[g].tickLength, b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), b[g].bounds = { x1: l2, y1: h2 + (b[g].margin + F), x2: n2, y2: k, width: n2 - l2 }, b[g].bounds.height = b[g].bounds.y2 - b[g].bounds.y1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width), F += C2[g] + b[g].margin);
              if (a2 && 0 < a2.length)
                for (g = 0; g < a2.length; g++) {
                  L = a2[g]._labels && 0 < a2[g]._labels.length ? a2[g]._labels[0].textBlock.fontSize / 2 : 0;
                  l2 = Math.round(f.x1 + e);
                  h2 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : f.y1 < Math.max(L, 10) ? Math.max(L, 10) : f.y1) : f.y1 < Math.max(L, 10) ? Math.max(L, 10) : f.y1;
                  n2 = Math.round(f.x1 + V3 + e);
                  k = c2 && 0 < c2.length ? Math.round(c2[0] ? c2[0].lineCoordinates.y1 : f.y2 - S2 > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : f.y2 - S2) : f.y2 > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : f.y2;
                  if (c2 && 0 < c2.length)
                    for (L = 0; L < c2.length; L++)
                      c2[L] && c2[L].labelAutoFit && (n2 = 0 > c2[L].labelAngle ? Math.max(n2, y) : 0 === c2[L].labelAngle ? Math.max(n2, y / 2) : n2, l2 = 0 > c2[L].labelAngle || 0 === c2[L].labelAngle ? n2 - V3 : l2);
                  if (b && 0 < b.length)
                    for (L = 0; L < b.length; L++)
                      b[L] && b[L].labelAutoFit && (n2 = b[L].lineCoordinates.x1, l2 = n2 - V3);
                  a2[g].lineCoordinates = { x1: n2 - O2, y1: h2, x2: n2 - O2, y2: k, height: Math.abs(k - h2) };
                  "inside" === a2[g].labelPlacement && 0 < g && (a2[g].lineCoordinates.x1 = a2[g].lineCoordinates.x1 - (E[g] - (a2[g]._titleTextBlock ? a2[g]._titleTextBlock.height : 0)) + a2[g].tickLength, a2[g].lineCoordinates.x2 = a2[g].lineCoordinates.x1 + a2[g].lineThickness / 2);
                  "inside" === a2[g].tickPlacement && 0 < g && (a2[g].lineCoordinates.x1 -= a2[g].tickLength, a2[g].lineCoordinates.x2 = a2[g].lineCoordinates.x1 + a2[g].lineThickness / 2);
                  a2[g].bounds = { x1: n2 - (E[g] + O2), y1: h2, x2: n2 - O2, y2: k, height: k - h2 };
                  a2[g].bounds.width = a2[g].bounds.x2 - a2[g].bounds.x1;
                  a2[g].title && (a2[g]._titleTextBlock.maxWidth = 0 < a2[g].titleMaxWidth && a2[g].titleMaxWidth < a2[g].lineCoordinates.height ? a2[g].titleMaxWidth : a2[g].lineCoordinates.height);
                  a2[g].calculateValueToPixelConversionParameters();
                  a2[g].calculateBreaksSizeInValues();
                  O2 += E[g] + a2[g].margin;
                }
              if (d2 && 0 < d2.length)
                for (g = 0; g < d2.length; g++) {
                  L = d2[g]._labels && 0 < d2[g]._labels.length ? d2[g]._labels[0].textBlock.fontSize / 2 : 0;
                  l2 = Math.round(f.x1 - e);
                  h2 = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : f.y1 < Math.max(L, 10) ? Math.max(L, 10) : f.y1) : f.y1 < Math.max(L, 10) ? Math.max(L, 10) : f.y1;
                  n2 = Math.round(f.x2 - W3 - X2);
                  k = c2 && 0 < c2.length ? Math.round(c2[0] ? c2[0].lineCoordinates.y1 : f.y2 - S2 > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : f.y2 - S2) : f.y2 > m.height - Math.max(L, 10) ? m.height - Math.max(L, 10) : f.y2;
                  if (c2 && 0 < c2.length)
                    for (L = 0; L < c2.length; L++)
                      c2[L] && c2[L].labelAutoFit && (n2 = 0 > c2[L].labelAngle ? Math.max(n2, y) : 0 === c2[L].labelAngle ? Math.max(n2, y / 2) : n2, l2 = 0 > c2[L].labelAngle || 0 === c2[L].labelAngle ? n2 - W3 : l2);
                  if (b && 0 < b.length)
                    for (L = 0; L < b.length; L++)
                      b[L] && b[L].labelAutoFit && (n2 = b[L].lineCoordinates.x2, l2 = n2 - W3);
                  d2[g].lineCoordinates = { x1: n2 + R3, y1: h2, x2: n2 + R3, y2: k, height: Math.abs(k - h2) };
                  "inside" === d2[g].labelPlacement && 0 < g && (d2[g].lineCoordinates.x1 = d2[g].lineCoordinates.x1 + (v3[g] - (d2[g]._titleTextBlock ? d2[g]._titleTextBlock.height : 0) - 2) - d2[g].tickLength, d2[g].lineCoordinates.x2 = d2[g].lineCoordinates.x1 + d2[g].lineThickness / 2);
                  "inside" === d2[g].tickPlacement && 0 < g && (d2[g].lineCoordinates.x1 += d2[g].tickLength, d2[g].lineCoordinates.x2 = d2[g].lineCoordinates.x1 + d2[g].lineThickness / 2);
                  d2[g].bounds = { x1: d2[g].lineCoordinates.x1, y1: h2, x2: n2 + v3[g] + R3, y2: k, width: n2 - l2, height: k - h2 };
                  d2[g].bounds.width = d2[g].bounds.x2 - d2[g].bounds.x1;
                  d2[g].title && (d2[g]._titleTextBlock.maxWidth = 0 < d2[g].titleMaxWidth && d2[g].titleMaxWidth < d2[g].lineCoordinates.height ? d2[g].titleMaxWidth : d2[g].lineCoordinates.height);
                  d2[g].calculateValueToPixelConversionParameters();
                  d2[g].calculateBreaksSizeInValues();
                  R3 += v3[g] + d2[g].margin;
                }
              for (g = 0; g < q.length; g++)
                "axisY" === q[g].type && (q[g].calculateValueToPixelConversionParameters(), q[g].calculateBreaksSizeInValues());
              if (0 < w2) {
                if (a2 && 0 < a2.length)
                  for (g = 0; g < a2.length; g++)
                    s = N2[w2 - 1][g] === N2[w2][g] ? true : false;
                else
                  s = true;
                if (d2 && 0 < d2.length)
                  for (g = 0; g < d2.length; g++)
                    I2 = P2[w2 - 1][g] === P2[w2][g] ? true : false;
                else
                  I2 = true;
                if (c2 && 0 < c2.length)
                  for (g = 0; g < c2.length; g++)
                    J2 = B3[w2 - 1][g] === B3[w2][g] ? true : false;
                else
                  J2 = true;
                if (b && 0 < b.length)
                  for (g = 0; g < b.length; g++)
                    K2 = u2[w2 - 1][g] === u2[w2][g] ? true : false;
                else
                  K2 = true;
              }
              if (s && I2 && J2 && K2)
                break;
              w2++;
            }
            if (c2 && 0 < c2.length)
              for (g = 0; g < c2.length; g++)
                c2[g].calculateStripLinesThicknessInValues(), c2[g].calculateBreaksInPixels();
            if (b && 0 < b.length)
              for (g = 0; g < b.length; g++)
                b[g].calculateStripLinesThicknessInValues(), b[g].calculateBreaksInPixels();
            if (a2 && 0 < a2.length)
              for (g = 0; g < a2.length; g++)
                a2[g].calculateStripLinesThicknessInValues(), a2[g].calculateBreaksInPixels();
            if (d2 && 0 < d2.length)
              for (g = 0; g < d2.length; g++)
                d2[g].calculateStripLinesThicknessInValues(), d2[g].calculateBreaksInPixels();
          }
        };
        A.render = function(a2, d2, c2, b, e) {
          var f = a2[0] ? a2[0].chart : d2[0].chart;
          e = f.ctx;
          f.alignVerticalAxes && f.alignVerticalAxes();
          e.save();
          e.beginPath();
          a2 && a2.length && e.rect(5, a2[0].bounds.y1, a2[0].chart.width - 10, a2[a2.length - 1].bounds.y2);
          d2 && d2.length && e.rect(5, d2[d2.length - 1].bounds.y1, d2[0].chart.width - 10, d2[0].bounds.y2);
          e.clip();
          if (a2 && 0 < a2.length)
            for (var l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderLabelsTicksAndTitle();
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderLabelsTicksAndTitle();
          e.restore();
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderLabelsTicksAndTitle();
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderLabelsTicksAndTitle();
          f.preparePlotArea();
          f = f.plotArea;
          e.save();
          e.beginPath();
          e.rect(f.x1, f.y1, Math.abs(f.x2 - f.x1), Math.abs(f.y2 - f.y1));
          e.clip();
          if (a2 && 0 < a2.length)
            for (l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderStripLinesOfThicknessType("value");
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderStripLinesOfThicknessType("value");
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderStripLinesOfThicknessType("value");
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderStripLinesOfThicknessType("value");
          if (a2 && 0 < a2.length)
            for (l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderInterlacedColors();
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderInterlacedColors();
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderInterlacedColors();
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderInterlacedColors();
          e.restore();
          if (a2 && 0 < a2.length)
            for (l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderGrid(), w && (a2[l2].createMask(), a2[l2].renderBreaksBackground());
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderGrid(), w && (d2[l2].createMask(), d2[l2].renderBreaksBackground());
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderGrid(), w && (c2[l2].createMask(), c2[l2].renderBreaksBackground());
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderGrid(), w && (b[l2].createMask(), b[l2].renderBreaksBackground());
          if (a2 && 0 < a2.length)
            for (l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderAxisLine();
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderAxisLine();
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderAxisLine();
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderAxisLine();
          if (a2 && 0 < a2.length)
            for (l2 = 0; l2 < a2.length; l2++)
              a2[l2].renderStripLinesOfThicknessType("pixel");
          if (d2 && 0 < d2.length)
            for (l2 = 0; l2 < d2.length; l2++)
              d2[l2].renderStripLinesOfThicknessType("pixel");
          if (c2 && 0 < c2.length)
            for (l2 = 0; l2 < c2.length; l2++)
              c2[l2].renderStripLinesOfThicknessType("pixel");
          if (b && 0 < b.length)
            for (l2 = 0; l2 < b.length; l2++)
              b[l2].renderStripLinesOfThicknessType("pixel");
        };
        A.prototype.calculateStripLinesThicknessInValues = function() {
          for (var a2 = 0; a2 < this.stripLines.length; a2++)
            if (null !== this.stripLines[a2].startValue && null !== this.stripLines[a2].endValue) {
              var d2 = Math.min(this.stripLines[a2].startValue, this.stripLines[a2].endValue), c2 = Math.max(this.stripLines[a2].startValue, this.stripLines[a2].endValue), d2 = this.getApparentDifference(d2, c2);
              this.stripLines[a2].value = this.logarithmic ? this.stripLines[a2].value * Math.sqrt(Math.log(Math.max(this.stripLines[a2].startValue, this.stripLines[a2].endValue) / Math.min(this.stripLines[a2].startValue, this.stripLines[a2].endValue)) / Math.log(d2)) : this.stripLines[a2].value + (Math.abs(this.stripLines[a2].endValue - this.stripLines[a2].startValue) - d2) / 2;
              this.stripLines[a2].thickness = d2;
              this.stripLines[a2]._thicknessType = "value";
            }
        };
        A.prototype.calculateBreaksSizeInValues = function() {
          for (var a2 = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, d2 = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c2 = this.conversionParameters.pixelPerUnit || a2 / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), b = this.scaleBreaks && !r(this.scaleBreaks.options.spacing), e, f = 0; f < d2.length; f++)
            e = b || !r(d2[f].options.spacing), d2[f].spacing = Ta(d2[f].spacing, a2, 8, e ? 0.1 * a2 : 8, e ? 0 : 3) << 0, d2[f].size = 0 > d2[f].spacing ? 0 : Math.abs(d2[f].spacing / c2), this.logarithmic && (d2[f].size = Math.pow(this.logarithmBase, d2[f].size));
        };
        A.prototype.calculateBreaksInPixels = function() {
          if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
            var a2 = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            a2.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
            for (var d2 = 0; d2 < a2.length && !(a2[d2].startValue > this.conversionParameters.maximum); d2++)
              a2[d2].endValue < this.conversionParameters.minimum || (r(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = d2), a2[d2].startValue >= this.conversionParameters.minimum && (a2[d2].startPixel = this.convertValueToPixel(a2[d2].startValue), this.scaleBreaks.lastBreakIndex = d2), a2[d2].endValue <= this.conversionParameters.maximum && (a2[d2].endPixel = this.convertValueToPixel(a2[d2].endValue)));
          }
        };
        A.prototype.renderLabelsTicksAndTitle = function() {
          var a2 = this, d2 = false, c2 = 0, b = 0, e = 1, f = 0;
          0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);
          if ("undefined" === typeof this.options.interval) {
            if ("bottom" === this._position || "top" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var c2 = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, l2, h2 = this.viewportMaximum, n2 = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
                  p2 = this._labels[k];
                  if (p2.position < this.viewportMinimum)
                    break;
                  p2.position > this.viewportMaximum || !(k === this._labels.length - 1 || l2 < Math.log(h2 / p2.position) * n2 / e) || (c2.push(p2), h2 = p2.position, l2 = p2.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p2.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = c2;
              } else {
                for (k = 0; k < this._labels.length; k++)
                  p2 = this._labels[k], p2.position < this.viewportMinimum || (l2 = p2.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p2.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c2 += l2);
                c2 > this.lineCoordinates.width * e && this.labelAutoFit && (d2 = true);
              }
            if ("left" === this._position || "right" === this._position)
              if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                for (var c2 = [], m, h2 = this.viewportMaximum, n2 = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
                  p2 = this._labels[k];
                  if (p2.position < this.viewportMinimum)
                    break;
                  p2.position > this.viewportMaximum || !(k === this._labels.length - 1 || m < Math.log(h2 / p2.position) * n2) || (c2.push(p2), h2 = p2.position, m = p2.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p2.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                }
                this._labels = c2;
              } else {
                for (k = 0; k < this._labels.length; k++)
                  p2 = this._labels[k], p2.position < this.viewportMinimum || (m = p2.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p2.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += m);
                b > this.lineCoordinates.height * e && this.labelAutoFit && (d2 = true);
              }
          }
          this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function(a3, b2) {
            return a3.position - b2.position;
          });
          var k = 0, p2, q;
          if ("bottom" === this._position) {
            for (k = 0; k < this._labels.length; k++)
              p2 = this._labels[k], p2.position < this.viewportMinimum || p2.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p2.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y + this.tickLength << 0), this.ctx.stroke()), d2 && 0 !== f++ % 2 && this.labelAutoFit || (0 === p2.textBlock.angle ? (q.x -= p2.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y - (("inside" === this.tickPlacement ? this.tickLength : 0) + p2.textBlock.height - p2.textBlock.fontSize / 2) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + p2.textBlock.fontSize / 2 + 5) : (q.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.x : q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : q.x - (0 > this.labelAngle ? p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? q.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - Math.abs(p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : q.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + Math.abs(0 > this.labelAngle ? p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p2.textBlock.x = q.x, p2.textBlock.y = q.y));
            "inside" === this.tickPlacement && this.chart.addEventListener(
              "dataAnimationIterationEnd",
              function() {
                for (k = 0; k < a2._labels.length; k++)
                  if (p2 = a2._labels[k], !(p2.position < a2.viewportMinimum || p2.position > a2.viewportMaximum) && (q = a2.getPixelCoordinatesOnAxis(p2.position), a2.tickThickness)) {
                    a2.ctx.lineWidth = a2.tickThickness;
                    a2.ctx.strokeStyle = a2.tickColor;
                    var b2 = 1 === a2.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;
                    a2.ctx.save();
                    a2.ctx.beginPath();
                    a2.ctx.moveTo(b2, q.y << 0);
                    a2.ctx.lineTo(b2, q.y - a2.tickLength << 0);
                    a2.ctx.stroke();
                    a2.ctx.restore();
                  }
              },
              this
            );
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("top" === this._position) {
            for (k = 0; k < this._labels.length; k++)
              p2 = this._labels[k], p2.position < this.viewportMinimum || p2.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p2.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0, this.ctx.beginPath(), this.ctx.moveTo(b, q.y << 0), this.ctx.lineTo(b, q.y - this.tickLength << 0), this.ctx.stroke()), d2 && 0 !== f++ % 2 && this.labelAutoFit || (0 === p2.textBlock.angle ? (q.x -= p2.textBlock.width / 2, q.y = "inside" === this.labelPlacement ? q.y + this.labelFontSize / 2 + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + p2.textBlock.height - p2.textBlock.fontSize / 2)) : (q.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.x : q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : q.x + (p2.textBlock.height - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), q.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? q.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + ((p2.textBlock.height - p2.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p2.textBlock.x = q.x, p2.textBlock.y = q.y));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a2._labels.length; k++)
                if (p2 = a2._labels[k], !(p2.position < a2.viewportMinimum || p2.position > a2.viewportMaximum) && (q = a2.getPixelCoordinatesOnAxis(p2.position), a2.tickThickness)) {
                  a2.ctx.lineWidth = a2.tickThickness;
                  a2.ctx.strokeStyle = a2.tickColor;
                  var b2 = 1 === a2.ctx.lineWidth % 2 ? (q.x << 0) + 0.5 : q.x << 0;
                  a2.ctx.save();
                  a2.ctx.beginPath();
                  a2.ctx.moveTo(b2, q.y << 0);
                  a2.ctx.lineTo(b2, q.y + a2.tickLength << 0);
                  a2.ctx.stroke();
                  a2.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("left" === this._position) {
            for (k = 0; k < this._labels.length; k++)
              p2 = this._labels[k], p2.position < this.viewportMinimum || p2.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p2.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x - this.tickLength << 0, b), this.ctx.stroke()), d2 && 0 !== f++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p2.textBlock.y = q.y, p2.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : (p2.textBlock.y = "inside" === this.labelPlacement ? q.y : q.y - p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p2.textBlock.x = "inside" === this.labelPlacement ? q.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : 0 < this.labelAngle ? q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 : q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p2.textBlock.height - p2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength))));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a2._labels.length; k++)
                if (p2 = a2._labels[k], !(p2.position < a2.viewportMinimum || p2.position > a2.viewportMaximum) && (q = a2.getPixelCoordinatesOnAxis(p2.position), a2.tickThickness)) {
                  a2.ctx.lineWidth = a2.tickThickness;
                  a2.ctx.strokeStyle = a2.tickColor;
                  var b2 = 1 === a2.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;
                  a2.ctx.save();
                  a2.ctx.beginPath();
                  a2.ctx.moveTo(q.x << 0, b2);
                  a2.ctx.lineTo(q.x + a2.tickLength << 0, b2);
                  a2.ctx.stroke();
                  a2.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          } else if ("right" === this._position) {
            for (k = 0; k < this._labels.length; k++)
              p2 = this._labels[k], p2.position < this.viewportMinimum || p2.position > this.viewportMaximum || (q = this.getPixelCoordinatesOnAxis(p2.position), this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0, this.ctx.beginPath(), this.ctx.moveTo(q.x << 0, b), this.ctx.lineTo(q.x + this.tickLength << 0, b), this.ctx.stroke()), d2 && 0 !== f++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (p2.textBlock.y = q.y, p2.textBlock.x = "inside" === this.labelPlacement ? q.x - p2.textBlock.width - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : (p2.textBlock.y = "inside" === this.labelPlacement ? q.y - p2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? q.y : q.y - (p2.textBlock.height - p2.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), p2.textBlock.x = "inside" === this.labelPlacement ? q.x - p2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : 0 < this.labelAngle ? q.x + (p2.textBlock.height - p2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) : q.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5)));
            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a2._labels.length; k++)
                if (p2 = a2._labels[k], !(p2.position < a2.viewportMinimum || p2.position > a2.viewportMaximum) && (q = a2.getPixelCoordinatesOnAxis(p2.position), a2.tickThickness)) {
                  a2.ctx.lineWidth = a2.tickThickness;
                  a2.ctx.strokeStyle = a2.tickColor;
                  var b2 = 1 === a2.ctx.lineWidth % 2 ? (q.y << 0) + 0.5 : q.y << 0;
                  a2.ctx.save();
                  a2.ctx.beginPath();
                  a2.ctx.moveTo(q.x << 0, b2);
                  a2.ctx.lineTo(q.x - a2.tickLength << 0, b2);
                  a2.ctx.stroke();
                  a2.ctx.restore();
                }
            }, this);
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(true));
          }
          f = 0;
          if ("inside" === this.labelPlacement)
            this.chart.addEventListener("dataAnimationIterationEnd", function() {
              for (k = 0; k < a2._labels.length; k++)
                p2 = a2._labels[k], p2.position < a2.viewportMinimum || (p2.position > a2.viewportMaximum || d2 && 0 !== f++ % 2 && a2.labelAutoFit) || (a2.ctx.save(), a2.ctx.beginPath(), p2.textBlock.render(true), a2.ctx.restore());
            }, this);
          else
            for (k = 0; k < this._labels.length; k++)
              p2 = this._labels[k], p2.position < this.viewportMinimum || (p2.position > this.viewportMaximum || d2 && 0 !== f++ % 2 && this.labelAutoFit) || p2.textBlock.render(true);
        };
        A.prototype.renderInterlacedColors = function() {
          var a2 = this.chart.plotArea.ctx, d2, c2, b = this.chart.plotArea, e = 0;
          d2 = true;
          if (("bottom" === this._position || "top" === this._position) && this.interlacedColor)
            for (a2.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              d2 ? (d2 = this.getPixelCoordinatesOnAxis(this._labels[e].position), c2 = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a2.fillRect(Math.min(c2.x, d2.x), b.y1, Math.abs(c2.x - d2.x), Math.abs(b.y1 - b.y2)), d2 = false) : d2 = true;
          else if (("left" === this._position || "right" === this._position) && this.interlacedColor)
            for (a2.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)
              d2 ? (c2 = this.getPixelCoordinatesOnAxis(this._labels[e].position), d2 = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a2.fillRect(b.x1, Math.min(c2.y, d2.y), Math.abs(b.x1 - b.x2), Math.abs(d2.y - c2.y)), d2 = false) : d2 = true;
          a2.beginPath();
        };
        A.prototype.renderStripLinesOfThicknessType = function(a2) {
          if (this.stripLines && 0 < this.stripLines.length && a2) {
            for (var d2 = this, c2, b = 0, e = 0, f = false, l2 = false, h2 = [], n2 = [], l2 = false, b = 0; b < this.stripLines.length; b++) {
              var k = this.stripLines[b];
              k._thicknessType === a2 && ("pixel" === a2 && (k.value < this.viewportMinimum || k.value > this.viewportMaximum || r(k.value) || isNaN(this.range)) || "value" === a2 && (k.startValue <= this.viewportMinimum && k.endValue <= this.viewportMinimum || k.startValue >= this.viewportMaximum && k.endValue >= this.viewportMaximum || r(k.startValue) || r(k.endValue) || isNaN(this.range)) || h2.push(k));
            }
            for (b = 0; b < this._stripLineLabels.length; b++)
              if (k = this.stripLines[b], c2 = this._stripLineLabels[b], !(c2.position < this.viewportMinimum || c2.position > this.viewportMaximum || isNaN(this.range))) {
                a2 = this.getPixelCoordinatesOnAxis(c2.position);
                if ("outside" === c2.stripLine.labelPlacement)
                  if (k && (this.ctx.strokeStyle = k.color, this.ctx.lineWidth = "pixel" === k._thicknessType ? k.thickness : this.tickThickness), "bottom" === this._position) {
                    var m = 1 === this.ctx.lineWidth % 2 ? (a2.x << 0) + 0.5 : a2.x << 0;
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                      m,
                      a2.y << 0
                    );
                    this.ctx.lineTo(m, a2.y + this.tickLength << 0);
                    this.ctx.stroke();
                    0 === this.labelAngle ? (a2.x -= c2.textBlock.width / 2, a2.y += this.tickLength + c2.textBlock.fontSize / 2 + 5) : (a2.x -= 0 > this.labelAngle ? c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a2.y += this.tickLength + Math.abs(0 > this.labelAngle ? c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                  } else
                    "top" === this._position ? (m = 1 === this.ctx.lineWidth % 2 ? (a2.x << 0) + 0.5 : a2.x << 0, this.ctx.beginPath(), this.ctx.moveTo(m, a2.y << 0), this.ctx.lineTo(m, a2.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a2.x -= c2.textBlock.width / 2, a2.y -= this.tickLength + c2.textBlock.height - c2.textBlock.fontSize / 2) : (a2.x += (c2.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a2.y -= this.tickLength + (c2.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (m = 1 === this.ctx.lineWidth % 2 ? (a2.y << 0) + 0.5 : a2.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a2.x << 0, m), this.ctx.lineTo(a2.x - this.tickLength << 0, m), this.ctx.stroke(), 0 === this.labelAngle ? a2.x = a2.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a2.y -= c2.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a2.x = 0 < this.labelAngle ? a2.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a2.x - c2.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (m = 1 === this.ctx.lineWidth % 2 ? (a2.y << 0) + 0.5 : a2.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a2.x << 0, m), this.ctx.lineTo(a2.x + this.tickLength << 0, m), this.ctx.stroke(), 0 === this.labelAngle ? a2.x = a2.x + this.tickLength + 5 : (a2.y = 0 > this.labelAngle ? a2.y : a2.y - (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a2.x = 0 < this.labelAngle ? a2.x + (c2.textBlock.height - c2.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a2.x + this.tickLength + 5));
                else
                  c2.textBlock.angle = -90, "bottom" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[b].labelMaxWidth ? this.options.stripLines[b].labelMaxWidth : this.chart.plotArea.height - 3, c2.textBlock.measureText(), a2.x - c2.textBlock.height - k.thickness / 2 > this.chart.plotArea.x1 ? r(k.startValue) ? a2.x -= c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.x -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : (c2.textBlock.angle = 90, r(k.startValue) ? a2.x += c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.x += c2.textBlock.height / 2 - c2.textBlock.fontSize / 2), a2.y = -90 === c2.textBlock.angle ? "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c2.textBlock.width) / 2 : this.chart.plotArea.y1 + c2.textBlock.width + 3 : "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y2 - c2.textBlock.width - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c2.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[b].labelMaxWidth ? this.options.stripLines[b].labelMaxWidth : this.chart.plotArea.height - 3, c2.textBlock.measureText(), a2.x - c2.textBlock.height - k.thickness / 2 > this.chart.plotArea.x1 ? r(k.startValue) ? a2.x -= c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.x -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : (c2.textBlock.angle = 90, r(k.startValue) ? a2.x += c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.x += c2.textBlock.height / 2 - c2.textBlock.fontSize / 2), a2.y = -90 === c2.textBlock.angle ? "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y1 + c2.textBlock.width + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c2.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === c2.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c2.textBlock.width) / 2 : this.chart.plotArea.y2 - c2.textBlock.width - 3) : "left" === this._position ? (c2.textBlock.maxWidth = this.options.stripLines[b].labelMaxWidth ? this.options.stripLines[b].labelMaxWidth : this.chart.plotArea.width - 3, c2.textBlock.angle = 0, c2.textBlock.measureText(), a2.y - c2.textBlock.height - k.thickness / 2 > this.chart.plotArea.y1 ? r(k.startValue) ? a2.y -= c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : r(k.startValue) ? a2.y += c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.y += c2.textBlock.height / 2 - c2.textBlock.fontSize + 3, a2.x = "near" === c2.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c2.textBlock.width / 2 : this.chart.plotArea.x2 - c2.textBlock.width - 3) : "right" === this._position && (c2.textBlock.maxWidth = this.options.stripLines[b].labelMaxWidth ? this.options.stripLines[b].labelMaxWidth : this.chart.plotArea.width - 3, c2.textBlock.angle = 0, c2.textBlock.measureText(), a2.y - c2.textBlock.height - k.thickness / 2 > this.chart.plotArea.y1 ? r(k.startValue) ? a2.y -= c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 : r(k.startValue) ? a2.y += c2.textBlock.height - c2.textBlock.fontSize / 2 + k.thickness / 2 : a2.y -= c2.textBlock.height / 2 - c2.textBlock.fontSize / 2 + 3, a2.x = "near" === c2.stripLine.labelAlign ? this.chart.plotArea.x2 - c2.textBlock.width - 3 : "center" === c2.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c2.textBlock.width / 2 : this.chart.plotArea.x1 + 3);
                c2.textBlock.x = a2.x;
                c2.textBlock.y = a2.y;
                n2.push(c2);
              }
            if (!l2) {
              l2 = false;
              this.ctx.save();
              this.ctx.beginPath();
              this.ctx.rect(
                this.chart.plotArea.x1,
                this.chart.plotArea.y1,
                this.chart.plotArea.width,
                this.chart.plotArea.height
              );
              this.ctx.clip();
              for (b = 0; b < h2.length; b++)
                k = h2[b], k.showOnTop ? f || (f = true, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                  this.ctx.clip();
                  for (e = 0; e < h2.length; e++)
                    k = h2[e], k.showOnTop && k.render();
                  this.ctx.restore();
                }, k)) : k.render();
              for (b = 0; b < n2.length; b++)
                c2 = n2[b], c2.stripLine.showOnTop ? l2 || (l2 = true, this.chart.addEventListener(
                  "dataAnimationIterationEnd",
                  function() {
                    for (e = 0; e < n2.length; e++)
                      c2 = n2[e], "inside" === c2.stripLine.labelPlacement && c2.stripLine.showOnTop && (d2.ctx.save(), d2.ctx.beginPath(), d2.ctx.rect(d2.chart.plotArea.x1, d2.chart.plotArea.y1, d2.chart.plotArea.width, d2.chart.plotArea.height), d2.ctx.clip(), c2.textBlock.render(true), d2.ctx.restore());
                  },
                  c2.textBlock
                )) : "inside" === c2.stripLine.labelPlacement && c2.textBlock.render(true);
              this.ctx.restore();
              l2 = true;
            }
            if (l2)
              for (l2 = false, b = 0; b < n2.length; b++)
                c2 = n2[b], "outside" === c2.stripLine.labelPlacement && c2.textBlock.render(true);
          }
        };
        A.prototype.renderBreaksBackground = function() {
          this.chart._breaksCanvas && (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore());
        };
        A.prototype.createMask = function() {
          if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
            var a2 = this.scaleBreaks._appliedBreaks;
            w ? (this.maskCanvas = ra(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);
            this.maskCtx.save();
            this.maskCtx.beginPath();
            this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.maskCtx.clip();
            for (var d2 = 0; d2 < a2.length; d2++)
              a2[d2].endValue < this.viewportMinimum || (a2[d2].startValue > this.viewportMaximum || isNaN(this.range)) || a2[d2].render(this.maskCtx);
            this.maskCtx.restore();
          }
        };
        A.prototype.renderCrosshair = function(a2, d2) {
          isFinite(this.minimum) && isFinite(this.maximum) && (this.crosshair.render(a2, d2), this.crosshair.dispatchEvent("updated", { chart: this.chart, crosshair: this.crosshair.options, axis: this, value: this.crosshair.value }, this));
        };
        A.prototype.showCrosshair = function(a2) {
          r(a2) || (a2 < this.viewportMinimum || a2 > this.viewportMaximum) || ("top" === this._position || "bottom" === this._position ? this.crosshair.render(this.convertValueToPixel(a2), null, a2) : this.crosshair.render(null, this.convertValueToPixel(a2), a2));
        };
        A.prototype.renderGrid = function() {
          if (this.gridThickness && 0 < this.gridThickness) {
            var a2 = this.chart.ctx;
            a2.save();
            var d2, c2 = this.chart.plotArea;
            a2.lineWidth = this.gridThickness;
            a2.strokeStyle = this.gridColor;
            a2.setLineDash && a2.setLineDash(J(this.gridDashType, this.gridThickness));
            if ("bottom" === this._position || "top" === this._position)
              for (b = 0; b < this._labels.length; b++)
                this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a2.beginPath(), d2 = this.getPixelCoordinatesOnAxis(this._labels[b].position), d2 = 1 === a2.lineWidth % 2 ? (d2.x << 0) + 0.5 : d2.x << 0, a2.moveTo(d2, c2.y1 << 0), a2.lineTo(d2, c2.y2 << 0), a2.stroke());
            else if ("left" === this._position || "right" === this._position)
              for (var b = 0; b < this._labels.length; b++)
                this._labels[b].position < this.viewportMinimum || (this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType) || (a2.beginPath(), d2 = this.getPixelCoordinatesOnAxis(this._labels[b].position), d2 = 1 === a2.lineWidth % 2 ? (d2.y << 0) + 0.5 : d2.y << 0, a2.moveTo(c2.x1 << 0, d2), a2.lineTo(c2.x2 << 0, d2), a2.stroke());
            a2.restore();
          }
        };
        A.prototype.renderAxisLine = function() {
          var a2 = this.chart.ctx, d2 = w ? this.chart._preRenderCtx : a2, c2 = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), b = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)), e, f;
          d2.save();
          if ("bottom" === this._position || "top" === this._position) {
            if (this.lineThickness) {
              this.reversed ? (e = this.lineCoordinates.x2, f = this.lineCoordinates.x1) : (e = this.lineCoordinates.x1, f = this.lineCoordinates.x2);
              d2.lineWidth = this.lineThickness;
              d2.strokeStyle = this.lineColor ? this.lineColor : "black";
              d2.setLineDash && d2.setLineDash(J(this.lineDashType, this.lineThickness));
              var l2 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;
              d2.beginPath();
              if (this.scaleBreaks && !r(this.scaleBreaks.firstBreakIndex))
                if (r(this.scaleBreaks.lastBreakIndex))
                  e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;
                else
                  for (var h2 = this.scaleBreaks.firstBreakIndex; h2 <= this.scaleBreaks.lastBreakIndex; h2++)
                    d2.moveTo(e, l2), d2.lineTo(this.scaleBreaks._appliedBreaks[h2].startPixel + c2, l2), e = this.scaleBreaks._appliedBreaks[h2].endPixel + b;
              e && (d2.moveTo(e, l2), d2.lineTo(f, l2));
              d2.stroke();
            }
          } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
            this.reversed ? (e = this.lineCoordinates.y1, f = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, f = this.lineCoordinates.y1);
            d2.lineWidth = this.lineThickness;
            d2.strokeStyle = this.lineColor;
            d2.setLineDash && d2.setLineDash(J(this.lineDashType, this.lineThickness));
            l2 = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;
            d2.beginPath();
            if (this.scaleBreaks && !r(this.scaleBreaks.firstBreakIndex))
              if (r(this.scaleBreaks.lastBreakIndex))
                e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c2;
              else
                for (h2 = this.scaleBreaks.firstBreakIndex; h2 <= this.scaleBreaks.lastBreakIndex; h2++)
                  d2.moveTo(l2, e), d2.lineTo(l2, this.scaleBreaks._appliedBreaks[h2].startPixel + b), e = this.scaleBreaks._appliedBreaks[h2].endPixel + c2;
            e && (d2.moveTo(l2, e), d2.lineTo(l2, f));
            d2.stroke();
          }
          w && (a2.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), d2.clearRect(0, 0, this.chart.width, this.chart.height));
          d2.restore();
        };
        A.prototype.getPixelCoordinatesOnAxis = function(a2) {
          var d2 = {};
          if ("bottom" === this._position || "top" === this._position)
            d2.x = this.convertValueToPixel(a2), d2.y = this.lineCoordinates.y1;
          if ("left" === this._position || "right" === this._position)
            d2.y = this.convertValueToPixel(a2), d2.x = this.lineCoordinates.x2;
          return d2;
        };
        A.prototype.convertPixelToValue = function(a2) {
          if ("undefined" === typeof a2)
            return null;
          var d2 = 0, c2 = 0, b, d2 = true, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c2 = "number" === typeof a2 ? a2 : "left" === this._position || "right" === this._position ? a2.y : a2.x;
          if (this.logarithmic) {
            a2 = b = Math.pow(this.logarithmBase, (c2 - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
            if (c2 <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (c2 = 0; c2 < e.length; c2++) {
                if (!(e[c2].endValue < this.conversionParameters.minimum))
                  if (d2)
                    if (e[c2].startValue < this.conversionParameters.minimum) {
                      if (1 < e[c2].size && this.conversionParameters.minimum * Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size)) < e[c2].endValue) {
                        a2 = Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size));
                        break;
                      } else
                        a2 *= e[c2].endValue / this.conversionParameters.minimum / Math.pow(e[c2].size, Math.log(e[c2].endValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue)), b /= Math.pow(e[c2].size, Math.log(e[c2].endValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue));
                      d2 = false;
                    } else if (b > e[c2].startValue / this.conversionParameters.minimum) {
                      b /= e[c2].startValue / this.conversionParameters.minimum;
                      if (b < e[c2].size) {
                        a2 *= Math.pow(e[c2].endValue / e[c2].startValue, 1 === e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) / b;
                        break;
                      } else
                        a2 *= e[c2].endValue / e[c2].startValue / e[c2].size;
                      b /= e[c2].size;
                      d2 = false;
                    } else
                      break;
                  else if (b > e[c2].startValue / e[c2 - 1].endValue) {
                    b /= e[c2].startValue / e[c2 - 1].endValue;
                    if (b < e[c2].size) {
                      a2 *= Math.pow(e[c2].endValue / e[c2].startValue, 1 === e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) / b;
                      break;
                    } else
                      a2 *= e[c2].endValue / e[c2].startValue / e[c2].size;
                    b /= e[c2].size;
                  } else
                    break;
              }
            else
              for (c2 = e.length - 1; 0 <= c2; c2--)
                if (!(e[c2].startValue > this.conversionParameters.minimum))
                  if (d2)
                    if (e[c2].endValue > this.conversionParameters.minimum) {
                      if (1 < e[c2].size && this.conversionParameters.minimum * Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size)) > e[c2].startValue) {
                        a2 = Math.pow(e[c2].endValue / e[c2].startValue, Math.log(b) / Math.log(e[c2].size));
                        break;
                      } else
                        a2 *= e[c2].startValue / this.conversionParameters.minimum * Math.pow(e[c2].size, Math.log(e[c2].startValue / this.conversionParameters.minimum) / Math.log(e[c2].endValue / e[c2].startValue)) * b, b *= Math.pow(e[c2].size, Math.log(this.conversionParameters.minimum / e[c2].startValue) / Math.log(e[c2].endValue / e[c2].startValue));
                      d2 = false;
                    } else if (b < e[c2].endValue / this.conversionParameters.minimum) {
                      b /= e[c2].endValue / this.conversionParameters.minimum;
                      if (b > 1 / e[c2].size) {
                        a2 *= Math.pow(e[c2].endValue / e[c2].startValue, 1 >= e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) * b;
                        break;
                      } else
                        a2 /= e[c2].endValue / e[c2].startValue / e[c2].size;
                      b *= e[c2].size;
                      d2 = false;
                    } else
                      break;
                  else if (b < e[c2].endValue / e[c2 + 1].startValue) {
                    b /= e[c2].endValue / e[c2 + 1].startValue;
                    if (b > 1 / e[c2].size) {
                      a2 *= Math.pow(e[c2].endValue / e[c2].startValue, 1 >= e[c2].size ? 1 : Math.log(b) / Math.log(e[c2].size)) * b;
                      break;
                    } else
                      a2 /= e[c2].endValue / e[c2].startValue / e[c2].size;
                    b *= e[c2].size;
                  } else
                    break;
            d2 = a2 * this.viewportMinimum;
          } else {
            a2 = b = (c2 - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
            if (c2 <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
              for (c2 = 0; c2 < e.length; c2++) {
                if (!(e[c2].endValue < this.conversionParameters.minimum))
                  if (d2)
                    if (e[c2].startValue < this.conversionParameters.minimum) {
                      if (e[c2].size && this.conversionParameters.minimum + b * (e[c2].endValue - e[c2].startValue) / e[c2].size < e[c2].endValue) {
                        a2 = 0 >= e[c2].size ? 0 : b * (e[c2].endValue - e[c2].startValue) / e[c2].size;
                        break;
                      } else
                        a2 += e[c2].endValue - this.conversionParameters.minimum - e[c2].size * (e[c2].endValue - this.conversionParameters.minimum) / (e[c2].endValue - e[c2].startValue), b -= e[c2].size * (e[c2].endValue - this.conversionParameters.minimum) / (e[c2].endValue - e[c2].startValue);
                      d2 = false;
                    } else if (b > e[c2].startValue - this.conversionParameters.minimum) {
                      b -= e[c2].startValue - this.conversionParameters.minimum;
                      if (b < e[c2].size) {
                        a2 += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) - b;
                        break;
                      } else
                        a2 += e[c2].endValue - e[c2].startValue - e[c2].size;
                      b -= e[c2].size;
                      d2 = false;
                    } else
                      break;
                  else if (b > e[c2].startValue - e[c2 - 1].endValue) {
                    b -= e[c2].startValue - e[c2 - 1].endValue;
                    if (b < e[c2].size) {
                      a2 += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) - b;
                      break;
                    } else
                      a2 += e[c2].endValue - e[c2].startValue - e[c2].size;
                    b -= e[c2].size;
                  } else
                    break;
              }
            else
              for (c2 = e.length - 1; 0 <= c2; c2--)
                if (!(e[c2].startValue > this.conversionParameters.minimum))
                  if (d2)
                    if (e[c2].endValue > this.conversionParameters.minimum)
                      if (e[c2].size && this.conversionParameters.minimum + b * (e[c2].endValue - e[c2].startValue) / e[c2].size > e[c2].startValue) {
                        a2 = 0 >= e[c2].size ? 0 : b * (e[c2].endValue - e[c2].startValue) / e[c2].size;
                        break;
                      } else
                        a2 += e[c2].startValue - this.conversionParameters.minimum + e[c2].size * (this.conversionParameters.minimum - e[c2].startValue) / (e[c2].endValue - e[c2].startValue), b += e[c2].size * (this.conversionParameters.minimum - e[c2].startValue) / (e[c2].endValue - e[c2].startValue), d2 = false;
                    else if (b < e[c2].endValue - this.conversionParameters.minimum) {
                      b -= e[c2].endValue - this.conversionParameters.minimum;
                      if (b > -1 * e[c2].size) {
                        a2 += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) + b;
                        break;
                      } else
                        a2 -= e[c2].endValue - e[c2].startValue - e[c2].size;
                      b += e[c2].size;
                      d2 = false;
                    } else
                      break;
                  else if (b < e[c2].endValue - e[c2 + 1].startValue) {
                    b -= e[c2].endValue - e[c2 + 1].startValue;
                    if (b > -1 * e[c2].size) {
                      a2 += (e[c2].endValue - e[c2].startValue) * (0 === e[c2].size ? 1 : b / e[c2].size) + b;
                      break;
                    } else
                      a2 -= e[c2].endValue - e[c2].startValue - e[c2].size;
                    b += e[c2].size;
                  } else
                    break;
            d2 = this.conversionParameters.minimum + a2;
          }
          return d2;
        };
        A.prototype.convertValueToPixel = function(a2) {
          a2 = this.getApparentDifference(
            this.conversionParameters.minimum,
            a2,
            a2
          );
          return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a2 / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a2 - this.conversionParameters.minimum) + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a2 - this.conversionParameters.minimum) + 0.5;
        };
        A.prototype.getApparentDifference = function(a2, d2, c2, b) {
          var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          if (this.logarithmic) {
            c2 = r(c2) ? d2 / a2 : c2;
            for (var f = 0; f < e.length && !(d2 < e[f].startValue); f++)
              a2 > e[f].endValue || (a2 <= e[f].startValue && d2 >= e[f].endValue ? c2 = c2 / e[f].endValue * e[f].startValue * e[f].size : a2 >= e[f].startValue && d2 >= e[f].endValue ? c2 = c2 / e[f].endValue * a2 * Math.pow(e[f].size, Math.log(e[f].endValue / a2) / Math.log(e[f].endValue / e[f].startValue)) : a2 <= e[f].startValue && d2 <= e[f].endValue ? c2 = c2 / d2 * e[f].startValue * Math.pow(e[f].size, Math.log(d2 / e[f].startValue) / Math.log(e[f].endValue / e[f].startValue)) : !b && (a2 > e[f].startValue && d2 < e[f].endValue) && (c2 = a2 * Math.pow(e[f].size, Math.log(d2 / a2) / Math.log(e[f].endValue / e[f].startValue))));
          } else
            for (c2 = r(c2) ? Math.abs(d2 - a2) : c2, f = 0; f < e.length && !(d2 < e[f].startValue); f++)
              a2 > e[f].endValue || (a2 <= e[f].startValue && d2 >= e[f].endValue ? c2 = c2 - e[f].endValue + e[f].startValue + e[f].size : a2 > e[f].startValue && d2 >= e[f].endValue ? c2 = c2 - e[f].endValue + a2 + e[f].size * (e[f].endValue - a2) / (e[f].endValue - e[f].startValue) : a2 <= e[f].startValue && d2 < e[f].endValue ? c2 = c2 - d2 + e[f].startValue + e[f].size * (d2 - e[f].startValue) / (e[f].endValue - e[f].startValue) : !b && (a2 > e[f].startValue && d2 < e[f].endValue) && (c2 = a2 + e[f].size * (d2 - a2) / (e[f].endValue - e[f].startValue)));
          return c2;
        };
        A.prototype.setViewPortRange = function(a2, d2) {
          this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a2, d2);
          this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a2, d2);
        };
        A.prototype.getXValueAt = function(a2) {
          if (!a2)
            return null;
          var d2 = null;
          "left" === this._position ? d2 = this.convertPixelToValue(a2.y) : "bottom" === this._position && (d2 = this.convertPixelToValue(a2.x));
          return d2;
        };
        A.prototype.calculateValueToPixelConversionParameters = function(a2) {
          a2 = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
          var d2 = { pixelPerUnit: null, minimum: null, reference: null }, c2 = this.lineCoordinates.width, b = this.lineCoordinates.height, c2 = "bottom" === this._position || "top" === this._position ? c2 : b, b = Math.abs(this.range);
          if (this.logarithmic)
            for (var e = 0; e < a2.length && !(this.viewportMaximum < a2[e].startValue); e++)
              this.viewportMinimum > a2[e].endValue || (this.viewportMinimum >= a2[e].startValue && this.viewportMaximum <= a2[e].endValue ? c2 = 0 : this.viewportMinimum <= a2[e].startValue && this.viewportMaximum >= a2[e].endValue ? (b = b / a2[e].endValue * a2[e].startValue, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100) : c2 - Math.min(a2[e].spacing, 0.1 * c2)) : this.viewportMinimum > a2[e].startValue && this.viewportMaximum >= a2[e].endValue ? (b = b / a2[e].endValue * this.viewportMinimum, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100 * Math.log(a2[e].endValue / this.viewportMinimum) / Math.log(a2[e].endValue / a2[e].startValue)) : c2 - Math.min(a2[e].spacing, 0.1 * c2) * Math.log(a2[e].endValue / this.viewportMinimum) / Math.log(a2[e].endValue / a2[e].startValue)) : this.viewportMinimum <= a2[e].startValue && this.viewportMaximum < a2[e].endValue && (b = b / this.viewportMaximum * a2[e].startValue, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100 * Math.log(this.viewportMaximum / a2[e].startValue) / Math.log(a2[e].endValue / a2[e].startValue)) : c2 - Math.min(a2[e].spacing, 0.1 * c2) * Math.log(this.viewportMaximum / a2[e].startValue) / Math.log(a2[e].endValue / a2[e].startValue)));
          else
            for (e = 0; e < a2.length && !(this.viewportMaximum < a2[e].startValue); e++)
              this.viewportMinimum > a2[e].endValue || (this.viewportMinimum >= a2[e].startValue && this.viewportMaximum <= a2[e].endValue ? c2 = 0 : this.viewportMinimum <= a2[e].startValue && this.viewportMaximum >= a2[e].endValue ? (b = b - a2[e].endValue + a2[e].startValue, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100) : c2 - Math.min(a2[e].spacing, 0.1 * c2)) : this.viewportMinimum > a2[e].startValue && this.viewportMaximum >= a2[e].endValue ? (b = b - a2[e].endValue + this.viewportMinimum, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100 * (a2[e].endValue - this.viewportMinimum) / (a2[e].endValue - a2[e].startValue)) : c2 - Math.min(a2[e].spacing, 0.1 * c2) * (a2[e].endValue - this.viewportMinimum) / (a2[e].endValue - a2[e].startValue)) : this.viewportMinimum <= a2[e].startValue && this.viewportMaximum < a2[e].endValue && (b = b - this.viewportMaximum + a2[e].startValue, c2 = 0 < a2[e].spacing.toString().indexOf("%") ? c2 * (1 - parseFloat(a2[e].spacing) / 100 * (this.viewportMaximum - a2[e].startValue) / (a2[e].endValue - a2[e].startValue)) : c2 - Math.min(a2[e].spacing, 0.1 * c2) * (this.viewportMaximum - a2[e].startValue) / (a2[e].endValue - a2[e].startValue)));
          d2.minimum = this.viewportMinimum;
          d2.maximum = this.viewportMaximum;
          d2.range = b;
          if ("bottom" === this._position || "top" === this._position)
            this.logarithmic ? (d2.lnLogarithmBase = Math.log(this.logarithmBase), d2.pixelPerUnit = (this.reversed ? -1 : 1) * c2 * d2.lnLogarithmBase / Math.log(Math.abs(b))) : d2.pixelPerUnit = (this.reversed ? -1 : 1) * c2 / Math.abs(b), d2.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
          if ("left" === this._position || "right" === this._position)
            this.logarithmic ? (d2.lnLogarithmBase = Math.log(this.logarithmBase), d2.pixelPerUnit = (this.reversed ? 1 : -1) * c2 * d2.lnLogarithmBase / Math.log(Math.abs(b))) : d2.pixelPerUnit = (this.reversed ? 1 : -1) * c2 / Math.abs(b), d2.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
          this.conversionParameters = d2;
        };
        A.prototype.calculateAxisParameters = function() {
          if (this.logarithmic)
            this.calculateLogarithmicAxisParameters();
          else {
            var a2 = this.chart.layoutManager.getFreeSpace(), d2 = false, c2 = false;
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a2.width, this.maxHeight = a2.height) : (this.maxWidth = a2.height, this.maxHeight = a2.width);
            var a2 = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, b = 4;
            "axisX" === this.type && (b = 600 > this.maxWidth ? 8 : 6);
            var a2 = Math.max(b, Math.floor(this.maxWidth / a2)), e, f, h2, b = 0;
            !r(this.options.viewportMinimum) && (!r(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null);
            if (r(this.options.viewportMinimum) && !r(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum))
              this.viewportMinimum = this.sessionVariables.newViewportMinimum;
            else if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
              this.viewportMinimum = this.minimum;
            if (r(this.options.viewportMaximum) && !r(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum))
              this.viewportMaximum = this.sessionVariables.newViewportMaximum;
            else if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
              this.viewportMaximum = this.maximum;
            if (this.scaleBreaks) {
              for (b = 0; b < this.scaleBreaks._appliedBreaks.length; b++)
                if ((!r(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue || !r(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[b].startValue || !r(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue) && (!r(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue || !r(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[b].endValue || !r(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue)) {
                  this.scaleBreaks._appliedBreaks.splice(b, 1);
                  break;
                }
            }
            if ("axisX" === this.type) {
              if (this.dataSeries && 0 < this.dataSeries.length)
                for (e = 0; e < this.dataSeries.length; e++)
                  "dateTime" === this.dataSeries[e].xValueType && (c2 = true);
              e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
              f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;
              0 === f - e && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, f += b, e -= b);
              Infinity !== this.dataInfo.minDiff ? h2 = this.dataInfo.minDiff : 1 < f - e ? h2 = 0.5 * Math.abs(f - e) : (h2 = 1, c2 && (d2 = true));
            } else
              "axisY" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(f) ? isFinite(e) ? isFinite(f) || (f = e) : e = f : (f = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === f ? (f += 9, e = 0) : 0 === f - e ? (b = Math.min(Math.abs(0.01 * Math.abs(f)), 5), f += b, e -= b) : e > f ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, e, null, true)), 5), 0 <= f ? e = f - b : f = isFinite(e) ? e + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(
                e,
                f,
                null,
                true
              )), 0.05), 0 !== f && (f += b), 0 !== e && (e -= b)), h2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - e ? 0.5 * Math.abs(f - e) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > f && (f = 0));
            b = this.getApparentDifference(
              isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum,
              isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum,
              null,
              true
            );
            if ("axisX" === this.type && c2) {
              this.valueType = "dateTime";
              this.intervalType || (b / 1 <= a2 ? (this.interval = 1, this.intervalType = "millisecond") : b / 2 <= a2 ? (this.interval = 2, this.intervalType = "millisecond") : b / 5 <= a2 ? (this.interval = 5, this.intervalType = "millisecond") : b / 10 <= a2 ? (this.interval = 10, this.intervalType = "millisecond") : b / 20 <= a2 ? (this.interval = 20, this.intervalType = "millisecond") : b / 50 <= a2 ? (this.interval = 50, this.intervalType = "millisecond") : b / 100 <= a2 ? (this.interval = 100, this.intervalType = "millisecond") : b / 200 <= a2 ? (this.interval = 200, this.intervalType = "millisecond") : b / 250 <= a2 ? (this.interval = 250, this.intervalType = "millisecond") : b / 300 <= a2 ? (this.interval = 300, this.intervalType = "millisecond") : b / 400 <= a2 ? (this.interval = 400, this.intervalType = "millisecond") : b / 500 <= a2 ? (this.interval = 500, this.intervalType = "millisecond") : b / (1 * I.secondDuration) <= a2 ? (this.interval = 1, this.intervalType = "second") : b / (2 * I.secondDuration) <= a2 ? (this.interval = 2, this.intervalType = "second") : b / (5 * I.secondDuration) <= a2 ? (this.interval = 5, this.intervalType = "second") : b / (10 * I.secondDuration) <= a2 ? (this.interval = 10, this.intervalType = "second") : b / (15 * I.secondDuration) <= a2 ? (this.interval = 15, this.intervalType = "second") : b / (20 * I.secondDuration) <= a2 ? (this.interval = 20, this.intervalType = "second") : b / (30 * I.secondDuration) <= a2 ? (this.interval = 30, this.intervalType = "second") : b / (1 * I.minuteDuration) <= a2 ? (this.interval = 1, this.intervalType = "minute") : b / (2 * I.minuteDuration) <= a2 ? (this.interval = 2, this.intervalType = "minute") : b / (5 * I.minuteDuration) <= a2 ? (this.interval = 5, this.intervalType = "minute") : b / (10 * I.minuteDuration) <= a2 ? (this.interval = 10, this.intervalType = "minute") : b / (15 * I.minuteDuration) <= a2 ? (this.interval = 15, this.intervalType = "minute") : b / (20 * I.minuteDuration) <= a2 ? (this.interval = 20, this.intervalType = "minute") : b / (30 * I.minuteDuration) <= a2 ? (this.interval = 30, this.intervalType = "minute") : b / (1 * I.hourDuration) <= a2 ? (this.interval = 1, this.intervalType = "hour") : b / (2 * I.hourDuration) <= a2 ? (this.interval = 2, this.intervalType = "hour") : b / (3 * I.hourDuration) <= a2 ? (this.interval = 3, this.intervalType = "hour") : b / (6 * I.hourDuration) <= a2 ? (this.interval = 6, this.intervalType = "hour") : b / (1 * I.dayDuration) <= a2 ? (this.interval = 1, this.intervalType = "day") : b / (2 * I.dayDuration) <= a2 ? (this.interval = 2, this.intervalType = "day") : b / (4 * I.dayDuration) <= a2 ? (this.interval = 4, this.intervalType = "day") : b / (1 * I.weekDuration) <= a2 ? (this.interval = 1, this.intervalType = "week") : b / (2 * I.weekDuration) <= a2 ? (this.interval = 2, this.intervalType = "week") : b / (3 * I.weekDuration) <= a2 ? (this.interval = 3, this.intervalType = "week") : b / (1 * I.monthDuration) <= a2 ? (this.interval = 1, this.intervalType = "month") : b / (2 * I.monthDuration) <= a2 ? (this.interval = 2, this.intervalType = "month") : b / (3 * I.monthDuration) <= a2 ? (this.interval = 3, this.intervalType = "month") : b / (6 * I.monthDuration) <= a2 ? (this.interval = 6, this.intervalType = "month") : (this.interval = b / (1 * I.yearDuration) <= a2 ? 1 : b / (2 * I.yearDuration) <= a2 ? 2 : b / (4 * I.yearDuration) <= a2 ? 4 : Math.floor(A.getNiceNumber(b / (a2 - 1), true) / I.yearDuration), this.intervalType = "year"));
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = e - h2 / 2;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = f + h2 / 2;
              d2 ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
              this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);
            } else {
              this.intervalType = "number";
              b = A.getNiceNumber(b, false);
              this.interval = this.options && 0 < this.options.interval ? this.options.interval : A.getNiceNumber(b / (a2 - 1), true);
              if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
                this.viewportMinimum = "axisX" === this.type ? e - h2 / 2 : Math.floor(e / this.interval) * this.interval;
              if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
                this.viewportMaximum = "axisX" === this.type ? f + h2 / 2 : Math.ceil(f / this.interval) * this.interval;
              0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = A.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a2 - 1), true)));
            }
            if (null === this.minimum || null === this.maximum)
              if ("axisX" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === f - e && (b = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, f += b, e -= b), h2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - e ? 0.5 * Math.abs(f - e) : 1) : "axisY" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, f = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(f) ? 0 === e && 0 === f ? (f += 9, e = 0) : 0 === f - e ? (b = Math.min(
                Math.abs(0.01 * Math.abs(f)),
                5
              ), f += b, e -= b) : e > f ? (b = Math.min(0.01 * Math.abs(this.getApparentDifference(f, e, null, true)), 5), 0 <= f ? e = f - b : f = isFinite(e) ? e + b : 0) : (b = Math.min(0.01 * Math.abs(this.getApparentDifference(e, f, null, true)), 0.05), 0 !== f && (f += b), 0 !== e && (e -= b)) : (f = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), h2 = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < f - e ? 0.5 * Math.abs(f - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > f && (f = 0)), Math.abs(this.getApparentDifference(e, f, null, true)), "axisX" === this.type && c2) {
                this.valueType = "dateTime";
                if (null === this.minimum || isNaN(this.minimum))
                  this.minimum = e - h2 / 2, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum);
                if (null === this.maximum || isNaN(this.maximum))
                  this.maximum = f + h2 / 2, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum);
              } else
                this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? e - h2 / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? f + h2 / 2 : Math.ceil(f / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
            r(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
            r(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
            this.range = this.viewportMaximum - this.viewportMinimum;
            this.intervalStartPosition = "axisX" === this.type && c2 ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;
            this.valueFormatString || (this.valueFormatString = A.generateValueFormatString(this.range, 2));
          }
        };
        A.prototype.calculateLogarithmicAxisParameters = function() {
          var a2 = this.chart.layoutManager.getFreeSpace(), d2 = Math.log(this.logarithmBase), c2;
          "bottom" === this._position || "top" === this._position ? (this.maxWidth = a2.width, this.maxHeight = a2.height) : (this.maxWidth = a2.height, this.maxHeight = a2.width);
          var a2 = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3), b, e, f, h2;
          h2 = 1;
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = this.minimum;
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = this.maximum;
          if (this.scaleBreaks) {
            for (h2 = 0; h2 < this.scaleBreaks._appliedBreaks.length; h2++)
              if ((!r(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[h2].startValue || !r(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[h2].startValue || !r(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[h2].startValue) && (!r(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[h2].endValue || !r(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[h2].endValue || !r(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[h2].endValue)) {
                this.scaleBreaks._appliedBreaks.splice(h2, 1);
                break;
              }
          }
          "axisX" === this.type ? (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / b && (h2 = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h2, b /= h2), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / b > this.logarithmBase ? e / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= b && !isFinite(e) ? (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1) : 0 >= b ? b = e : isFinite(e) || (e = b), 1 === b && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, b = 1) : 1 === e / b ? (h2 = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= h2, b /= h2) : b > e ? (h2 = Math.min(b / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? b = e / h2 : e = b * h2) : (h2 = Math.min(e / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h2), 1 !== b && (b /= h2)), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / b > this.logarithmBase ? e / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < b && (b = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));
          h2 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          var n2 = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
          this.intervalType = "number";
          h2 = Math.pow(this.logarithmBase, A.getNiceNumber(Math.abs(Math.log(h2) / d2), false));
          this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = A.getNiceExponent(Math.log(h2) / d2 / (a2 - 1), true), c2 = A.getNiceNumber(n2 / (a2 - 1), true));
          if (null === this.viewportMinimum || isNaN(this.viewportMinimum))
            this.viewportMinimum = "axisX" === this.type ? b / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / d2 / this.interval));
          if (null === this.viewportMaximum || isNaN(this.viewportMaximum))
            this.viewportMaximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d2 / this.interval));
          1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = A.getNiceExponent(Math.ceil(Math.log(h2) / d2) / (a2 - 1)), c2 = A.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a2 - 1), true)));
          if (null === this.minimum || null === this.maximum)
            "axisX" === this.type ? (b = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / b && (h2 = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h2, b /= h2), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / b > this.logarithmBase ? e / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(b) || isFinite(e) ? 1 === b && 1 === e ? (e *= this.logarithmBase, b /= this.logarithmBase) : 1 === e / b ? (h2 = Math.pow(this.logarithmBase, this.interval), e *= h2, b /= h2) : b > e ? (h2 = Math.min(0.01 * (b / e), 5), 1 <= e ? b = e / h2 : e = b * h2) : (h2 = Math.min(e / b * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h2), 1 !== b && (b /= h2)) : (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, b = 1), f = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / b > this.logarithmBase ? e / b * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < b && (b = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? b / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / d2 / this.interval)), r(null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum) || (this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum))), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / d2 / this.interval)), r(null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum) || (this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum))), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
          this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
          this.viewportMaximum = Math.min(
            this.viewportMaximum,
            this.maximum
          );
          this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
          b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d2 * this.interval) + 0.2) * this.interval);
          this.range = this.viewportMaximum / this.viewportMinimum;
          this.noTicks = a2;
          if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a2 ? 2 : 3)) {
            for (d2 = Math.floor(this.viewportMinimum / c2 + 0.5) * c2; d2 < this.viewportMinimum; )
              d2 += c2;
            this.equidistantInterval = false;
            this.intervalStartPosition = d2;
            this.interval = c2;
          } else
            this.options.interval || (c2 = Math.ceil(this.interval), this.range > this.interval && (this.interval = c2, b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (d2 * this.interval) + 0.2) * this.interval))), this.equidistantInterval = true, this.intervalStartPosition = b;
          if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
            d2 = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
            if (isNaN(d2) || !isFinite(d2))
              d2 = 2;
            if (2 < d2)
              for (h2 = 0; h2 < d2 - 2; h2++)
                this.valueFormatString += "#";
          }
        };
        A.generateValueFormatString = function(a2, d2) {
          var c2 = "#,##0.", b = d2;
          1 > a2 && (b += Math.floor(Math.abs(Math.log(a2) / Math.LN10)), isNaN(b) || !isFinite(b)) && (b = d2);
          for (var e = 0; e < b; e++)
            c2 += "#";
          return c2;
        };
        A.getNiceExponent = function(a2, d2) {
          var c2 = Math.floor(Math.log(a2) / Math.LN10), b = a2 / Math.pow(10, c2), b = 0 > c2 ? 1 >= b ? 1 : 5 >= b ? 5 : 10 : Math.max(Math.floor(b), 1);
          return -20 > c2 ? Number(b * Math.pow(10, c2)) : Number((b * Math.pow(10, c2)).toFixed(20));
        };
        A.getNiceNumber = function(a2, d2) {
          var c2 = Math.floor(Math.log(a2) / Math.LN10), b = a2 / Math.pow(10, c2), b = d2 ? 1.5 > b ? 1 : 3 > b ? 2 : 7 > b ? 5 : 10 : 1 >= b ? 1 : 2 >= b ? 2 : 5 >= b ? 5 : 10;
          return -20 > c2 ? Number(b * Math.pow(10, c2)) : Number((b * Math.pow(10, c2)).toFixed(20));
        };
        A.prototype.getLabelStartPoint = function() {
          var a2 = I[this.intervalType + "Duration"] * this.interval, a2 = new Date(Math.floor(this.viewportMinimum / a2) * a2);
          if ("millisecond" !== this.intervalType)
            if ("second" === this.intervalType)
              0 < a2.getMilliseconds() && (a2.setSeconds(a2.getSeconds() + 1), a2.setMilliseconds(0));
            else if ("minute" === this.intervalType) {
              if (0 < a2.getSeconds() || 0 < a2.getMilliseconds())
                a2.setMinutes(a2.getMinutes() + 1), a2.setSeconds(0), a2.setMilliseconds(0);
            } else if ("hour" === this.intervalType) {
              if (0 < a2.getMinutes() || 0 < a2.getSeconds() || 0 < a2.getMilliseconds())
                a2.setHours(a2.getHours() + 1), a2.setMinutes(0), a2.setSeconds(0), a2.setMilliseconds(0);
            } else if ("day" === this.intervalType) {
              if (0 < a2.getHours() || 0 < a2.getMinutes() || 0 < a2.getSeconds() || 0 < a2.getMilliseconds())
                a2.setDate(a2.getDate() + 1), a2.setHours(0), a2.setMinutes(0), a2.setSeconds(0), a2.setMilliseconds(0);
            } else if ("week" === this.intervalType) {
              if (0 < a2.getDay() || 0 < a2.getHours() || 0 < a2.getMinutes() || 0 < a2.getSeconds() || 0 < a2.getMilliseconds())
                a2.setDate(a2.getDate() + (7 - a2.getDay())), a2.setHours(0), a2.setMinutes(0), a2.setSeconds(0), a2.setMilliseconds(0);
            } else if ("month" === this.intervalType) {
              if (1 < a2.getDate() || 0 < a2.getHours() || 0 < a2.getMinutes() || 0 < a2.getSeconds() || 0 < a2.getMilliseconds())
                a2.setMonth(a2.getMonth() + 1), a2.setDate(1), a2.setHours(0), a2.setMinutes(0), a2.setSeconds(0), a2.setMilliseconds(0);
            } else
              "year" === this.intervalType && (0 < a2.getMonth() || 1 < a2.getDate() || 0 < a2.getHours() || 0 < a2.getMinutes() || 0 < a2.getSeconds() || 0 < a2.getMilliseconds()) && (a2.setFullYear(a2.getFullYear() + 1), a2.setMonth(0), a2.setDate(1), a2.setHours(0), a2.setMinutes(0), a2.setSeconds(0), a2.setMilliseconds(0));
          return a2;
        };
        na(V2, X);
        na(da2, X);
        da2.prototype.createUserOptions = function(a2) {
          if ("undefined" !== typeof a2 || this.options._isPlaceholder) {
            var d2 = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ea(this.parent[this.optionsName]), d2 = this.parent.options[this.optionsName].indexOf(this.options));
            this.options = "undefined" === typeof a2 ? {} : a2;
            this.parent.options[this.optionsName][d2] = this.options;
          }
        };
        da2.prototype.render = function(a2) {
          if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
            var d2 = this.ctx, c2 = this.ctx.globalAlpha;
            this.ctx = a2 || this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
            this.ctx.clip();
            var b = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
            this.ctx.strokeStyle = this.lineColor;
            this.ctx.fillStyle = this.color;
            this.ctx.beginPath();
            this.ctx.globalAlpha = 1;
            O(this.id);
            var f, h2, n2, r2, k, m;
            a2 = Math.max(this.spacing, 3);
            var p2 = Math.max(0, this.lineThickness);
            this.ctx.lineWidth = p2;
            this.ctx.setLineDash && this.ctx.setLineDash(J(this.lineDashType, p2));
            if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position)
              if (b = 1 === p2 % 2 ? (b.x << 0) + 0.5 : b.x << 0, h2 = 1 === p2 % 2 ? (e.x << 0) + 0.5 : e.x << 0, "top" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, n2 = this.chart.plotArea.y2 + p2 / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, n2 = this.chart.plotArea.y1 - p2 / 2 + 0.5 << 0, a2 *= -1), this.bounds = { x1: b - p2 / 2, y1: e, x2: h2 + p2 / 2, y2: n2 }, this.ctx.moveTo(b, e), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= a2 || "bottom" === this.scaleBreaks.parent._position && 0 <= a2)
                this.ctx.lineTo(b, n2), this.ctx.lineTo(h2, n2), this.ctx.lineTo(h2, e);
              else if ("wavy" === this.type) {
                r2 = b;
                k = e;
                f = 0.5;
                m = (n2 - k) / a2 / 3;
                for (var q = 0; q < m; q++)
                  this.ctx.bezierCurveTo(r2 + f * a2, k + a2, r2 + f * a2, k + 2 * a2, r2, k + 3 * a2), k += 3 * a2, f *= -1;
                this.ctx.bezierCurveTo(
                  r2 + f * a2,
                  k + a2,
                  r2 + f * a2,
                  k + 2 * a2,
                  r2,
                  k + 3 * a2
                );
                r2 = h2;
                f *= -1;
                this.ctx.lineTo(r2, k);
                for (q = 0; q < m; q++)
                  this.ctx.bezierCurveTo(r2 + f * a2, k - a2, r2 + f * a2, k - 2 * a2, r2, k - 3 * a2), k -= 3 * a2, f *= -1;
              } else {
                if ("zigzag" === this.type) {
                  f = -1;
                  k = e + a2;
                  r2 = b + a2;
                  m = (n2 - k) / a2 / 2;
                  for (q = 0; q < m; q++)
                    this.ctx.lineTo(r2, k), r2 += 2 * f * a2, k += 2 * a2, f *= -1;
                  this.ctx.lineTo(r2, k);
                  r2 += h2 - b;
                  for (q = 0; q < m + 1; q++)
                    this.ctx.lineTo(r2, k), r2 += 2 * f * a2, k -= 2 * a2, f *= -1;
                  this.ctx.lineTo(r2 + f * a2, k + a2);
                }
              }
            else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) {
              if (e = 1 === p2 % 2 ? (e.y << 0) + 0.5 : e.y << 0, n2 = 1 === p2 % 2 ? (b.y << 0) + 0.5 : b.y << 0, "left" === this.scaleBreaks.parent._position ? (b = this.chart.plotArea.x1, h2 = this.chart.plotArea.x2 + p2 / 2 + 0.5 << 0) : (b = this.chart.plotArea.x2, h2 = this.chart.plotArea.x1 - p2 / 2 + 0.5 << 0, a2 *= -1), this.bounds = { x1: b, y1: e - p2 / 2, x2: h2, y2: n2 + p2 / 2 }, this.ctx.moveTo(b, e), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a2 || "right" === this.scaleBreaks.parent._position && 0 <= a2)
                this.ctx.lineTo(h2, e), this.ctx.lineTo(h2, n2), this.ctx.lineTo(b, n2);
              else if ("wavy" === this.type) {
                r2 = b;
                k = e;
                f = 0.5;
                m = (h2 - r2) / a2 / 3;
                for (q = 0; q < m; q++)
                  this.ctx.bezierCurveTo(r2 + a2, k + f * a2, r2 + 2 * a2, k + f * a2, r2 + 3 * a2, k), r2 += 3 * a2, f *= -1;
                this.ctx.bezierCurveTo(r2 + a2, k + f * a2, r2 + 2 * a2, k + f * a2, r2 + 3 * a2, k);
                k = n2;
                f *= -1;
                this.ctx.lineTo(r2, k);
                for (q = 0; q < m; q++)
                  this.ctx.bezierCurveTo(r2 - a2, k + f * a2, r2 - 2 * a2, k + f * a2, r2 - 3 * a2, k), r2 -= 3 * a2, f *= -1;
              } else if ("zigzag" === this.type) {
                f = 1;
                k = e - a2;
                r2 = b + a2;
                m = (h2 - r2) / a2 / 2;
                for (q = 0; q < m; q++)
                  this.ctx.lineTo(r2, k), k += 2 * f * a2, r2 += 2 * a2, f *= -1;
                this.ctx.lineTo(r2, k);
                k += n2 - e;
                for (q = 0; q < m + 1; q++)
                  this.ctx.lineTo(r2, k), k += 2 * f * a2, r2 -= 2 * a2, f *= -1;
                this.ctx.lineTo(r2 + a2, k + f * a2);
              }
            }
            0 < p2 && this.ctx.stroke();
            this.ctx.closePath();
            this.ctx.globalAlpha = this.fillOpacity;
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.fill();
            this.ctx.restore();
            this.ctx.globalAlpha = c2;
            this.ctx = d2;
          }
        };
        na(P, X);
        P.prototype.createUserOptions = function(a2) {
          if ("undefined" !== typeof a2 || this.options._isPlaceholder) {
            var d2 = 0;
            this.parent.options._isPlaceholder && this.parent.createUserOptions();
            this.options._isPlaceholder || (Ea(this.parent.stripLines), d2 = this.parent.options.stripLines.indexOf(this.options));
            this.options = "undefined" === typeof a2 ? {} : a2;
            this.parent.options.stripLines[d2] = this.options;
          }
        };
        P.prototype.render = function() {
          this.ctx.save();
          var a2 = this.parent.getPixelCoordinatesOnAxis(this.value), d2 = Math.abs("pixel" === this._thicknessType ? this.thickness : Math.abs(this.parent.convertValueToPixel(this.endValue) - this.parent.convertValueToPixel(this.startValue)));
          if (0 < d2) {
            var c2 = null === this.opacity ? 1 : this.opacity;
            this.ctx.strokeStyle = this.color;
            this.ctx.beginPath();
            var b = this.ctx.globalAlpha;
            this.ctx.globalAlpha = c2;
            O(this.id);
            var e, f, h2, n2;
            this.ctx.lineWidth = d2;
            this.ctx.setLineDash && this.ctx.setLineDash(J(this.lineDashType, d2));
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              e = f = 1 === this.ctx.lineWidth % 2 ? (a2.x << 0) + 0.5 : a2.x << 0, h2 = this.chart.plotArea.y1, n2 = this.chart.plotArea.y2, this.bounds = { x1: e - d2 / 2, y1: h2, x2: f + d2 / 2, y2: n2 };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              h2 = n2 = 1 === this.ctx.lineWidth % 2 ? (a2.y << 0) + 0.5 : a2.y << 0, e = this.chart.plotArea.x1, f = this.chart.plotArea.x2, this.bounds = {
                x1: e,
                y1: h2 - d2 / 2,
                x2: f,
                y2: n2 + d2 / 2
              };
            this.ctx.moveTo(e, h2);
            this.ctx.lineTo(f, n2);
            this.ctx.stroke();
            this.ctx.globalAlpha = b;
          }
          this.ctx.restore();
        };
        na(Y2, X);
        Y2.prototype.showAt = function(a2) {
          if (!this.enabled)
            return false;
          var d2 = this.chart, c2 = false;
          d2.resetOverlayedCanvas();
          d2.clearedOverlayedCanvas = this.parent.type;
          this.chart.renderCrosshairs(this.parent);
          if ("xySwapped" === d2.plotInfo.axisPlacement)
            if ("bottom" === this.parent._position)
              for (var b = 0; b < d2.axisY.length; b++)
                this.parent === d2.axisY[b] && (d2.axisY[b]._crosshairValue = a2 >= d2.axisY[b].viewportMinimum && a2 <= d2.axisY[b].viewportMaximum ? a2 : null);
            else if ("top" === this.parent._position)
              for (b = 0; b < d2.axisY2.length; b++)
                this.parent === d2.axisY2[b] && (d2.axisY2[b]._crosshairValue = a2 >= d2.axisY2[b].viewportMinimum && a2 <= d2.axisY2[b].viewportMaximum ? a2 : null);
            else if ("left" === this.parent._position)
              for (b = 0; b < d2.axisX.length; b++)
                this.parent === d2.axisX[b] && (d2.axisX[b]._crosshairValue = a2 >= d2.axisX[b].viewportMinimum && a2 <= d2.axisX[b].viewportMaximum ? a2 : null);
            else {
              if ("right" === this.parent._position)
                for (b = 0; b < d2.axisX2.length; b++)
                  this.parent === d2.axisX2[b] && (d2.axisX2[b]._crosshairValue = a2 >= d2.axisX2[b].viewportMinimum && a2 <= d2.axisX2[b].viewportMaximum ? a2 : null);
            }
          else if ("bottom" === this.parent._position)
            for (b = 0; b < d2.axisX.length; b++)
              this.parent === d2.axisX[b] && (d2.axisX[b]._crosshairValue = a2 >= d2.axisX[b].viewportMinimum && a2 <= d2.axisX[b].viewportMaximum ? a2 : null);
          else if ("top" === this.parent._position)
            for (b = 0; b < d2.axisX2.length; b++)
              this.parent === d2.axisX2[b] && (d2.axisX2[b]._crosshairValue = a2 >= d2.axisX2[b].viewportMinimum && a2 <= d2.axisX2[b].viewportMaximum ? a2 : null);
          else if ("left" === this.parent._position)
            for (b = 0; b < d2.axisY.length; b++)
              this.parent === d2.axisY[b] && (d2.axisY[b]._crosshairValue = a2 >= d2.axisY[b].viewportMinimum && a2 <= d2.axisY[b].viewportMaximum ? a2 : null);
          else if ("right" === this.parent._position)
            for (b = 0; b < d2.axisY2.length; b++)
              this.parent === d2.axisY2[b] && (d2.axisY2[b]._crosshairValue = a2 >= d2.axisY2[b].viewportMinimum && a2 <= d2.axisY2[b].viewportMaximum ? a2 : null);
          for (b = 0; b < d2.axisX.length; b++)
            a2 = d2.axisX[b]._crosshairValue, d2.axisX[b].crosshair && (d2.axisX[b].crosshair.enabled && !r(a2) && a2 >= d2.axisX[b].viewportMinimum && a2 <= d2.axisX[b].viewportMaximum) && (d2.axisX[b].showCrosshair(a2), d2.axisX[b].crosshair._updatedValue = a2, this === d2.axisX[b].crosshair && (c2 = true));
          for (b = 0; b < d2.axisX2.length; b++)
            a2 = d2.axisX2[b]._crosshairValue, d2.axisX2[b].crosshair && (d2.axisX2[b].crosshair.enabled && !r(a2) && a2 >= d2.axisX2[b].viewportMinimum && a2 <= d2.axisX2[b].viewportMaximum) && (d2.axisX2[b].showCrosshair(a2), d2.axisX2[b].crosshair._updatedValue = a2, this === d2.axisX2[b].crosshair && (c2 = true));
          for (b = 0; b < d2.axisY.length; b++)
            a2 = d2.axisY[b]._crosshairValue, d2.axisY[b].crosshair && (d2.axisY[b].crosshair.enabled && !r(a2) && a2 >= d2.axisY[b].viewportMinimum && a2 <= d2.axisY[b].viewportMaximum) && (d2.axisY[b].showCrosshair(a2), d2.axisY[b].crosshair._updatedValue = a2, this === d2.axisY[b].crosshair && (c2 = true));
          for (b = 0; b < d2.axisY2.length; b++)
            a2 = d2.axisY2[b]._crosshairValue, d2.axisY2[b].crosshair && (d2.axisY2[b].crosshair.enabled && !r(a2) && a2 >= d2.axisY2[b].viewportMinimum && a2 <= d2.axisY2[b].viewportMaximum) && (d2.axisY2[b].showCrosshair(a2), d2.axisY2[b].crosshair._updatedValue = a2, this === d2.axisY2[b].crosshair && (c2 = true));
          this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);
          return c2;
        };
        Y2.prototype.hide = function() {
          this.chart.resetOverlayedCanvas();
          this.chart.renderCrosshairs(this.parent);
          this._hidden = true;
        };
        Y2.prototype.render = function(a2, d2, c2) {
          var b, e, f, h2, n2 = null, w2 = null, k = null, m = "";
          if (!this.valueFormatString)
            if ("dateTime" === this.parent.valueType)
              this.valueFormatString = this.parent.valueFormatString;
            else {
              var p2 = 0, p2 = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);
              this.valueFormatString = A.generateValueFormatString(this.parent.range, p2);
            }
          var k = null === this.opacity ? 1 : this.opacity, p2 = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), q = this.chart.overlaidCanvasCtx, g = q.globalAlpha;
          q.globalAlpha = k;
          q.beginPath();
          q.strokeStyle = this.color;
          q.lineWidth = p2;
          q.save();
          this.labelFontSize = Math.abs(r(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize);
          this.labelMaxWidth = r(this.options.labelMaxWidth) ? 0.3 * this.chart.width : this.labelMaxWidth;
          this.labelMaxHeight = r(this.options.labelWrap) || this.labelWrap ? 0.3 * this.chart.height : 2 * this.labelFontSize;
          0 < p2 && q.setLineDash && q.setLineDash(J(this.lineDashType, p2));
          k = new ka(
            q,
            { x: 0, y: 0, padding: { top: 2, right: 3, bottom: 2, left: 4 }, backgroundColor: this.labelBackgroundColor, borderColor: this.labelBorderColor, borderThickness: this.labelBorderThickness, cornerRadius: this.labelCornerRadius, maxWidth: this.labelMaxWidth, maxHeight: this.labelMaxHeight, angle: this.labelAngle, text: m, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }
          );
          if (this.snapToDataPoint) {
            var s = 0, m = [];
            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
              var v3 = null;
              if ("bottom" === this.parent._position || "top" === this.parent._position)
                s = this.parent.dataSeries[0].axisX.convertPixelToValue({ y: d2 });
              else if ("left" === this.parent._position || "right" === this.parent._position)
                s = this.parent.convertPixelToValue({ y: d2 });
              for (var B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (v3.dataSeries = this.parent.dataSeries[B3], null !== v3.dataPoint.y && v3.dataSeries.visible && m.push(v3));
              v3 = null;
              if (0 === m.length)
                return;
              m.sort(function(a3, b2) {
                return a3.distance - b2.distance;
              });
              v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y));
              B3 = 0;
              if ("rangeBar" === m[0].dataSeries.type || "error" === m[0].dataSeries.type)
                for (var v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[B3].dataPoint.y[0])), u2 = 0, s = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (var y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y)), u2 < v3 && (v3 = u2, B3 = s);
              else if ("stackedBar" === m[0].dataSeries.type)
                for (var v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), x = u2 = 0, s = B3 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    x += m[s].dataPoint.y, u2 = Math.abs(a2 - this.parent.convertValueToPixel(x)), u2 < v3 && (v3 = u2, B3 = s);
              else if ("stackedBar100" === m[0].dataSeries.type)
                for (var v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), z = x = u2 = 0, s = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    x += m[s].dataPoint.y, z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, z = 100 * (x / m[s].dataSeries.plotUnit.dataPointYSums[z]), u2 = Math.abs(a2 - this.parent.convertValueToPixel(z)), u2 < v3 && (v3 = u2, B3 = s);
              else
                for (v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), s = B3 = u2 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    u2 = Math.abs(a2 - this.parent.convertValueToPixel(m[s].dataPoint.y)), u2 < v3 && (v3 = u2, B3 = s);
              y = m[B3];
              if ("bottom" === this.parent._position || "top" === this.parent._position) {
                b = 0;
                if ("rangeBar" === this.parent.dataSeries[B3].type || "error" === this.parent.dataSeries[B3].type) {
                  v3 = Math.abs(a2 - this.parent.convertValueToPixel(y.dataPoint.y[0]));
                  for (s = u2 = 0; s < y.dataPoint.y.length; s++)
                    u2 = Math.abs(a2 - this.parent.convertValueToPixel(y.dataPoint.y[s])), u2 < v3 && (v3 = u2, b = s);
                  n2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataPoint.y[b]) << 0;
                  this.value = y.dataPoint.y[b];
                  k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.y[b] }) : r(this.options.label) ? fa(r(c2) ? y.dataPoint.y[b] : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else if ("stackedBar" === this.parent.dataSeries[B3].type) {
                  v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y));
                  x = u2 = 0;
                  for (s = B3; 0 <= s; s--)
                    x += m[s].dataPoint.y, u2 = Math.abs(a2 - this.parent.convertValueToPixel(x)), u2 < v3 && (v3 = u2, b = s);
                  n2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(x) << 0) + 0.5 : this.parent.convertValueToPixel(x) << 0;
                  this.value = x;
                  k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.y }) : r(this.options.label) ? fa(r(c2) ? y.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else if ("stackedBar100" === this.parent.dataSeries[B3].type) {
                  v3 = Math.abs(a2 - this.parent.convertValueToPixel(m[0].dataPoint.y));
                  z = x = u2 = 0;
                  for (s = B3; 0 <= s; s--)
                    x += m[s].dataPoint.y, z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, z = 100 * (x / m[s].dataSeries.plotUnit.dataPointYSums[z]), u2 = Math.abs(a2 - this.parent.convertValueToPixel(z)), u2 < v3 && (v3 = u2, b = s);
                  n2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z) << 0) + 0.5 : this.parent.convertValueToPixel(z) << 0;
                  this.value = z;
                  k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z }) : r(this.options.label) ? fa(r(c2) ? z : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                } else
                  n2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataPoint.y) << 0, this.value = y.dataPoint.y, k.text = this.labelFormatter ? this.labelFormatter({
                    chart: this.chart,
                    axis: this.parent.options,
                    crosshair: this.options,
                    value: y.dataPoint.y
                  }) : r(this.options.label) ? fa(r(c2) ? y.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                b = e = n2;
                f = this.chart.plotArea.y1;
                h2 = this.chart.plotArea.y2;
                this.bounds = { x1: b - p2 / 2, y1: f, x2: e + p2 / 2, y2: h2 };
                k.x = b - k.measureText().width / 2;
                k.x + k.width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.width : k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
                k.y = this.parent.lineCoordinates.y2 + ("top" === this.parent._position ? -k.height + this.parent.tickLength : k.fontSize / 2) + 2;
                k.y + k.height > this.chart.bounds.y2 ? k.y = this.chart.bounds.y2 - k.height : k.y < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1);
              } else if ("left" === this.parent._position || "right" === this.parent._position) {
                f = h2 = w2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataPoint.x) << 0;
                b = this.chart.plotArea.x1;
                e = this.chart.plotArea.x2;
                this.bounds = { x1: b, y1: f - p2 / 2, x2: e, y2: h2 + p2 / 2 };
                z = false;
                if (this.parent.labels)
                  for (m = Math.ceil(this.parent.interval), s = 0; s < this.parent.viewportMaximum; s += m)
                    if (this.parent.labels[s])
                      z = true;
                    else {
                      z = false;
                      break;
                    }
                if (z) {
                  if ("axisX" === this.parent.type)
                    for (s = this.parent.convertPixelToValue({ y: d2 }), v3 = null, B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                      (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? v3.dataPoint.label : this.label);
                } else
                  k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? fa(y.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? Aa(y.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = y.dataPoint.x;
                k.y = h2 + k.fontSize / 2 - k.measureText().height / 2 + 2;
                k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
              }
            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              s = this.parent.convertPixelToValue({ x: a2 });
              for (B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (v3.dataSeries = this.parent.dataSeries[B3], null !== v3.dataPoint.y && v3.dataSeries.visible && m.push(v3));
              if (0 === m.length)
                return;
              m.sort(function(a3, b2) {
                return a3.distance - b2.distance;
              });
              y = m[0];
              b = e = n2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataPoint.x) << 0;
              f = this.chart.plotArea.y1;
              h2 = this.chart.plotArea.y2;
              this.bounds = { x1: b - p2 / 2, y1: f, x2: e + p2 / 2, y2: h2 };
              z = false;
              if (this.parent.labels)
                for (m = Math.ceil(this.parent.interval), s = 0; s < this.parent.viewportMaximum; s += m)
                  if (this.parent.labels[s])
                    z = true;
                  else {
                    z = false;
                    break;
                  }
              if (z) {
                if ("axisX" === this.parent.type)
                  for (s = this.parent.convertPixelToValue({ x: a2 }), v3 = null, B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                    (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? v3.dataPoint.label : this.label);
              } else
                k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? fa(y.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.x }) : r(this.options.label) ? Aa(y.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
              this.value = y.dataPoint.x;
              k.x = b - k.measureText().width / 2;
              k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
              k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position) {
              !r(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (s = this.parent.dataSeries[0].axisX.convertPixelToValue({ x: a2 }));
              for (B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (v3.dataSeries = this.parent.dataSeries[B3], null !== v3.dataPoint.y && v3.dataSeries.visible && m.push(v3));
              if (0 === m.length)
                return;
              m.sort(function(a3, b2) {
                return a3.distance - b2.distance;
              });
              B3 = 0;
              if ("rangeColumn" === m[0].dataSeries.type || "rangeArea" === m[0].dataSeries.type || "error" === m[0].dataSeries.type || "rangeSplineArea" === m[0].dataSeries.type || "candlestick" === m[0].dataSeries.type || "ohlc" === m[0].dataSeries.type || "boxAndWhisker" === m[0].dataSeries.type)
                for (v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y[0])), s = u2 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y)), u2 < v3 && (v3 = u2, B3 = s);
              else if ("stackedColumn" === m[0].dataSeries.type || "stackedArea" === m[0].dataSeries.type)
                for (v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), s = x = u2 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    x += m[s].dataPoint.y, u2 = Math.abs(d2 - this.parent.convertValueToPixel(x)), u2 < v3 && (v3 = u2, B3 = s);
              else if ("stackedColumn100" === m[0].dataSeries.type || "stackedArea100" === m[0].dataSeries.type)
                for (v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), s = z = x = u2 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    x += m[s].dataPoint.y, z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, z = 100 * (x / m[s].dataSeries.plotUnit.dataPointYSums[z]), u2 = Math.abs(d2 - this.parent.convertValueToPixel(z)), u2 < v3 && (v3 = u2, B3 = s);
              else
                for (v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y)), s = u2 = 0; s < m.length; s++)
                  if (m[s].dataPoint.y && m[s].dataPoint.y.length)
                    for (y = 0; y < m[s].dataPoint.y.length; y++)
                      u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y[y])), u2 < v3 && (v3 = u2, B3 = s);
                  else
                    u2 = Math.abs(d2 - this.parent.convertValueToPixel(m[s].dataPoint.y)), u2 < v3 && (v3 = u2, B3 = s);
              y = m[B3];
              b = 0;
              if ("rangeColumn" === this.parent.dataSeries[B3].type || "rangeArea" === this.parent.dataSeries[B3].type || "error" === this.parent.dataSeries[B3].type || "rangeSplineArea" === this.parent.dataSeries[B3].type || "candlestick" === this.parent.dataSeries[B3].type || "ohlc" === this.parent.dataSeries[B3].type || "boxAndWhisker" === this.parent.dataSeries[B3].type) {
                v3 = Math.abs(d2 - this.parent.convertValueToPixel(y.dataPoint.y[0]));
                for (s = u2 = 0; s < y.dataPoint.y.length; s++)
                  u2 = Math.abs(d2 - this.parent.convertValueToPixel(y.dataPoint.y[s])), u2 < v3 && (v3 = u2, b = s);
                w2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataPoint.y[b]) << 0;
                k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataPoint.y[b] }) : r(this.options.label) ? fa(
                  r(c2) ? y.dataPoint.y[b] : c2,
                  this.valueFormatString,
                  this.chart._cultureInfo
                ) : this.label;
                this.value = y.dataPoint.y[b];
              } else if ("stackedColumn" === this.parent.dataSeries[B3].type || "stackedArea" === this.parent.dataSeries[B3].type) {
                v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y));
                x = u2 = 0;
                for (s = B3; 0 <= s; s--)
                  x += m[s].dataPoint.y, u2 = Math.abs(d2 - this.parent.convertValueToPixel(x)), u2 < v3 && (v3 = u2, b = s);
                w2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(x) << 0) + 0.5 : this.parent.convertValueToPixel(x) << 0;
                k.text = this.labelFormatter ? this.labelFormatter({
                  chart: this.chart,
                  axis: this.parent.options,
                  crosshair: this.options,
                  value: y.dataPoint.y
                }) : r(this.options.label) ? fa(r(c2) ? y.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = x;
              } else if ("stackedColumn100" === this.parent.dataSeries[B3].type || "stackedArea100" === this.parent.dataSeries[B3].type) {
                v3 = Math.abs(d2 - this.parent.convertValueToPixel(m[0].dataPoint.y));
                x = u2 = 0;
                for (s = B3; 0 <= s; s--)
                  x += m[s].dataPoint.y, z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, z = 100 * (x / m[s].dataSeries.plotUnit.dataPointYSums[z]), u2 = Math.abs(d2 - this.parent.convertValueToPixel(z)), u2 < v3 && (v3 = u2, b = s);
                w2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(z) << 0) + 0.5 : this.parent.convertValueToPixel(z) << 0;
                k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: z }) : r(this.options.label) ? fa(r(c2) ? z : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                this.value = z;
              } else
                "waterfall" === this.parent.dataSeries[B3].type ? (w2 = 1 === q.lineWidth % 2 ? (this.parent.convertValueToPixel(y.dataSeries.dataPointEOs[y.index].cumulativeSum) << 0) + 0.5 : this.parent.convertValueToPixel(y.dataSeries.dataPointEOs[y.index].cumulativeSum) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: y.dataSeries.dataPointEOs[y.index].cumulativeSum }) : r(this.options.label) ? fa(r(c2) ? y.dataSeries.dataPointEOs[y.index].cumulativeSum : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = y.dataSeries.dataPointEOs[y.index].cumulativeSum) : (w2 = 1 === q.lineWidth % 2 ? (r(a2) ? d2 : this.parent.convertValueToPixel(y.dataPoint.y) << 0) + 0.5 : r(a2) ? d2 : this.parent.convertValueToPixel(y.dataPoint.y) << 0, k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? y.dataPoint.y : c2 }) : r(this.options.label) ? fa(r(c2) ? y.dataPoint.y : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, this.value = y.dataPoint.y);
              f = h2 = w2;
              b = this.chart.plotArea.x1;
              e = this.chart.plotArea.x2;
              this.bounds = { x1: b, y1: f - p2 / 2, x2: e, y2: h2 + p2 / 2 };
              k.y = h2 + k.fontSize / 2 - k.measureText().height / 2 + 2;
              k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
              "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
            }
            m = null;
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1 + k.fontSize / 2), "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2), b >= this.parent.convertValueToPixel(this.parent.reversed ? this.parent.viewportMaximum : this.parent.viewportMinimum) && e <= this.parent.convertValueToPixel(this.parent.reversed ? this.parent.viewportMinimum : this.parent.viewportMaximum) && (0 < p2 && (q.moveTo(b, f), q.lineTo(e, h2), q.stroke(), this._hidden = false), q.restore());
            if ("left" === this.parent._position || "right" === this.parent._position)
              "left" === this.parent._position && k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.measureText().width), h2 >= this.parent.convertValueToPixel(this.parent.reversed ? this.parent.viewportMinimum : this.parent.viewportMaximum) && f <= this.parent.convertValueToPixel(this.parent.reversed ? this.parent.viewportMaximum : this.parent.viewportMinimum) && (0 < p2 && (q.moveTo(b, f), q.lineTo(
                e,
                h2
              ), q.stroke(), this._hidden = false), q.restore());
          } else {
            if ("bottom" === this.parent._position || "top" === this.parent._position)
              b = e = n2 = 1 === q.lineWidth % 2 ? (a2 << 0) + 0.5 : a2 << 0, f = this.chart.plotArea.y1, h2 = this.chart.plotArea.y2, this.bounds = { x1: b - p2 / 2, y1: f, x2: e + p2 / 2, y2: h2 };
            else if ("left" === this.parent._position || "right" === this.parent._position)
              f = h2 = w2 = 1 === q.lineWidth % 2 ? (d2 << 0) + 0.5 : d2 << 0, b = this.chart.plotArea.x1, e = this.chart.plotArea.x2, this.bounds = { x1: b, y1: f - p2 / 2, x2: e, y2: h2 + p2 / 2 };
            if ("xySwapped" === this.chart.plotInfo.axisPlacement)
              if ("left" === this.parent._position || "right" === this.parent._position) {
                z = false;
                if (this.parent.labels)
                  for (m = Math.ceil(this.parent.interval), s = 0; s < this.parent.viewportMaximum; s += m)
                    if (this.parent.labels[s])
                      z = true;
                    else {
                      z = false;
                      break;
                    }
                if (z) {
                  if ("axisX" === this.parent.type)
                    for (s = this.parent.convertPixelToValue({ y: d2 }), v3 = null, B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                      (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (k.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: r(c2) ? this.parent.convertPixelToValue(a2) : c2
                      }) : r(this.options.label) ? v3.dataPoint.label : this.label);
                } else
                  k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? this.parent.convertPixelToValue(d2) : c2 }) : r(this.options.label) ? fa(r(c2) ? this.parent.convertPixelToValue(d2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                    chart: this.chart,
                    axis: this.parent.options,
                    crosshair: this.options,
                    value: r(c2) ? this.parent.convertPixelToValue(d2) : c2
                  }) : r(this.options.label) ? Aa(r(c2) ? this.parent.convertPixelToValue(d2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
                k.y = d2 + k.fontSize / 2 - k.measureText().height / 2 + 2;
                k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x1 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
              } else {
                if ("bottom" === this.parent._position || "top" === this.parent._position)
                  k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? this.parent.convertPixelToValue(a2) : c2 }) : r(this.options.label) ? fa(r(c2) ? this.parent.convertPixelToValue(a2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, k.x = b - k.measureText().width / 2, k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width), k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
              }
            else if ("bottom" === this.parent._position || "top" === this.parent._position) {
              z = false;
              m = "";
              if (this.parent.labels)
                for (m = Math.ceil(this.parent.interval), s = 0; s < this.parent.viewportMaximum; s += m)
                  if (this.parent.labels[s])
                    z = true;
                  else {
                    z = false;
                    break;
                  }
              if (z) {
                if ("axisX" === this.parent.type)
                  for (s = this.parent.convertPixelToValue({ x: a2 }), v3 = null, B3 = 0; B3 < this.parent.dataSeries.length; B3++)
                    (v3 = this.parent.dataSeries[B3].getDataPointAtX(s, true)) && 0 <= v3.index && (k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? this.parent.convertPixelToValue(a2) : c2 }) : r(this.options.label) ? r(c2) ? v3.dataPoint.label : c2 : this.label);
              } else
                k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a2) : "" : c2 }) : r(this.options.label) ? fa(r(c2) ? this.parent.convertPixelToValue(a2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? this.parent.convertPixelToValue(a2) : c2 }) : r(this.options.label) ? Aa(r(c2) ? this.parent.convertPixelToValue(a2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label;
              k.x = b - k.measureText().width / 2;
              k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
              k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
              "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
            } else if ("left" === this.parent._position || "right" === this.parent._position)
              k.text = this.labelFormatter ? this.labelFormatter({ chart: this.chart, axis: this.parent.options, crosshair: this.options, value: r(c2) ? this.parent.convertPixelToValue(d2) : c2 }) : r(this.options.label) ? fa(r(c2) ? this.parent.convertPixelToValue(d2) : c2, this.valueFormatString, this.chart._cultureInfo) : this.label, k.y = d2 + k.fontSize / 2 - k.measureText().height / 2 + 2, k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2), "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
            "left" === this.parent._position && k.x < this.chart.bounds.x1 ? k.x = this.chart.bounds.x1 : "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.measureText().width : "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 : "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2);
            0 < p2 && (q.moveTo(b, f), q.lineTo(e, h2), q.stroke(), this._hidden = false);
            q.restore();
            this.value = "bottom" === this.parent._position || "top" === this.parent._position ? this.parent.convertPixelToValue(a2) : this.parent.convertPixelToValue(d2);
          }
          if ("bottom" === this.parent._position || "top" === this.parent._position)
            this._updatedValue = this.parent.convertPixelToValue(n2);
          if ("left" === this.parent._position || "right" === this.parent._position)
            this._updatedValue = this.parent.convertPixelToValue(w2);
          this._textBlock = k;
          r(c2) || this.renderLabel();
          q.globalAlpha = g;
        };
        Y2.prototype.renderLabel = function() {
          r(this._textBlock) || (r(this._textBlock.text) || !("number" === typeof this._textBlock.text.valueOf() || 0 < this._textBlock.text.length) || this._hidden) || this._textBlock.render(true);
        };
        na(Z2, X);
        Z2.prototype._initialize = function() {
          this.updateOption("updated");
          this.updateOption("hidden");
          if (this.enabled) {
            this.container = document.createElement("div");
            this.container.setAttribute("class", "canvasjs-chart-tooltip");
            this.container.style.position = "absolute";
            this.container.style.height = "auto";
            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
            this.container.style.zIndex = "1000";
            this.container.style.pointerEvents = "none";
            this.container.style.display = "none";
            var a2 = document.createElement("div");
            a2.style.width = "auto";
            a2.style.height = "auto";
            a2.style.minWidth = "50px";
            a2.style.lineHeight = "normal";
            a2.style.margin = "0px 0px 0px 0px";
            a2.style.padding = "5px";
            a2.style.fontFamily = "Calibri, Arial, Georgia, serif";
            a2.style.fontWeight = "normal";
            a2.style.fontStyle = w ? "italic" : "normal";
            a2.style.fontSize = "14px";
            a2.style.color = "#000000";
            a2.style.textShadow = "1px 1px 1px rgba(0, 0, 0, 0.1)";
            a2.style.textAlign = "left";
            a2.style.border = "2px solid gray";
            a2.style.background = w ? "rgba(255,255,255,.9)" : "rgb(255,255,255)";
            a2.style.textIndent = "0px";
            a2.style.whiteSpace = "nowrap";
            a2.style.borderRadius = "5px";
            a2.style.MozUserSelect = "none";
            a2.style.WebkitUserSelect = "none";
            a2.style.msUserSelect = "none";
            a2.style.userSelect = "none";
            w || (a2.style.filter = "alpha(opacity = 90)", a2.style.filter = "progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')");
            a2.innerText = "Sample Tooltip";
            this.container.appendChild(a2);
            this.contentDiv = this.container.firstChild;
            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
            this.chart._canvasJSContainer.appendChild(this.container);
          }
        };
        Z2.prototype.mouseMoveHandler = function(a2, d2) {
          this._lastUpdated && 4 > new Date().getTime() - this._lastUpdated || (this._lastUpdated = new Date().getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a2, d2));
        };
        Z2.prototype._updateToolTip = function(a2, d2, c2) {
          c2 = "undefined" === typeof c2 ? true : c2;
          this.container || this._initialize();
          this.enabled || this.hide();
          if (!this.chart.disableToolTip) {
            if ("undefined" === typeof a2 || "undefined" === typeof d2) {
              if (isNaN(this._prevX) || isNaN(this._prevY))
                return;
              a2 = this._prevX;
              d2 = this._prevY;
            } else
              this._prevX = a2, this._prevY = d2;
            var b = null, e = null, f = [], h2 = 0;
            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
              var n2 = [];
              if (this.chart.axisX)
                for (var v3 = 0; v3 < this.chart.axisX.length; v3++) {
                  for (var h2 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX[v3].convertPixelToValue({ y: d2 }) : this.chart.axisX[v3].convertPixelToValue({ x: a2 }), k = null, b = 0; b < this.chart.axisX[v3].dataSeries.length; b++)
                    (k = this.chart.axisX[v3].dataSeries[b].getDataPointAtX(h2, c2)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[v3].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && n2.push(k));
                  k = null;
                }
              if (this.chart.axisX2)
                for (v3 = 0; v3 < this.chart.axisX2.length; v3++) {
                  h2 = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX2[v3].convertPixelToValue({ y: d2 }) : this.chart.axisX2[v3].convertPixelToValue({ x: a2 });
                  k = null;
                  for (b = 0; b < this.chart.axisX2[v3].dataSeries.length; b++)
                    (k = this.chart.axisX2[v3].dataSeries[b].getDataPointAtX(h2, c2)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[v3].dataSeries[b], null !== k.dataPoint.y && k.dataSeries.visible && n2.push(k));
                  k = null;
                }
              if (0 === n2.length)
                return;
              n2.sort(function(a3, b2) {
                return a3.distance - b2.distance;
              });
              c2 = n2[0];
              for (b = 0; b < n2.length; b++)
                n2[b].dataPoint.x.valueOf() === c2.dataPoint.x.valueOf() && f.push(n2[b]);
              n2 = null;
            } else {
              if (b = this.chart.getDataPointAtXY(a2, d2, c2))
                this.currentDataPointIndex = b.dataPointIndex, this.currentSeriesIndex = b.dataSeries.index;
              else if (w)
                if (b = $a(a2, d2, this.chart._eventManager.ghostCtx), 0 < b && "undefined" !== typeof this.chart._eventManager.objectMap[b]) {
                  b = this.chart._eventManager.objectMap[b];
                  if ("legendItem" === b.objectType)
                    return;
                  this.currentSeriesIndex = b.dataSeriesIndex;
                  this.currentDataPointIndex = 0 <= b.dataPointIndex ? b.dataPointIndex : -1;
                } else
                  this.currentDataPointIndex = -1;
              else
                this.currentDataPointIndex = -1;
              if (0 <= this.currentSeriesIndex) {
                e = this.chart.data[this.currentSeriesIndex];
                k = {};
                if (0 <= this.currentDataPointIndex)
                  b = e.dataPoints[this.currentDataPointIndex], k.dataSeries = e, k.dataPoint = b, k.index = this.currentDataPointIndex, k.distance = Math.abs(b.x - h2), "waterfall" === e.type && (k.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
                else {
                  if (!this.enabled || "line" !== e.type && "stepLine" !== e.type && "spline" !== e.type && "area" !== e.type && "stepArea" !== e.type && "splineArea" !== e.type && "stackedArea" !== e.type && "stackedArea100" !== e.type && "rangeArea" !== e.type && "rangeSplineArea" !== e.type && "candlestick" !== e.type && "ohlc" !== e.type && "boxAndWhisker" !== e.type)
                    return;
                  h2 = e.axisX.convertPixelToValue({ x: a2 });
                  k = e.getDataPointAtX(h2, c2);
                  r(k) || (k.dataSeries = e, this.currentDataPointIndex = k.index, b = k.dataPoint);
                }
                if (!r(k) && !r(k.dataPoint) && !r(k.dataPoint.y))
                  if (k.dataSeries.axisY)
                    if (0 < k.dataPoint.y.length) {
                      for (b = c2 = 0; b < k.dataPoint.y.length; b++)
                        k.dataPoint.y[b] < k.dataSeries.axisY.viewportMinimum ? c2-- : k.dataPoint.y[b] > k.dataSeries.axisY.viewportMaximum && c2++;
                      c2 < k.dataPoint.y.length && c2 > -k.dataPoint.y.length && f.push(k);
                    } else
                      "column" === e.type || "bar" === e.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && f.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && f.push(k) : "bubble" === e.type ? (c2 = this.chart._eventManager.objectMap[e.dataPointIds[k.index]].size / 2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - c2 && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + c2 && f.push(k)) : "waterfall" === e.type ? (c2 = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? c2-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && c2++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? c2-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && c2++, 2 > c2 && -2 < c2 && f.push(k)) : (0 <= k.dataSeries.type.indexOf("100") || "stackedColumn" === e.type || "stackedBar" === e.type || k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && f.push(k);
                  else
                    f.push(k);
              }
            }
            if (0 < f.length) {
              if (this.highlightObjects(f), this.enabled) {
                c2 = "";
                c2 = this.getToolTipInnerHTML({ entries: f });
                if (null !== c2) {
                  this.contentDiv.innerHTML = c2;
                  if (this.isToolTipDefinedInData && r(this.options.content) && r(this.options.contentFormatter))
                    for (h2 = this.contentDiv.getElementsByTagName("span"), b = 0; b < h2.length; b++)
                      h2[b] && (h2[b].style.color = h2[b].getAttribute("data-color"));
                  h2 = false;
                  "none" === this.container.style.display && (h2 = true, this.container.style.display = "block");
                  try {
                    this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : w ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : 0 < f[0].dataPoint.y ? f[0].dataSeries.risingColor : f[0].dataSeries.fallingColor : "error" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[e.index % f[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[f[0].index % f[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : w ? "italic" : "normal";
                  } catch (m) {
                  }
                  "pie" === f[0].dataSeries.type || "doughnut" === f[0].dataSeries.type || "funnel" === f[0].dataSeries.type || "pyramid" === f[0].dataSeries.type || "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? a2 = a2 - 10 - this.container.clientWidth : (a2 = f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) - this.container.clientWidth << 0, a2 -= 10);
                  0 > a2 && (a2 += this.container.clientWidth + 20);
                  a2 + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a2 = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                  d2 = 1 !== f.length || this.shared || "line" !== f[0].dataSeries.type && "stepLine" !== f[0].dataSeries.type && "spline" !== f[0].dataSeries.type && "area" !== f[0].dataSeries.type && "stepArea" !== f[0].dataSeries.type && "splineArea" !== f[0].dataSeries.type ? "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) : d2 : f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);
                  d2 = -d2 + 10;
                  0 < d2 + this.container.clientHeight + 5 && (d2 -= d2 + this.container.clientHeight + 5 - 0);
                  this.fixMozTransitionDelay(a2, d2);
                  !this.animationEnabled || h2 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
                  this.positionLeft = a2;
                  this.positionBottom = d2;
                  this.container.style.left = a2 + "px";
                  this.container.style.bottom = d2 + "px";
                } else
                  this.hide(false), this.enabled && this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this);
                d2 = [];
                for (b = 0; b < f.length; b++)
                  d2.push({
                    xValue: f[b].dataPoint.x,
                    dataPoint: f[b].dataPoint,
                    dataSeries: f[b].dataSeries,
                    dataPointIndex: f[b].index,
                    dataSeriesIndex: f[b].dataSeries._index
                  });
                d2 = { chart: this.chart, toolTip: this.options, content: c2, entries: d2 };
                this._entries = f;
                this.dispatchEvent("updated", d2, this);
              }
            } else
              this.hide(), this.enabled && this.dispatchEvent("hidden", { chart: this.chart, toolTip: this }, this);
          }
        };
        Z2.prototype.highlightObjects = function(a2) {
          var d2 = this.chart.overlaidCanvasCtx;
          if (r(this.chart.clearedOverlayedCanvas) || "toolTip" === this.chart.clearedOverlayedCanvas)
            this.chart.resetOverlayedCanvas(), d2.clearRect(0, 0, this.chart.width, this.chart.height), this.chart.clearedOverlayedCanvas = "toolTip";
          d2.save();
          var c2 = this.chart.plotArea, b = 0;
          d2.beginPath();
          d2.rect(c2.x1, c2.y1, c2.x2 - c2.x1, c2.y2 - c2.y1);
          d2.clip();
          for (c2 = 0; c2 < a2.length; c2++) {
            var e = a2[c2];
            if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
              var b = this.chart.data[e.dataSeriesIndex], f = b.dataPoints[e.dataPointIndex], h2 = e.dataPointIndex;
              false === f.highlightEnabled || true !== b.highlightEnabled && true !== f.highlightEnabled || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "scatter" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type ? (f = b.getMarkerProperties(h2, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(0.1 * f.size), $.drawMarkers([f]), "undefined" !== typeof e.y2 && (f = b.getMarkerProperties(h2, e.x1, e.y2, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(0.1 * f.size), $.drawMarkers([f]))) : "bubble" === b.type ? (f = b.getMarkerProperties(h2, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = e.size, f.color = "white", f.borderColor = "white", d2.globalAlpha = 0.3, $.drawMarkers([f]), d2.globalAlpha = 1) : "column" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "bar" === b.type || "rangeBar" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "rangeColumn" === b.type || "waterfall" === b.type ? ba(d2, e.x1, e.y1, e.x2, e.y2, "white", 0, null, false, false, false, false, 0.3) : "pie" === b.type || "doughnut" === b.type ? W2(d2, e.center, e.radius, "white", b.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : "funnel" === b.type || "pyramid" === b.type ? oa2(d2, e.funnelSection, 0.3, "white") : "candlestick" === b.type ? (d2.globalAlpha = 1, d2.strokeStyle = e.color, d2.lineWidth = 2 * e.borderThickness, b = 0 === d2.lineWidth % 2 ? 0 : 0.5, d2.beginPath(), d2.moveTo(e.x3 - b, Math.min(e.y2, e.y3)), d2.lineTo(e.x3 - b, Math.min(e.y1, e.y4)), d2.stroke(), d2.beginPath(), d2.moveTo(e.x3 - b, Math.max(e.y1, e.y4)), d2.lineTo(e.x3 - b, Math.max(e.y2, e.y3)), d2.stroke(), ba(d2, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, false, false, false, false), d2.globalAlpha = 1) : "ohlc" === b.type ? (d2.globalAlpha = 1, d2.strokeStyle = e.color, d2.lineWidth = 2 * e.borderThickness, b = 0 === d2.lineWidth % 2 ? 0 : 0.5, d2.beginPath(), d2.moveTo(e.x3 - b, e.y2), d2.lineTo(e.x3 - b, e.y3), d2.stroke(), d2.beginPath(), d2.moveTo(e.x3, e.y1), d2.lineTo(e.x1, e.y1), d2.stroke(), d2.beginPath(), d2.moveTo(
                e.x3,
                e.y4
              ), d2.lineTo(e.x2, e.y4), d2.stroke(), d2.globalAlpha = 1) : "boxAndWhisker" === b.type ? (d2.save(), d2.globalAlpha = 1, d2.strokeStyle = e.stemColor, d2.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (d2.beginPath(), d2.moveTo(e.x3, e.y2 + e.borderThickness / 2), d2.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), d2.stroke(), d2.beginPath(), d2.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), d2.lineTo(e.x3, e.y3 - e.borderThickness / 2), d2.stroke()), d2.beginPath(), ba(d2, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), "transparent", e.borderThickness, e.color, false, false, false, false), d2.globalAlpha = 1, d2.strokeStyle = e.whiskerColor, d2.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (d2.beginPath(), d2.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), d2.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), d2.stroke(), d2.beginPath(), d2.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y1), d2.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), d2.stroke()), d2.globalAlpha = 1, d2.strokeStyle = e.lineColor, d2.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (d2.beginPath(), d2.moveTo(e.x1, e.y5), d2.lineTo(e.x2, e.y5), d2.stroke()), d2.restore(), d2.globalAlpha = 1) : "error" === b.type && B2(d2, e.x1, e.y1, e.x2, e.y2, "white", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3));
            }
          }
          d2.restore();
          d2.globalAlpha = 1;
          d2.beginPath();
        };
        Z2.prototype.getToolTipInnerHTML = function(a2) {
          a2 = a2.entries;
          var d2 = null, c2 = null, b = null, e = 0, f = "";
          this.isToolTipDefinedInData = true;
          for (var h2 = 0; h2 < a2.length; h2++)
            if (a2[h2].dataSeries.toolTipContent || a2[h2].dataPoint.toolTipContent) {
              this.isToolTipDefinedInData = false;
              break;
            }
          if (this.isToolTipDefinedInData && (this.content && "function" === typeof this.content || this.contentFormatter))
            a2 = { chart: this.chart, toolTip: this.options, entries: a2 }, d2 = this.contentFormatter ? this.contentFormatter(a2) : this.content(a2);
          else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
            for (var n2 = null, r2 = "", h2 = 0; h2 < a2.length; h2++) {
              c2 = a2[h2].dataSeries;
              b = a2[h2].dataPoint;
              e = a2[h2].index;
              f = "";
              if (0 === h2 && this.isToolTipDefinedInData && !this.content) {
                this.chart.axisX && 0 < this.chart.axisX.length ? r2 += "undefined" !== typeof this.chart.axisX[0].labels[b.x] ? this.chart.axisX[0].labels[b.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (r2 += "undefined" !== typeof this.chart.axisX2[0].labels[b.x] ? this.chart.axisX2[0].labels[b.x] : "{x}");
                r2 += "</br>";
                if (!c2.visible)
                  continue;
                r2 = this.chart.replaceKeywordsWithValue(r2, b, c2, e);
              }
              null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c2.options.toolTipContent || ("line" === c2.type || "stepLine" === c2.type || "spline" === c2.type || "area" === c2.type || "stepArea" === c2.type || "splineArea" === c2.type || "column" === c2.type || "bar" === c2.type || "scatter" === c2.type || "stackedColumn" === c2.type || "stackedColumn100" === c2.type || "stackedBar" === c2.type || "stackedBar100" === c2.type || "stackedArea" === c2.type || "stackedArea100" === c2.type || "waterfall" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += n2 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}`, n2 = c2.axisXIndex) : "bubble" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += n2 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}`) : "rangeColumn" === c2.type || "rangeBar" === c2.type || "rangeArea" === c2.type || "rangeSplineArea" === c2.type || "error" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += n2 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}`) : "candlestick" === c2.type || "ohlc" === c2.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (f += n2 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}`) : "boxAndWhisker" === c2.type && (this.chart.axisX && 1 < this.chart.axisX.length && (f += n2 != c2.axisXIndex ? c2.axisX.title ? c2.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), f += b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}`), null === d2 && (d2 = ""), c2.visible && (true === this.reversed ? (d2 = this.chart.replaceKeywordsWithValue(f, b, c2, e) + d2, h2 < a2.length - 1 && (d2 = "</br>" + d2)) : (d2 += this.chart.replaceKeywordsWithValue(f, b, c2, e), h2 < a2.length - 1 && (d2 += "</br>"))));
            }
            null !== d2 && (d2 = r2 + d2);
          } else {
            c2 = a2[0].dataSeries;
            b = a2[0].dataPoint;
            e = a2[0].index;
            if (null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c2.options.toolTipContent)
              return null;
            "line" === c2.type || "stepLine" === c2.type || "spline" === c2.type || "area" === c2.type || "stepArea" === c2.type || "splineArea" === c2.type || "column" === c2.type || "bar" === c2.type || "scatter" === c2.type || "stackedColumn" === c2.type || "stackedColumn100" === c2.type || "stackedBar" === c2.type || "stackedBar100" === c2.type || "stackedArea" === c2.type || "stackedArea100" === c2.type || "waterfall" === c2.type ? f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c2.type ? f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c2.type || "doughnut" === c2.type || "funnel" === c2.type || "pyramid" === c2.type ? f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.name ? "{name}:</span>&nbsp;&nbsp;" : b.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c2.type || "rangeBar" === c2.type || "rangeArea" === c2.type || "rangeSplineArea" === c2.type || "error" === c2.type ? f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === c2.type || "ohlc" === c2.type ? f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === c2.type && (f = b.toolTipContent ? b.toolTipContent : c2.toolTipContent ? c2.toolTipContent : this.content && "function" !== typeof this.content ? this.content : `<span data-color='"` + (this.options.fontColor ? "" : "'{color}'") + `"'>` + (b.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
            null === d2 && (d2 = "");
            d2 += this.chart.replaceKeywordsWithValue(
              f,
              b,
              c2,
              e
            );
          }
          return d2;
        };
        Z2.prototype.enableAnimation = function() {
          if (!this.container.style.WebkitTransition) {
            var a2 = this.getContainerTransition(this.containerTransitionDuration);
            this.container.style.WebkitTransition = a2;
            this.container.style.MsTransition = a2;
            this.container.style.transition = a2;
            this.container.style.MozTransition = this.mozContainerTransition;
          }
        };
        Z2.prototype.disableAnimation = function() {
          this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "");
        };
        Z2.prototype.hide = function(a2) {
          this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof a2 || a2) && this.chart.resetOverlayedCanvas());
        };
        Z2.prototype.show = function(a2, d2, c2) {
          this._updateToolTip(a2, d2, "undefined" === typeof c2 ? false : c2);
        };
        Z2.prototype.showAtIndex = function(a2, d2) {
        };
        Z2.prototype.showAtX = function(a2, d2) {
          if (!this.enabled)
            return false;
          this.chart.clearedOverlayedCanvas = null;
          var c2, b, e, f = [];
          e = false;
          d2 = !r(d2) && 0 <= d2 && d2 < this.chart.data.length ? d2 : 0;
          if (this.shared)
            for (var h2 = 0; h2 < this.chart.data.length; h2++)
              c2 = this.chart.data[h2], (b = c2.getDataPointAtX(a2, false)) && (b.dataPoint && !r(b.dataPoint.y) && c2.visible) && (b.dataSeries = c2, f.push(b));
          else
            c2 = this.chart.data[d2], (b = c2.getDataPointAtX(a2, false)) && (b.dataPoint && !r(b.dataPoint.y) && c2.visible) && (b.dataSeries = c2, f.push(b));
          if (0 < f.length) {
            for (h2 = 0; h2 < f.length; h2++)
              if (b = f[h2], (this.shared || 0 <= b.dataSeries.type.indexOf("100")) && b.dataPoint.x >= b.dataSeries.axisX.viewportMinimum && b.dataPoint.x <= b.dataSeries.axisX.viewportMaximum) {
                e = false;
                break;
              } else if (b.dataPoint.x < b.dataSeries.axisX.viewportMinimum || b.dataPoint.x > b.dataSeries.axisX.viewportMaximum || b.dataPoint.y < b.dataSeries.axisY.viewportMinimum || b.dataPoint.y > b.dataSeries.axisY.viewportMaximum)
                e = true;
              else {
                e = false;
                break;
              }
            if (e)
              return this.hide(), false;
            this.highlightObjects(f);
            this._entries = f;
            h2 = "";
            h2 = this.getToolTipInnerHTML({ entries: f });
            if (null !== h2) {
              this.contentDiv.innerHTML = h2;
              if (this.isToolTipDefinedInData && r(this.options.content) && r(this.options.contentFormatter))
                for (b = this.contentDiv.getElementsByTagName("span"), h2 = 0; h2 < b.length; h2++)
                  b[h2] && (b[h2].style.color = b[h2].getAttribute("data-color"));
              h2 = false;
              "none" === this.container.style.display && (h2 = true, this.container.style.display = "block");
              try {
                this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : w ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : 0 < f[0].dataPoint.y ? f[0].dataSeries.risingColor : f[0].dataSeries.fallingColor : "error" === f[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[c2.index % f[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : f[0].dataPoint.color ? f[0].dataPoint.color : f[0].dataSeries.color ? f[0].dataSeries.color : f[0].dataSeries._colorSet[f[0].index % f[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : w ? "italic" : "normal";
              } catch (n2) {
              }
              "pie" === f[0].dataSeries.type || "doughnut" === f[0].dataSeries.type || "funnel" === f[0].dataSeries.type || "pyramid" === f[0].dataSeries.type ? c2 = mouseX - 10 - this.container.clientWidth : (c2 = "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y) - this.container.clientWidth << 0 : f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) - this.container.clientWidth << 0, c2 -= 10);
              0 > c2 && (c2 += this.container.clientWidth + 20);
              c2 + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (c2 = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
              f = 1 !== f.length || this.shared || "line" !== f[0].dataSeries.type && "stepLine" !== f[0].dataSeries.type && "spline" !== f[0].dataSeries.type && "area" !== f[0].dataSeries.type && "stepArea" !== f[0].dataSeries.type && "splineArea" !== f[0].dataSeries.type ? "bar" === f[0].dataSeries.type || "rangeBar" === f[0].dataSeries.type || "stackedBar" === f[0].dataSeries.type || "stackedBar100" === f[0].dataSeries.type ? f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x) : f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y) : f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);
              f = -f + 10;
              0 < f + this.container.clientHeight + 5 && (f -= f + this.container.clientHeight + 5 - 0);
              this.fixMozTransitionDelay(c2, f);
              !this.animationEnabled || h2 ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
              this.container.style.left = c2 + "px";
              this.container.style.bottom = f + "px";
            } else
              return this.hide(false), false;
          } else
            return this.hide(), false;
          return true;
        };
        Z2.prototype.fixMozTransitionDelay = function(a2, d2) {
          if (20 < this.chart._eventManager.lastObjectId)
            this.mozContainerTransition = this.getContainerTransition(0);
          else {
            var c2 = parseFloat(this.container.style.left), c2 = isNaN(c2) ? 0 : c2, b = parseFloat(this.container.style.bottom), b = isNaN(b) ? 0 : b;
            10 < Math.sqrt(Math.pow(c2 - a2, 2) + Math.pow(b - d2, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0);
          }
        };
        Z2.prototype.getContainerTransition = function(a2) {
          return "left " + a2 + "s ease-out 0s, bottom " + a2 + "s ease-out 0s";
        };
        ea2.prototype.reset = function() {
          this.lastObjectId = 0;
          this.objectMap = [];
          this.rectangularRegionEventSubscriptions = [];
          this.previousDataPointEventObject = null;
          this.eventObjects = [];
          w && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());
        };
        ea2.prototype.getNewObjectTrackingId = function() {
          return ++this.lastObjectId;
        };
        ea2.prototype.mouseEventHandler = function(a2) {
          if ("mousemove" === a2.type || "click" === a2.type) {
            var d2 = [], c2 = Pa(a2), b = null;
            if ((b = this.chart.getObjectAtXY(c2.x, c2.y, false)) && "undefined" !== typeof this.objectMap[b])
              if (b = this.objectMap[b], "dataPoint" === b.objectType) {
                var e = this.chart.data[b.dataSeriesIndex], f = e.dataPoints[b.dataPointIndex], h2 = b.dataPointIndex;
                b.eventParameter = { x: c2.x, y: c2.y, dataPoint: f, dataSeries: e.options, dataPointIndex: h2, dataSeriesIndex: e.index, chart: this.chart };
                b.eventContext = {
                  context: f,
                  userContext: f,
                  mouseover: "mouseover",
                  mousemove: "mousemove",
                  mouseout: "mouseout",
                  click: "click"
                };
                d2.push(b);
                b = this.objectMap[e.id];
                b.eventParameter = { x: c2.x, y: c2.y, dataPoint: f, dataSeries: e.options, dataPointIndex: h2, dataSeriesIndex: e.index, chart: this.chart };
                b.eventContext = { context: e, userContext: e.options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" };
                d2.push(this.objectMap[e.id]);
              } else
                "legendItem" === b.objectType && (e = this.chart.data[b.dataSeriesIndex], f = null !== b.dataPointIndex ? e.dataPoints[b.dataPointIndex] : null, b.eventParameter = {
                  x: c2.x,
                  y: c2.y,
                  dataSeries: e.options,
                  dataPoint: f,
                  dataPointIndex: b.dataPointIndex,
                  dataSeriesIndex: b.dataSeriesIndex,
                  chart: this.chart
                }, b.eventContext = { context: this.chart.legend, userContext: this.chart.legend.options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick" }, d2.push(b));
            e = [];
            for (c2 = 0; c2 < this.mouseoveredObjectMaps.length; c2++) {
              f = true;
              for (b = 0; b < d2.length; b++)
                if (d2[b].id === this.mouseoveredObjectMaps[c2].id) {
                  f = false;
                  break;
                }
              f ? this.fireEvent(this.mouseoveredObjectMaps[c2], "mouseout", a2) : e.push(this.mouseoveredObjectMaps[c2]);
            }
            this.mouseoveredObjectMaps = e;
            for (c2 = 0; c2 < d2.length; c2++) {
              e = false;
              for (b = 0; b < this.mouseoveredObjectMaps.length; b++)
                if (d2[c2].id === this.mouseoveredObjectMaps[b].id) {
                  e = true;
                  break;
                }
              e || (this.fireEvent(d2[c2], "mouseover", a2), this.mouseoveredObjectMaps.push(d2[c2]));
              "click" === a2.type ? this.fireEvent(d2[c2], "click", a2) : "mousemove" === a2.type && this.fireEvent(d2[c2], "mousemove", a2);
            }
          }
        };
        ea2.prototype.fireEvent = function(a2, d2, c2) {
          if (a2 && d2) {
            var b = a2.eventParameter, e = a2.eventContext, f = a2.eventContext.userContext;
            f && (e && f[e[d2]]) && f[e[d2]].call(f, b);
            "mouseout" !== d2 ? f.cursor && f.cursor !== c2.target.style.cursor && (c2.target.style.cursor = f.cursor) : (c2.target.style.cursor = this.chart._defaultCursor, delete a2.eventParameter, delete a2.eventContext);
            "click" === d2 && ("dataPoint" === a2.objectType && this.chart.pieDoughnutClickHandler) && this.chart.pieDoughnutClickHandler.call(this.chart.data[a2.dataSeriesIndex], b);
            "click" === d2 && ("dataPoint" === a2.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a2.dataSeriesIndex], b);
          }
        };
        ja2.prototype.animate = function(a2, d2, c2, b, e) {
          var f = this;
          this.chart.isAnimating = true;
          e = e || N.easing.linear;
          c2 && this.animations.push({ startTime: new Date().getTime() + (a2 ? a2 : 0), duration: d2, animationCallback: c2, onComplete: b });
          for (a2 = []; 0 < this.animations.length; )
            if (d2 = this.animations.shift(), c2 = new Date().getTime(), b = 0, d2.startTime <= c2 && (b = e(Math.min(c2 - d2.startTime, d2.duration), 0, 1, d2.duration), b = Math.min(b, 1), isNaN(b) || !isFinite(b)) && (b = 1), 1 > b && a2.push(d2), d2.animationCallback(b), 1 <= b && d2.onComplete)
              d2.onComplete();
          this.animations = a2;
          0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function() {
            f.animate.call(f);
          }) : this.chart.isAnimating = false;
        };
        ja2.prototype.cancelAllAnimations = function() {
          this.animations = [];
          this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
          this.animationRequestId = null;
          this.chart.isAnimating = false;
        };
        var N = { yScaleAnimation: function(a2, d2) {
          if (0 !== a2) {
            var c2 = d2.dest, b = d2.source.canvas, e = d2.animationBase;
            c2.drawImage(b, 0, 0, b.width, b.height, 0, e - e * a2, c2.canvas.width / ia, a2 * c2.canvas.height / ia);
          }
        }, xScaleAnimation: function(a2, d2) {
          if (0 !== a2) {
            var c2 = d2.dest, b = d2.source.canvas, e = d2.animationBase;
            c2.drawImage(b, 0, 0, b.width, b.height, e - e * a2, 0, a2 * c2.canvas.width / ia, c2.canvas.height / ia);
          }
        }, xClipAnimation: function(a2, d2) {
          if (0 !== a2) {
            var c2 = d2.dest, b = d2.source.canvas;
            c2.save();
            0 < a2 && c2.drawImage(b, 0, 0, b.width * a2, b.height, 0, 0, b.width * a2 / ia, b.height / ia);
            c2.restore();
          }
        }, fadeInAnimation: function(a2, d2) {
          if (0 !== a2) {
            var c2 = d2.dest, b = d2.source.canvas;
            c2.save();
            c2.globalAlpha = a2;
            c2.drawImage(b, 0, 0, b.width, b.height, 0, 0, c2.canvas.width / ia, c2.canvas.height / ia);
            c2.restore();
          }
        }, easing: { linear: function(a2, d2, c2, b) {
          return c2 * a2 / b + d2;
        }, easeOutQuad: function(a2, d2, c2, b) {
          return -c2 * (a2 /= b) * (a2 - 2) + d2;
        }, easeOutQuart: function(a2, d2, c2, b) {
          return -c2 * ((a2 = a2 / b - 1) * a2 * a2 * a2 - 1) + d2;
        }, easeInQuad: function(a2, d2, c2, b) {
          return c2 * (a2 /= b) * a2 + d2;
        }, easeInQuart: function(a2, d2, c2, b) {
          return c2 * (a2 /= b) * a2 * a2 * a2 + d2;
        } } }, $ = { drawMarker: function(a2, d2, c2, b, e, f, h2, n2) {
          if (c2) {
            var r2 = 1;
            c2.fillStyle = f ? f : "#000000";
            c2.strokeStyle = h2 ? h2 : "#000000";
            c2.lineWidth = n2 ? n2 : 0;
            c2.setLineDash && c2.setLineDash(J("solid", n2));
            "circle" === b ? (c2.moveTo(a2, d2), c2.beginPath(), c2.arc(a2, d2, e / 2, 0, 2 * Math.PI, false), f && c2.fill(), n2 && (h2 ? c2.stroke() : (r2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = r2))) : "square" === b ? (c2.beginPath(), c2.rect(a2 - e / 2, d2 - e / 2, e, e), f && c2.fill(), n2 && (h2 ? c2.stroke() : (r2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = r2))) : "triangle" === b ? (c2.beginPath(), c2.moveTo(a2 - e / 2, d2 + e / 2), c2.lineTo(a2 + e / 2, d2 + e / 2), c2.lineTo(a2, d2 - e / 2), c2.closePath(), f && c2.fill(), n2 && (h2 ? c2.stroke() : (r2 = c2.globalAlpha, c2.globalAlpha = 0.15, c2.strokeStyle = "black", c2.stroke(), c2.globalAlpha = r2)), c2.beginPath()) : "cross" === b && (c2.strokeStyle = f, c2.lineWidth = e / 4, c2.beginPath(), c2.moveTo(a2 - e / 2, d2 - e / 2), c2.lineTo(a2 + e / 2, d2 + e / 2), c2.stroke(), c2.moveTo(a2 + e / 2, d2 - e / 2), c2.lineTo(a2 - e / 2, d2 + e / 2), c2.stroke());
          }
        }, drawMarkers: function(a2) {
          for (var d2 = 0; d2 < a2.length; d2++) {
            var c2 = a2[d2];
            $.drawMarker(c2.x, c2.y, c2.ctx, c2.type, c2.size, c2.color, c2.borderColor, c2.borderThickness);
          }
        } };
        return n;
      }();
      v.version = "v3.7.17 GA";
      window.CanvasJS && (v && !window.CanvasJS.Chart) && (window.CanvasJS.Chart = v);
    })();
    document.createElement("canvas").getContext || function() {
      function V() {
        return this.context_ || (this.context_ = new C2(this));
      }
      function W(a2, b, c2) {
        var g = M.call(arguments, 2);
        return function() {
          return a2.apply(b, g.concat(M.call(arguments)));
        };
      }
      function N(a2) {
        return String(a2).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      }
      function O(a2) {
        a2.namespaces.g_vml_ || a2.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
        a2.namespaces.g_o_ || a2.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
        a2.styleSheets.ex_canvas_ || (a2 = a2.createStyleSheet(), a2.owningElement.id = "ex_canvas_", a2.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}");
      }
      function X(a2) {
        var b = a2.srcElement;
        switch (a2.propertyName) {
          case "width":
            b.getContext().clearRect();
            b.style.width = b.attributes.width.nodeValue + "px";
            b.firstChild.style.width = b.clientWidth + "px";
            break;
          case "height":
            b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px";
        }
      }
      function Y(a2) {
        a2 = a2.srcElement;
        a2.firstChild && (a2.firstChild.style.width = a2.clientWidth + "px", a2.firstChild.style.height = a2.clientHeight + "px");
      }
      function D() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      }
      function t(a2, b) {
        for (var c2 = D(), g = 0; 3 > g; g++)
          for (var e = 0; 3 > e; e++) {
            for (var f = 0, d3 = 0; 3 > d3; d3++)
              f += a2[g][d3] * b[d3][e];
            c2[g][e] = f;
          }
        return c2;
      }
      function P(a2, b) {
        b.fillStyle = a2.fillStyle;
        b.lineCap = a2.lineCap;
        b.lineJoin = a2.lineJoin;
        b.lineWidth = a2.lineWidth;
        b.miterLimit = a2.miterLimit;
        b.shadowBlur = a2.shadowBlur;
        b.shadowColor = a2.shadowColor;
        b.shadowOffsetX = a2.shadowOffsetX;
        b.shadowOffsetY = a2.shadowOffsetY;
        b.strokeStyle = a2.strokeStyle;
        b.globalAlpha = a2.globalAlpha;
        b.font = a2.font;
        b.textAlign = a2.textAlign;
        b.textBaseline = a2.textBaseline;
        b.arcScaleX_ = a2.arcScaleX_;
        b.arcScaleY_ = a2.arcScaleY_;
        b.lineScale_ = a2.lineScale_;
      }
      function Q(a2) {
        var b = a2.indexOf("(", 3), c2 = a2.indexOf(")", b + 1), b = a2.substring(b + 1, c2).split(",");
        if (4 != b.length || "a" != a2.charAt(3))
          b[3] = 1;
        return b;
      }
      function E(a2, b, c2) {
        return Math.min(c2, Math.max(b, a2));
      }
      function F(a2, b, c2) {
        0 > c2 && c2++;
        1 < c2 && c2--;
        return 1 > 6 * c2 ? a2 + 6 * (b - a2) * c2 : 1 > 2 * c2 ? b : 2 > 3 * c2 ? a2 + 6 * (b - a2) * (2 / 3 - c2) : a2;
      }
      function G(a2) {
        if (a2 in H)
          return H[a2];
        var b, c2 = 1;
        a2 = String(a2);
        if ("#" == a2.charAt(0))
          b = a2;
        else if (/^rgb/.test(a2)) {
          c2 = Q(a2);
          b = "#";
          for (var g, e = 0; 3 > e; e++)
            g = -1 != c2[e].indexOf("%") ? Math.floor(255 * (parseFloat(c2[e]) / 100)) : +c2[e], b += v[E(g, 0, 255)];
          c2 = +c2[3];
        } else if (/^hsl/.test(a2)) {
          e = c2 = Q(a2);
          b = parseFloat(e[0]) / 360 % 360;
          0 > b && b++;
          g = E(parseFloat(e[1]) / 100, 0, 1);
          e = E(parseFloat(e[2]) / 100, 0, 1);
          if (0 == g)
            g = e = b = e;
          else {
            var f = 0.5 > e ? e * (1 + g) : e + g - e * g, d3 = 2 * e - f;
            g = F(d3, f, b + 1 / 3);
            e = F(d3, f, b);
            b = F(d3, f, b - 1 / 3);
          }
          b = "#" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
          c2 = c2[3];
        } else
          b = Z[a2] || a2;
        return H[a2] = { color: b, alpha: c2 };
      }
      function C2(a2) {
        this.m_ = D();
        this.mStack_ = [];
        this.aStack_ = [];
        this.currentPath_ = [];
        this.fillStyle = this.strokeStyle = "#000";
        this.lineWidth = 1;
        this.lineJoin = "miter";
        this.lineCap = "butt";
        this.miterLimit = 1 * q;
        this.globalAlpha = 1;
        this.font = "10px sans-serif";
        this.textAlign = "left";
        this.textBaseline = "alphabetic";
        this.canvas = a2;
        var b = "width:" + a2.clientWidth + "px;height:" + a2.clientHeight + "px;overflow:hidden;position:absolute", c2 = a2.ownerDocument.createElement("div");
        c2.style.cssText = b;
        a2.appendChild(c2);
        b = c2.cloneNode(false);
        b.style.backgroundColor = "red";
        b.style.filter = "alpha(opacity=0)";
        a2.appendChild(b);
        this.element_ = c2;
        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
      }
      function R(a2, b, c2, g) {
        a2.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c2.x, cp2y: c2.y, x: g.x, y: g.y });
        a2.currentX_ = g.x;
        a2.currentY_ = g.y;
      }
      function S(a2, b) {
        var c2 = G(a2.strokeStyle), g = c2.color, c2 = c2.alpha * a2.globalAlpha, e = a2.lineScale_ * a2.lineWidth;
        1 > e && (c2 *= e);
        b.push(
          "<g_vml_:stroke",
          ' opacity="',
          c2,
          '"',
          ' joinstyle="',
          a2.lineJoin,
          '"',
          ' miterlimit="',
          a2.miterLimit,
          '"',
          ' endcap="',
          $[a2.lineCap] || "square",
          '"',
          ' weight="',
          e,
          'px"',
          ' color="',
          g,
          '" />'
        );
      }
      function T(a2, b, c2, g) {
        var e = a2.fillStyle, f = a2.arcScaleX_, d3 = a2.arcScaleY_, k2 = g.x - c2.x, n = g.y - c2.y;
        if (e instanceof w) {
          var h = 0, l2 = g = 0, u2 = 0, m = 1;
          if ("gradient" == e.type_) {
            h = e.x1_ / f;
            c2 = e.y1_ / d3;
            var p2 = s(a2, e.x0_ / f, e.y0_ / d3), h = s(a2, h, c2), h = 180 * Math.atan2(h.x - p2.x, h.y - p2.y) / Math.PI;
            0 > h && (h += 360);
            1e-6 > h && (h = 0);
          } else
            p2 = s(a2, e.x0_, e.y0_), g = (p2.x - c2.x) / k2, l2 = (p2.y - c2.y) / n, k2 /= f * q, n /= d3 * q, m = x.max(k2, n), u2 = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u2;
          f = e.colors_;
          f.sort(function(a3, b2) {
            return a3.offset - b2.offset;
          });
          d3 = f.length;
          p2 = f[0].color;
          c2 = f[d3 - 1].color;
          k2 = f[0].alpha * a2.globalAlpha;
          a2 = f[d3 - 1].alpha * a2.globalAlpha;
          for (var n = [], r2 = 0; r2 < d3; r2++) {
            var t2 = f[r2];
            n.push(t2.offset * m + u2 + " " + t2.color);
          }
          b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p2, '"', ' color2="', c2, '"', ' colors="', n.join(","), '"', ' opacity="', a2, '"', ' g_o_:opacity2="', k2, '"', ' angle="', h, '"', ' focusposition="', g, ",", l2, '" />');
        } else
          e instanceof I ? k2 && n && b.push("<g_vml_:fill", ' position="', -c2.x / k2 * f * f, ",", -c2.y / n * d3 * d3, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a2.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a2.globalAlpha, '" />'));
      }
      function s(a2, b, c2) {
        a2 = a2.m_;
        return { x: q * (b * a2[0][0] + c2 * a2[1][0] + a2[2][0]) - r, y: q * (b * a2[0][1] + c2 * a2[1][1] + a2[2][1]) - r };
      }
      function z(a2, b, c2) {
        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a2.m_ = b, c2 && (a2.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
      }
      function w(a2) {
        this.type_ = a2;
        this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
        this.colors_ = [];
      }
      function I(a2, b) {
        if (!a2 || 1 != a2.nodeType || "IMG" != a2.tagName)
          throw new A("TYPE_MISMATCH_ERR");
        if ("complete" != a2.readyState)
          throw new A("INVALID_STATE_ERR");
        switch (b) {
          case "repeat":
          case null:
          case "":
            this.repetition_ = "repeat";
            break;
          case "repeat-x":
          case "repeat-y":
          case "no-repeat":
            this.repetition_ = b;
            break;
          default:
            throw new A("SYNTAX_ERR");
        }
        this.src_ = a2.src;
        this.width_ = a2.width;
        this.height_ = a2.height;
      }
      function A(a2) {
        this.code = this[a2];
        this.message = a2 + ": DOM Exception " + this.code;
      }
      var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;
      navigator.userAgent.match(/MSIE ([\d.]+)?/);
      var M = Array.prototype.slice;
      O(document);
      var U = { init: function(a2) {
        a2 = a2 || document;
        a2.createElement("canvas");
        a2.attachEvent("onreadystatechange", W(this.init_, this, a2));
      }, init_: function(a2) {
        a2 = a2.getElementsByTagName("canvas");
        for (var b = 0; b < a2.length; b++)
          this.initElement(a2[b]);
      }, initElement: function(a2) {
        if (!a2.getContext) {
          a2.getContext = V;
          O(a2.ownerDocument);
          a2.innerHTML = "";
          a2.attachEvent("onpropertychange", X);
          a2.attachEvent("onresize", Y);
          var b = a2.attributes;
          b.width && b.width.specified ? a2.style.width = b.width.nodeValue + "px" : a2.width = a2.clientWidth;
          b.height && b.height.specified ? a2.style.height = b.height.nodeValue + "px" : a2.height = a2.clientHeight;
        }
        return a2;
      } };
      U.init();
      for (var v = [], d2 = 0; 16 > d2; d2++)
        for (var B = 0; 16 > B; B++)
          v[16 * d2 + B] = d2.toString(16) + B.toString(16);
      var Z = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgreen: "#006400",
        darkgrey: "#A9A9A9",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        grey: "#808080",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgreen: "#90EE90",
        lightgrey: "#D3D3D3",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        oldlace: "#FDF5E6",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        whitesmoke: "#F5F5F5",
        yellowgreen: "#9ACD32"
      }, H = {}, L = {}, $ = { butt: "flat", round: "round" }, d2 = C2.prototype;
      d2.clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(true), this.textMeasureEl_ = null);
        this.element_.innerHTML = "";
      };
      d2.beginPath = function() {
        this.currentPath_ = [];
      };
      d2.moveTo = function(a2, b) {
        var c2 = s(this, a2, b);
        this.currentPath_.push({ type: "moveTo", x: c2.x, y: c2.y });
        this.currentX_ = c2.x;
        this.currentY_ = c2.y;
      };
      d2.lineTo = function(a2, b) {
        var c2 = s(this, a2, b);
        this.currentPath_.push({ type: "lineTo", x: c2.x, y: c2.y });
        this.currentX_ = c2.x;
        this.currentY_ = c2.y;
      };
      d2.bezierCurveTo = function(a2, b, c2, g, e, f) {
        e = s(this, e, f);
        a2 = s(this, a2, b);
        c2 = s(this, c2, g);
        R(this, a2, c2, e);
      };
      d2.quadraticCurveTo = function(a2, b, c2, g) {
        a2 = s(this, a2, b);
        c2 = s(this, c2, g);
        g = { x: this.currentX_ + 2 / 3 * (a2.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a2.y - this.currentY_) };
        R(this, g, { x: g.x + (c2.x - this.currentX_) / 3, y: g.y + (c2.y - this.currentY_) / 3 }, c2);
      };
      d2.arc = function(a2, b, c2, g, e, f) {
        c2 *= q;
        var d3 = f ? "at" : "wa", k2 = a2 + K(g) * c2 - r, n = b + J(g) * c2 - r;
        g = a2 + K(e) * c2 - r;
        e = b + J(e) * c2 - r;
        k2 != g || f || (k2 += 0.125);
        a2 = s(this, a2, b);
        k2 = s(this, k2, n);
        g = s(this, g, e);
        this.currentPath_.push({
          type: d3,
          x: a2.x,
          y: a2.y,
          radius: c2,
          xStart: k2.x,
          yStart: k2.y,
          xEnd: g.x,
          yEnd: g.y
        });
      };
      d2.rect = function(a2, b, c2, g) {
        this.moveTo(a2, b);
        this.lineTo(a2 + c2, b);
        this.lineTo(a2 + c2, b + g);
        this.lineTo(a2, b + g);
        this.closePath();
      };
      d2.strokeRect = function(a2, b, c2, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a2, b);
        this.lineTo(a2 + c2, b);
        this.lineTo(a2 + c2, b + g);
        this.lineTo(a2, b + g);
        this.closePath();
        this.stroke();
        this.currentPath_ = e;
      };
      d2.fillRect = function(a2, b, c2, g) {
        var e = this.currentPath_;
        this.beginPath();
        this.moveTo(a2, b);
        this.lineTo(a2 + c2, b);
        this.lineTo(a2 + c2, b + g);
        this.lineTo(a2, b + g);
        this.closePath();
        this.fill();
        this.currentPath_ = e;
      };
      d2.createLinearGradient = function(a2, b, c2, g) {
        var e = new w("gradient");
        e.x0_ = a2;
        e.y0_ = b;
        e.x1_ = c2;
        e.y1_ = g;
        return e;
      };
      d2.createRadialGradient = function(a2, b, c2, g, e, f) {
        var d3 = new w("gradientradial");
        d3.x0_ = a2;
        d3.y0_ = b;
        d3.r0_ = c2;
        d3.x1_ = g;
        d3.y1_ = e;
        d3.r1_ = f;
        return d3;
      };
      d2.drawImage = function(a2, b) {
        var c2, g, e, d3, r2, y, n, h;
        e = a2.runtimeStyle.width;
        d3 = a2.runtimeStyle.height;
        a2.runtimeStyle.width = "auto";
        a2.runtimeStyle.height = "auto";
        var l2 = a2.width, u2 = a2.height;
        a2.runtimeStyle.width = e;
        a2.runtimeStyle.height = d3;
        if (3 == arguments.length)
          c2 = arguments[1], g = arguments[2], r2 = y = 0, n = e = l2, h = d3 = u2;
        else if (5 == arguments.length)
          c2 = arguments[1], g = arguments[2], e = arguments[3], d3 = arguments[4], r2 = y = 0, n = l2, h = u2;
        else if (9 == arguments.length)
          r2 = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c2 = arguments[5], g = arguments[6], e = arguments[7], d3 = arguments[8];
        else
          throw Error("Invalid number of arguments");
        var m = s(this, c2, g), p2 = [];
        p2.push(
          " <g_vml_:group",
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' coordorigin="0,0"',
          ' style="width:',
          10,
          "px;height:",
          10,
          "px;position:absolute;"
        );
        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
          var t2 = [];
          t2.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), "");
          var v2 = s(this, c2 + e, g), w2 = s(this, c2, g + d3);
          c2 = s(this, c2 + e, g + d3);
          m.x = x.max(m.x, v2.x, w2.x, c2.x);
          m.y = x.max(m.y, v2.y, w2.y, c2.y);
          p2.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t2.join(""), ", sizingmethod='clip');");
        } else
          p2.push(
            "top:",
            k(m.y / q),
            "px;left:",
            k(m.x / q),
            "px;"
          );
        p2.push(' ">', '<g_vml_:image src="', a2.src, '"', ' style="width:', q * e, "px;", " height:", q * d3, 'px"', ' cropleft="', r2 / l2, '"', ' croptop="', y / u2, '"', ' cropright="', (l2 - r2 - n) / l2, '"', ' cropbottom="', (u2 - y - h) / u2, '"', " />", "</g_vml_:group>");
        this.element_.insertAdjacentHTML("BeforeEnd", p2.join(""));
      };
      d2.stroke = function(a2) {
        var b = [];
        b.push(
          "<g_vml_:shape",
          ' filled="',
          !!a2,
          '"',
          ' style="position:absolute;width:',
          10,
          "px;height:",
          10,
          'px;"',
          ' coordorigin="0,0"',
          ' coordsize="',
          10 * q,
          ",",
          10 * q,
          '"',
          ' stroked="',
          !a2,
          '"',
          ' path="'
        );
        for (var c2 = { x: null, y: null }, d3 = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) {
          var f = this.currentPath_[e];
          switch (f.type) {
            case "moveTo":
              b.push(" m ", k(f.x), ",", k(f.y));
              break;
            case "lineTo":
              b.push(" l ", k(f.x), ",", k(f.y));
              break;
            case "close":
              b.push(" x ");
              f = null;
              break;
            case "bezierCurveTo":
              b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y));
              break;
            case "at":
            case "wa":
              b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ * f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd));
          }
          if (f) {
            if (null == c2.x || f.x < c2.x)
              c2.x = f.x;
            if (null == d3.x || f.x > d3.x)
              d3.x = f.x;
            if (null == c2.y || f.y < c2.y)
              c2.y = f.y;
            if (null == d3.y || f.y > d3.y)
              d3.y = f.y;
          }
        }
        b.push(' ">');
        a2 ? T(this, b, c2, d3) : S(this, b);
        b.push("</g_vml_:shape>");
        this.element_.insertAdjacentHTML("beforeEnd", b.join(""));
      };
      d2.fill = function() {
        this.stroke(true);
      };
      d2.closePath = function() {
        this.currentPath_.push({ type: "close" });
      };
      d2.save = function() {
        var a2 = {};
        P(this, a2);
        this.aStack_.push(a2);
        this.mStack_.push(this.m_);
        this.m_ = t(D(), this.m_);
      };
      d2.restore = function() {
        this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
      };
      d2.translate = function(a2, b) {
        z(this, t([[1, 0, 0], [0, 1, 0], [a2, b, 1]], this.m_), false);
      };
      d2.rotate = function(a2) {
        var b = K(a2);
        a2 = J(a2);
        z(this, t([[b, a2, 0], [-a2, b, 0], [0, 0, 1]], this.m_), false);
      };
      d2.scale = function(a2, b) {
        this.arcScaleX_ *= a2;
        this.arcScaleY_ *= b;
        z(this, t([[a2, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), true);
      };
      d2.transform = function(a2, b, c2, d3, e, f) {
        z(this, t([[
          a2,
          b,
          0
        ], [c2, d3, 0], [e, f, 1]], this.m_), true);
      };
      d2.setTransform = function(a2, b, c2, d3, e, f) {
        z(this, [[a2, b, 0], [c2, d3, 0], [e, f, 1]], true);
      };
      d2.drawText_ = function(a2, b, c2, d3, e) {
        var f = this.m_;
        d3 = 0;
        var r2 = 1e3, t2 = 0, n = [], h;
        h = this.font;
        if (L[h])
          h = L[h];
        else {
          var l2 = document.createElement("div").style;
          try {
            l2.font = h;
          } catch (u2) {
          }
          h = L[h] = { style: l2.fontStyle || "normal", variant: l2.fontVariant || "normal", weight: l2.fontWeight || "normal", size: l2.fontSize || 10, family: l2.fontFamily || "sans-serif" };
        }
        var l2 = h, m = this.element_;
        h = {};
        for (var p2 in l2)
          h[p2] = l2[p2];
        p2 = parseFloat(m.currentStyle.fontSize);
        m = parseFloat(l2.size);
        "number" == typeof l2.size ? h.size = l2.size : -1 != l2.size.indexOf("px") ? h.size = m : -1 != l2.size.indexOf("em") ? h.size = p2 * m : -1 != l2.size.indexOf("%") ? h.size = p2 / 100 * m : -1 != l2.size.indexOf("pt") ? h.size = m / 0.75 : h.size = p2;
        h.size *= 0.981;
        p2 = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family;
        m = this.element_.currentStyle;
        l2 = this.textAlign.toLowerCase();
        switch (l2) {
          case "left":
          case "center":
          case "right":
            break;
          case "end":
            l2 = "ltr" == m.direction ? "right" : "left";
            break;
          case "start":
            l2 = "rtl" == m.direction ? "right" : "left";
            break;
          default:
            l2 = "left";
        }
        switch (this.textBaseline) {
          case "hanging":
          case "top":
            t2 = h.size / 1.75;
            break;
          case "middle":
            break;
          default:
          case null:
          case "alphabetic":
          case "ideographic":
          case "bottom":
            t2 = -h.size / 2.25;
        }
        switch (l2) {
          case "right":
            d3 = 1e3;
            r2 = 0.05;
            break;
          case "center":
            d3 = r2 = 500;
        }
        b = s(this, b + 0, c2 + t2);
        n.push('<g_vml_:line from="', -d3, ' 0" to="', r2, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
        e ? S(this, n) : T(
          this,
          n,
          { x: -d3, y: 0 },
          { x: r2, y: h.size }
        );
        e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0";
        b = k(b.x / q) + "," + k(b.y / q);
        n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d3, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a2), '" style="v-text-align:', l2, ";font:", N(p2), '" /></g_vml_:line>');
        this.element_.insertAdjacentHTML("beforeEnd", n.join(""));
      };
      d2.fillText = function(a2, b, c2, d3) {
        this.drawText_(a2, b, c2, d3, false);
      };
      d2.strokeText = function(a2, b, c2, d3) {
        this.drawText_(a2, b, c2, d3, true);
      };
      d2.measureText = function(a2) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var b = this.element_.ownerDocument;
        this.textMeasureEl_.innerHTML = "";
        this.textMeasureEl_.style.font = this.font;
        this.textMeasureEl_.appendChild(b.createTextNode(a2));
        return { width: this.textMeasureEl_.offsetWidth };
      };
      d2.clip = function() {
      };
      d2.arcTo = function() {
      };
      d2.createPattern = function(a2, b) {
        return new I(a2, b);
      };
      w.prototype.addColorStop = function(a2, b) {
        b = G(b);
        this.colors_.push({ offset: a2, color: b.color, alpha: b.alpha });
      };
      d2 = A.prototype = Error();
      d2.INDEX_SIZE_ERR = 1;
      d2.DOMSTRING_SIZE_ERR = 2;
      d2.HIERARCHY_REQUEST_ERR = 3;
      d2.WRONG_DOCUMENT_ERR = 4;
      d2.INVALID_CHARACTER_ERR = 5;
      d2.NO_DATA_ALLOWED_ERR = 6;
      d2.NO_MODIFICATION_ALLOWED_ERR = 7;
      d2.NOT_FOUND_ERR = 8;
      d2.NOT_SUPPORTED_ERR = 9;
      d2.INUSE_ATTRIBUTE_ERR = 10;
      d2.INVALID_STATE_ERR = 11;
      d2.SYNTAX_ERR = 12;
      d2.INVALID_MODIFICATION_ERR = 13;
      d2.NAMESPACE_ERR = 14;
      d2.INVALID_ACCESS_ERR = 15;
      d2.VALIDATION_ERR = 16;
      d2.TYPE_MISMATCH_ERR = 17;
      G_vmlCanvasManager = U;
      CanvasRenderingContext2D = C2;
      CanvasGradient = w;
      CanvasPattern = I;
      DOMException = A;
    }();
  }
});

// node_modules/@canvasjs/vue-charts/dist/vue-charts.js
var a = __toESM(require_canvasjs_min(), 1);
var c = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [n, r] of e)
    s[n] = r;
  return s;
};
var l = "Chart" in a ? a : window.CanvasJS;
var p = {
  props: {
    styles: {
      type: Object,
      default: () => ({})
    },
    options: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["chart-ref"],
  data() {
    return {
      chart: null,
      updateChart: true,
      containerStyle: {
        width: this.styles && this.styles.width ? this.styles.width : "100%",
        height: this.styles && this.styles.height ? this.styles.height : "360px",
        ...this.styles
      }
    };
  },
  watch: {
    options: {
      handler(t, e) {
        this.updateChart = t !== e;
      }
    }
  },
  updated() {
    this.chart && this.updateChart && (this.chart.options = this.options, this.chart.render());
  },
  mounted() {
    this.chart = new l.Chart(this.$refs.chartContainer, this.options), this.chart.render(), this.$emit("chart-ref", this.chart);
  },
  unmounted() {
    this.chart && this.chart.destroy();
  }
};
function d(t, e, s, n, r, f) {
  return openBlock(), createElementBlock("div", {
    ref: "chartContainer",
    style: normalizeStyle(r.containerStyle)
  }, null, 4);
}
var u = c(p, [["render", d]]);
var C = {
  install: (t, e) => {
    t.component("CanvasJSChart", u);
  }
};

// dep:@canvasjs_vue-charts
var canvasjs_vue_charts_default = C;
export {
  canvasjs_vue_charts_default as default
};
//# sourceMappingURL=@canvasjs_vue-charts.js.map
